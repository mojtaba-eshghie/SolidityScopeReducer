/// <reference types="node" />
import Decimal from "decimal.js";
import { BinaryOperation, EtherUnit, Expression, FunctionCall, IndexAccess, Literal, LiteralKind, TimeUnit, UnaryOperation, VariableDeclaration } from "../ast";
import { TypeNode } from "./ast";
import { InferType } from "./infer";
export type Value = Decimal | boolean | string | bigint | Buffer;
export declare class EvalError extends Error {
    expr?: Expression;
    constructor(msg: string, expr?: Expression);
}
export declare class NonConstantExpressionError extends EvalError {
    constructor(expr: Expression);
}
export declare function toDec(v: Value): Decimal;
export declare function toInt(v: Value): bigint;
export declare function castToType(v: Value, fromT: TypeNode | undefined, toT: TypeNode): Value;
export declare function isConstant(expr: Expression | VariableDeclaration): boolean;
export declare function evalLiteralImpl(kind: LiteralKind, value: string, subdenomination?: TimeUnit | EtherUnit): Value;
export declare function evalUnaryImpl(operator: string, value: Value): Value;
export declare function evalBinaryImpl(operator: string, left: Value, right: Value): Value;
export declare function evalLiteral(node: Literal): Value;
export declare function evalUnary(node: UnaryOperation, inference: InferType): Value;
export declare function evalBinary(node: BinaryOperation, inference: InferType): Value;
export declare function evalIndexAccess(node: IndexAccess, inference: InferType): Value;
export declare function evalFunctionCall(node: FunctionCall, inference: InferType): Value;
/**
 * Given a constant expression `expr` evaluate it to a concrete `Value`.
 * If `expr` is not constant throw `NonConstantExpressionError`.
 *
 * @todo The order of some operations changed in some version.
 * Current implementation does not yet take it into an account.
 */
export declare function evalConstantExpr(node: Expression | VariableDeclaration, inference: InferType): Value;
//# sourceMappingURL=eval_const.d.ts.map