"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decimalToRational = exports.clampIntToType = exports.smallestFittingType = exports.castable = exports.isVisiblityExternallyCallable = exports.getFallbackRecvFuns = exports.getABIEncoderVersion = exports.fixedBytesTypeToIntType = exports.enumToIntType = exports.isReferenceType = exports.getFQDefName = exports.generalizeType = exports.specializeType = exports.stripSingletonParens = exports.mergeFunTypes = exports.inferCommonVisiblity = exports.getTypeForCompilerVersion = exports.BINARY_OPERATOR_GROUPS = exports.CALL_BUILTINS = exports.SUBDENOMINATION_MULTIPLIERS = void 0;
const decimal_js_1 = __importDefault(require("decimal.js"));
const semver_1 = require("semver");
const ast_1 = require("../ast");
const misc_1 = require("../misc");
const types_1 = require("../types");
const abi_1 = require("./abi");
const ast_2 = require("./ast");
exports.SUBDENOMINATION_MULTIPLIERS = new Map([
    ["seconds", new decimal_js_1.default(1)],
    ["minutes", new decimal_js_1.default(60)],
    ["hours", new decimal_js_1.default(3600)],
    ["days", new decimal_js_1.default(24 * 3600)],
    ["weeks", new decimal_js_1.default(7 * 24 * 3600)],
    ["years", new decimal_js_1.default(365 * 24 * 3600)],
    ["wei", new decimal_js_1.default(1)],
    ["gwei", new decimal_js_1.default(10 ** 9)],
    ["szabo", new decimal_js_1.default(10 ** 12)],
    ["finney", new decimal_js_1.default(10).toPower(15)],
    ["ether", new decimal_js_1.default(10).toPower(18)]
]);
exports.CALL_BUILTINS = ["call", "callcode", "staticcall", "delegatecall", "transfer", "send"];
exports.BINARY_OPERATOR_GROUPS = {
    Arithmetic: ["+", "-", "*", "/", "%", "**"],
    Bitwise: ["<<", ">>", "&", "|", "^"],
    Comparison: ["<", ">", "<=", ">="],
    Equality: ["==", "!="],
    Logical: ["&&", "||"]
};
function getTypeForCompilerVersion(typing, compilerVersion) {
    if (typing instanceof ast_2.TypeNode) {
        return typing;
    }
    const [type, version] = typing;
    return (0, semver_1.satisfies)(compilerVersion, version) ? type : undefined;
}
exports.getTypeForCompilerVersion = getTypeForCompilerVersion;
/**
 * Given 2 function pointer's visibilities infer a common visibility thats compatible with both.
 * This is used to infer the visibility of the expression `flag ? fun1 : fun2` where fun1 and fun2 are
 * function pointers.
 */
function inferCommonVisiblity(a, b) {
    const visiblityOrder = [
        ast_1.FunctionVisibility.External,
        ast_1.FunctionVisibility.Public,
        ast_1.FunctionVisibility.Internal,
        ast_1.FunctionVisibility.Default,
        ast_1.FunctionVisibility.Private
    ];
    if (a == b) {
        return a;
    }
    if (visiblityOrder.indexOf(a) > visiblityOrder.indexOf(b)) {
        [b, a] = [a, b];
    }
    if (a === ast_1.FunctionVisibility.External) {
        return b == ast_1.FunctionVisibility.Public ? ast_1.FunctionVisibility.External : undefined;
    }
    return ast_1.FunctionVisibility.Internal;
}
exports.inferCommonVisiblity = inferCommonVisiblity;
/**
 * Given two `FunctionType`s/`BuiltinFunctionType`s/`FunctionSetType`s `a` and `b`
 * return a `FunctionSetType` that includes everything in `a` and `b`.
 */
function mergeFunTypes(a, b) {
    const funs = [];
    if (a instanceof ast_2.FunctionType || a instanceof ast_2.BuiltinFunctionType) {
        funs.push(a);
    }
    else {
        funs.push(...a.defs);
    }
    if (b instanceof ast_2.FunctionType || b instanceof ast_2.BuiltinFunctionType) {
        funs.push(b);
    }
    else {
        funs.push(...b.defs);
    }
    return new ast_2.FunctionLikeSetType(funs);
}
exports.mergeFunTypes = mergeFunTypes;
/**
 * Strip any singleton parens from expressions. I.e. given (((e))) returns e.
 */
function stripSingletonParens(e) {
    while (e instanceof ast_1.TupleExpression && e.vOriginalComponents.length === 1) {
        const comp = e.vOriginalComponents[0];
        (0, misc_1.assert)(comp !== null, 'Unexpected "null" component in tuple with single element');
        e = comp;
    }
    return e;
}
exports.stripSingletonParens = stripSingletonParens;
/**
 * Given a general type 'pattern' that doesn't contain any data locations, and a data location,
 * produce a concrete instance of the general type for the target location.
 * This is the inverse of `specializeType()`
 *
 * Note that this has to recursively fix sub-parts of compount types such as arrays and maps.
 * Note that this doesn't handle all possible expression types - just the ones that that may appear
 * in a variable declaration.
 *
 * @param type - general type "pattern"
 * @param loc - target location to specialize to
 * @returns specialized type
 */
function specializeType(type, loc) {
    (0, misc_1.assert)(!(type instanceof ast_2.PointerType), "Unexpected pointer type {0} in concretization.", type);
    (0, misc_1.assert)(!(type instanceof ast_2.TupleType), "Unexpected tuple type {0} in concretization.", type);
    // bytes and string
    if (type instanceof ast_2.PackedArrayType) {
        return new ast_2.PointerType(type, loc);
    }
    if (type instanceof ast_2.ArrayType) {
        const concreteElT = specializeType(type.elementT, loc);
        return new ast_2.PointerType(new ast_2.ArrayType(concreteElT, type.size), loc);
    }
    if (type instanceof ast_2.UserDefinedType) {
        const def = type.definition;
        (0, misc_1.assert)(def !== undefined, "Can't concretize user defined type {0} with no corresponding definition.", type);
        if (def instanceof ast_1.StructDefinition) {
            return new ast_2.PointerType(type, loc);
        }
        // Enums are a value type
        return type;
    }
    if (type instanceof ast_2.MappingType) {
        // Always treat map keys as in-memory copies
        const concreteKeyT = specializeType(type.keyType, ast_1.DataLocation.Memory);
        // The result of map indexing is always a pointer to a value that lives in storage
        const concreteValueT = specializeType(type.valueType, ast_1.DataLocation.Storage);
        // Maps always live in storage
        return new ast_2.PointerType(new ast_2.MappingType(concreteKeyT, concreteValueT), ast_1.DataLocation.Storage);
    }
    // TODO: What to do about string literals?
    // All other types are "value" types.
    return type;
}
exports.specializeType = specializeType;
/**
 * Given a `TypeNode` `type` that is specialized to some storage location,
 * compute the original 'general' type that is independent of location.
 * This is the inverse of `specializeType()`
 *
 * Note that this doesn't handle all possible expression types - just the ones that that may appear
 * in a variable declaration.
 *
 * @param type - specialized type
 * @returns computed generalized type.
 */
function generalizeType(type) {
    if (type instanceof ast_2.PointerType) {
        const [generalizedTo] = generalizeType(type.to);
        return [generalizedTo, type.location];
    }
    if (type instanceof ast_2.ArrayType) {
        const [innerT] = generalizeType(type.elementT);
        return [new ast_2.ArrayType(innerT, type.size), undefined];
    }
    if (type instanceof ast_2.MappingType) {
        const [genearlKeyT] = generalizeType(type.keyType);
        const [generalValueT] = generalizeType(type.valueType);
        return [new ast_2.MappingType(genearlKeyT, generalValueT), ast_1.DataLocation.Storage];
    }
    if (type instanceof ast_2.TypeNameType) {
        return generalizeType(type.type);
    }
    if (type instanceof ast_2.TupleType) {
        return [
            new ast_2.TupleType(type.elements.map((elT) => (elT === null ? null : generalizeType(elT)[0]))),
            undefined
        ];
    }
    return [type, undefined];
}
exports.generalizeType = generalizeType;
function getFQDefName(def) {
    return def.vScope instanceof ast_1.ContractDefinition ? `${def.vScope.name}.${def.name}` : def.name;
}
exports.getFQDefName = getFQDefName;
function isReferenceType(generalT) {
    return ((generalT instanceof ast_2.UserDefinedType && generalT.definition instanceof ast_1.StructDefinition) ||
        generalT instanceof ast_2.ArrayType ||
        generalT instanceof ast_2.PackedArrayType ||
        generalT instanceof ast_2.MappingType);
}
exports.isReferenceType = isReferenceType;
function enumToIntType(decl) {
    const length = decl.children.length;
    let size;
    for (let n = 8; n <= 32; n += 8) {
        if (length <= 2 ** n) {
            size = n;
            break;
        }
    }
    (0, misc_1.assert)(size !== undefined, "Unable to detect enum type size - member count exceeds 2 ** 32", decl);
    return new ast_2.IntType(size, false);
}
exports.enumToIntType = enumToIntType;
function fixedBytesTypeToIntType(type) {
    return new ast_2.IntType(type.size * 8, false, type.src);
}
exports.fixedBytesTypeToIntType = fixedBytesTypeToIntType;
function getABIEncoderVersion(unit, compilerVersion) {
    const predefined = unit.abiEncoderVersion;
    if (predefined) {
        return predefined;
    }
    return (0, semver_1.lt)(compilerVersion, "0.8.0") ? abi_1.ABIEncoderVersion.V1 : abi_1.ABIEncoderVersion.V2;
}
exports.getABIEncoderVersion = getABIEncoderVersion;
function getFallbackRecvFuns(contract) {
    const res = [];
    for (const base of contract.vLinearizedBaseContracts) {
        for (const fun of base.vFunctions) {
            if (fun.kind === ast_1.FunctionKind.Fallback || fun.kind === ast_1.FunctionKind.Receive) {
                res.push(fun);
            }
        }
    }
    return res;
}
exports.getFallbackRecvFuns = getFallbackRecvFuns;
function isVisiblityExternallyCallable(a) {
    return a === ast_1.FunctionVisibility.External || a === ast_1.FunctionVisibility.Public;
}
exports.isVisiblityExternallyCallable = isVisiblityExternallyCallable;
function functionVisibilitiesCompatible(a, b) {
    return (a === b ||
        (a === ast_1.FunctionVisibility.External && isVisiblityExternallyCallable(b)) ||
        (b === ast_1.FunctionVisibility.External && isVisiblityExternallyCallable(a)) ||
        (a !== ast_1.FunctionVisibility.External && b !== ast_1.FunctionVisibility.External));
}
/**
 * Return true IFF `fromT` can be implicitly casted to `toT`
 */
function castable(fromT, toT, compilerVersion) {
    if ((0, misc_1.eq)(fromT, toT)) {
        return true;
    }
    /**
     * When casting arrays to storage, we can cast fixed sized to dynamically sized arrays
     */
    if (fromT instanceof ast_2.PointerType &&
        fromT.to instanceof ast_2.ArrayType &&
        toT instanceof ast_2.PointerType &&
        toT.to instanceof ast_2.ArrayType &&
        fromT.to.size !== undefined &&
        toT.to.size === undefined &&
        toT.location === ast_1.DataLocation.Storage &&
        (0, misc_1.eq)(fromT.to.elementT, toT.to.elementT)) {
        return true;
    }
    if (fromT instanceof ast_2.PointerType && toT instanceof ast_2.PointerType && (0, misc_1.eq)(fromT.to, toT.to)) {
        return true;
    }
    if (fromT instanceof ast_2.StringLiteralType) {
        /**
         * @todo Should we make an explicit check that string literal fits to bytes size?
         * Note that string length is not the same as count of bytes in string due to multibyte chars.
         * Also for hex string literals we should check evenness of length.
         */
        if (toT instanceof ast_2.FixedBytesType) {
            return true;
        }
        if (toT instanceof ast_2.PointerType && toT.to instanceof ast_2.StringType) {
            return true;
        }
        if (toT instanceof ast_2.PointerType && toT.to instanceof ast_2.BytesType) {
            return true;
        }
    }
    if (fromT instanceof ast_2.IntLiteralType) {
        // In solidity >= 0.5.0 negative constants can't be vast to bytes
        if (toT instanceof ast_2.FixedBytesType &&
            fromT.literal !== undefined &&
            fitsNBytes(fromT.literal, toT.size, false) &&
            (0, semver_1.gte)(compilerVersion, "0.5.0")) {
            return true;
        }
        // In solidity < 0.5.0 negative constants can be vast to bytes
        if (toT instanceof ast_2.FixedBytesType &&
            fromT.literal !== undefined &&
            (fitsNBytes(fromT.literal, toT.size, false) ||
                fitsNBytes(fromT.literal, toT.size, true)) &&
            (0, semver_1.lt)(compilerVersion, "0.5.0")) {
            return true;
        }
        if (toT instanceof ast_2.IntType && fromT.literal !== undefined && toT.fits(fromT.literal)) {
            return true;
        }
        if (toT instanceof ast_2.AddressType &&
            fromT.literal !== undefined &&
            types_1.types.uint160.fits(fromT.literal) &&
            (0, semver_1.lt)(compilerVersion, "0.5.0")) {
            return true;
        }
    }
    // We can implicitly cast from payable to address
    if (fromT instanceof ast_2.AddressType && toT instanceof ast_2.AddressType && !toT.payable) {
        return true;
    }
    // We can implicitly cast from a fixed bytes type to a larger fixed bytes type
    if (fromT instanceof ast_2.FixedBytesType && toT instanceof ast_2.FixedBytesType && toT.size > fromT.size) {
        return true;
    }
    if (fromT instanceof ast_2.IntType) {
        // We can implicitly cast from a smaller to a larger int type with the same sign
        if (toT instanceof ast_2.IntType && fromT.signed == toT.signed && fromT.nBits < toT.nBits) {
            return true;
        }
        // In Solidity <=0.8.0 we can cast an unsigned type to a bigger signed type
        if (toT instanceof ast_2.IntType && !fromT.signed && toT.signed && fromT.nBits < toT.nBits) {
            return true;
        }
        /**
         * Can implicitly cast from unsigned ints <=160 bits to address
         */
        if (toT instanceof ast_2.AddressType && !fromT.signed && fromT.nBits <= 160) {
            return true;
        }
    }
    if (fromT instanceof ast_2.UserDefinedType && fromT.definition instanceof ast_1.ContractDefinition) {
        if (toT instanceof ast_2.AddressType) {
            // We can implicitly cast from contract to payable address if it has a payable receive/fallback function
            if (toT.payable) {
                return (0, misc_1.forAny)(getFallbackRecvFuns(fromT.definition), (fn) => fn.stateMutability === ast_1.FunctionStateMutability.Payable);
            }
            // We can implicitly cast from contract to non-payable address
            return true;
        }
        // We can implicitly up-cast a contract
        if (toT instanceof ast_2.UserDefinedType && toT.definition instanceof ast_1.ContractDefinition) {
            return fromT.definition.isSubclassOf(toT.definition);
        }
    }
    if (fromT instanceof ast_2.FunctionType &&
        toT instanceof ast_2.FunctionType &&
        (0, misc_1.eq)(new ast_2.TupleType(fromT.parameters), new ast_2.TupleType(toT.parameters)) &&
        (0, misc_1.eq)(new ast_2.TupleType(fromT.returns), new ast_2.TupleType(toT.returns)) &&
        functionVisibilitiesCompatible(fromT.visibility, toT.visibility) &&
        fromT.mutability === toT.mutability) {
        return true;
    }
    return false;
}
exports.castable = castable;
const signedLimits = [];
const unsignedLimits = [];
for (let i = 1n; i <= 32n; i++) {
    unsignedLimits.push([0n, 2n ** (i * 8n) - 1n]);
    signedLimits.push([-(2n ** (i * 8n - 1n)), 2n ** (i * 8n - 1n) - 1n]);
}
function fitsNBytes(literal, nBytes, signed) {
    const limits = signed ? signedLimits : unsignedLimits;
    return literal >= limits[nBytes - 1][0] && literal <= limits[nBytes - 1][1];
}
/**
 * Find the smallest concrete int type that can hold the passed in `literals`.
 */
function smallestFittingType(...literals) {
    /// TODO: Need a test for this logic that checks the boundary conditions
    /// when the literals include the MIN/MAX for both signed and unsigned types
    const unsigned = (0, misc_1.forAll)(literals, (literal) => literal >= 0n);
    const limits = unsigned ? unsignedLimits : signedLimits;
    for (let i = 0; i < limits.length; i++) {
        let fitsAll = true;
        for (const literal of literals) {
            if (!(limits[i][0] <= literal && literal <= limits[i][1])) {
                fitsAll = false;
                break;
            }
        }
        if (fitsAll) {
            return new ast_2.IntType(8 * (i + 1), !unsigned);
        }
    }
    return undefined;
}
exports.smallestFittingType = smallestFittingType;
/**
 * Helper to cast the bigint `val` to the `IntType` `type`.
 */
function clampIntToType(val, type) {
    const min = type.min();
    const max = type.max();
    const size = max - min + 1n;
    return val < min ? ((val - max) % size) + max : ((val - min) % size) + min;
}
exports.clampIntToType = clampIntToType;
function decimalToRational(d) {
    if (!d.isFinite()) {
        throw new Error(`Unexpected infinite rational ${d.toString()} in decimalToRational`);
    }
    const valStr = d.toFixed();
    const dotPos = valStr.indexOf(".");
    (0, misc_1.assert)(dotPos !== -1, `Missing decimal point in {0}`, valStr);
    return {
        numerator: BigInt(valStr.replace(".", "")),
        denominator: 10n ** BigInt(valStr.length - dotPos - 1)
    };
}
exports.decimalToRational = decimalToRational;
//# sourceMappingURL=utils.js.map