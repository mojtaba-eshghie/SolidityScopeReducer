"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.evalConstantExpr = exports.evalFunctionCall = exports.evalIndexAccess = exports.evalBinary = exports.evalUnary = exports.evalLiteral = exports.evalBinaryImpl = exports.evalUnaryImpl = exports.evalLiteralImpl = exports.isConstant = exports.castToType = exports.toInt = exports.toDec = exports.NonConstantExpressionError = exports.EvalError = void 0;
const decimal_js_1 = __importDefault(require("decimal.js"));
const ast_1 = require("../ast");
const misc_1 = require("../misc");
const ast_2 = require("./ast");
const utils_1 = require("./utils");
/**
 * Tune up precision of decimal values to follow Solidity behavior.
 * Be careful with precision - setting it to large values causes NodeJS to crash.
 *
 * @see https://mikemcl.github.io/decimal.js/#precision
 */
decimal_js_1.default.set({ precision: 100 });
class EvalError extends Error {
    constructor(msg, expr) {
        super(msg);
        this.expr = expr;
    }
}
exports.EvalError = EvalError;
class NonConstantExpressionError extends EvalError {
    constructor(expr) {
        super(`Found non-constant expression ${(0, misc_1.pp)(expr)} during constant evaluation`, expr);
    }
}
exports.NonConstantExpressionError = NonConstantExpressionError;
function str(value) {
    return value instanceof decimal_js_1.default ? value.toString() : (0, misc_1.pp)(value);
}
function toDec(v) {
    if (v instanceof decimal_js_1.default) {
        return v;
    }
    if (typeof v === "bigint") {
        return new decimal_js_1.default(v.toString());
    }
    if (typeof v === "string") {
        return new decimal_js_1.default(v === "" ? 0 : "0x" + Buffer.from(v, "utf-8").toString("hex"));
    }
    if (v instanceof Buffer) {
        return new decimal_js_1.default(v.length === 0 ? 0 : "0x" + v.toString("hex"));
    }
    throw new Error(`Expected number not ${v}`);
}
exports.toDec = toDec;
function toInt(v) {
    if (typeof v === "bigint") {
        return v;
    }
    if (v instanceof decimal_js_1.default && v.isInt()) {
        return BigInt(v.toHex());
    }
    if (typeof v === "string") {
        return v === "" ? 0n : BigInt("0x" + Buffer.from(v, "utf-8").toString("hex"));
    }
    if (v instanceof Buffer) {
        return v.length === 0 ? 0n : BigInt("0x" + v.toString("hex"));
    }
    throw new Error(`Expected integer not ${v}`);
}
exports.toInt = toInt;
function demoteFromDec(d) {
    return d.isInt() ? BigInt(d.toFixed()) : d;
}
function castToType(v, fromT, toT) {
    if (typeof v === "bigint") {
        if (toT instanceof ast_2.IntType) {
            return (0, utils_1.clampIntToType)(v, toT);
        }
        if (toT instanceof ast_2.FixedBytesType) {
            if (fromT instanceof ast_2.FixedBytesType && fromT.size < toT.size) {
                return BigInt("0x" + v.toString(16).padEnd(toT.size * 2, "0"));
            }
            return (0, utils_1.clampIntToType)(v, (0, utils_1.fixedBytesTypeToIntType)(toT));
        }
    }
    if (typeof v === "string") {
        if (toT instanceof ast_2.BytesType) {
            return Buffer.from(v, "utf-8");
        }
        if (toT instanceof ast_2.FixedBytesType) {
            if (v.length === 0) {
                return 0n;
            }
            const buf = Buffer.from(v, "utf-8");
            if (buf.length < toT.size) {
                return BigInt("0x" + buf.toString("hex").padEnd(toT.size * 2, "0"));
            }
            return BigInt("0x" + buf.slice(0, toT.size).toString("hex"));
        }
    }
    if (v instanceof Buffer) {
        if (toT instanceof ast_2.StringType) {
            return v.toString("utf-8");
        }
        if (toT instanceof ast_2.FixedBytesType) {
            if (v.length === 0) {
                return 0n;
            }
            if (v.length < toT.size) {
                return BigInt("0x" + v.toString("hex").padEnd(toT.size * 2, "0"));
            }
            return BigInt("0x" + v.slice(0, toT.size).toString("hex"));
        }
    }
    return v;
}
exports.castToType = castToType;
function isConstant(expr) {
    if (expr instanceof ast_1.Literal) {
        return true;
    }
    if (expr instanceof ast_1.UnaryOperation && isConstant(expr.vSubExpression)) {
        return true;
    }
    if (expr instanceof ast_1.VariableDeclaration &&
        expr.constant &&
        expr.vValue &&
        isConstant(expr.vValue)) {
        return true;
    }
    if (expr instanceof ast_1.BinaryOperation &&
        isConstant(expr.vLeftExpression) &&
        isConstant(expr.vRightExpression)) {
        return true;
    }
    if (expr instanceof ast_1.TupleExpression &&
        !expr.isInlineArray &&
        expr.vOriginalComponents.length === 1 &&
        expr.vOriginalComponents[0] &&
        isConstant(expr.vOriginalComponents[0])) {
        return true;
    }
    /// TODO: We can be more precise here. Conditionals are also constant if
    /// 1) vCondition is constant, and only the selected branch is constant
    /// 2) vCondition is not constant, but both branches are constant and equal (not likely in practice)
    if (expr instanceof ast_1.Conditional &&
        isConstant(expr.vCondition) &&
        isConstant(expr.vTrueExpression) &&
        isConstant(expr.vFalseExpression)) {
        return true;
    }
    if (expr instanceof ast_1.Identifier || expr instanceof ast_1.MemberAccess) {
        return (expr.vReferencedDeclaration instanceof ast_1.VariableDeclaration &&
            isConstant(expr.vReferencedDeclaration));
    }
    if (expr instanceof ast_1.IndexAccess) {
        return (isConstant(expr.vBaseExpression) &&
            expr.vIndexExpression !== undefined &&
            isConstant(expr.vIndexExpression));
    }
    if (expr instanceof ast_1.FunctionCall &&
        expr.kind === ast_1.FunctionCallKind.TypeConversion &&
        isConstant(expr.vArguments[0])) {
        return true;
    }
    return false;
}
exports.isConstant = isConstant;
function evalLiteralImpl(kind, value, subdenomination) {
    if (kind === ast_1.LiteralKind.Bool) {
        return value === "true";
    }
    if (kind === ast_1.LiteralKind.HexString) {
        return Buffer.from(value, "hex");
    }
    if (kind === ast_1.LiteralKind.String || kind === ast_1.LiteralKind.UnicodeString) {
        return value;
    }
    if (kind === ast_1.LiteralKind.Number) {
        const dec = new decimal_js_1.default(value.replaceAll("_", ""));
        const val = dec.isInteger() ? BigInt(dec.toFixed()) : dec;
        if (subdenomination) {
            const multiplier = utils_1.SUBDENOMINATION_MULTIPLIERS.get(subdenomination);
            if (multiplier === undefined) {
                throw new EvalError(`Unknown denomination ${subdenomination}`);
            }
            if (val instanceof decimal_js_1.default) {
                return demoteFromDec(val.times(multiplier));
            }
            return val * BigInt(multiplier.toFixed());
        }
        return val;
    }
    throw new EvalError(`Unsupported literal kind "${kind}"`);
}
exports.evalLiteralImpl = evalLiteralImpl;
function evalUnaryImpl(operator, value) {
    if (operator === "!") {
        if (typeof value === "boolean") {
            return !value;
        }
        throw new EvalError(`Expected ${str(value)} to be boolean`);
    }
    if (operator === "~") {
        if (typeof value === "bigint") {
            return ~value;
        }
        throw new EvalError(`Expected ${str(value)} to be a bigint`);
    }
    if (operator === "+") {
        if (value instanceof decimal_js_1.default || typeof value === "bigint") {
            return value;
        }
        throw new EvalError(`Expected ${str(value)} to be a bigint or a decimal`);
    }
    if (operator === "-") {
        if (value instanceof decimal_js_1.default) {
            return value.negated();
        }
        if (typeof value === "bigint") {
            return -value;
        }
        throw new EvalError(`Expected ${str(value)} to be a bigint or a decimal`);
    }
    throw new EvalError(`Unable to process ${operator}${str(value)}`);
}
exports.evalUnaryImpl = evalUnaryImpl;
function evalBinaryImpl(operator, left, right) {
    if (utils_1.BINARY_OPERATOR_GROUPS.Logical.includes(operator)) {
        if (!(typeof left === "boolean" && typeof right === "boolean")) {
            throw new EvalError(`${operator} expects booleans not ${str(left)} and ${str(right)}`);
        }
        if (operator === "&&") {
            return left && right;
        }
        if (operator === "||") {
            return left || right;
        }
        throw new EvalError(`Unknown logical operator ${operator}`);
    }
    if (utils_1.BINARY_OPERATOR_GROUPS.Equality.includes(operator)) {
        if (typeof left === "string" && typeof right === "string") {
            throw new EvalError(`${operator} not allowed for strings ${str(left)} and ${str(right)}`);
        }
        let isEqual;
        if (typeof left === "boolean" || typeof right === "boolean") {
            isEqual = left === right;
        }
        else {
            const leftDec = toDec(left);
            const rightDec = toDec(right);
            isEqual = leftDec.equals(rightDec);
        }
        if (operator === "==") {
            return isEqual;
        }
        if (operator === "!=") {
            return !isEqual;
        }
        throw new EvalError(`Unknown equality operator ${operator}`);
    }
    if (utils_1.BINARY_OPERATOR_GROUPS.Comparison.includes(operator)) {
        if (typeof left === "string" && typeof right === "string") {
            throw new EvalError(`${operator} not allowed for strings ${str(left)} and ${str(right)}`);
        }
        const leftDec = toDec(left);
        const rightDec = toDec(right);
        if (operator === "<") {
            return leftDec.lessThan(rightDec);
        }
        if (operator === "<=") {
            return leftDec.lessThanOrEqualTo(rightDec);
        }
        if (operator === ">") {
            return leftDec.greaterThan(rightDec);
        }
        if (operator === ">=") {
            return leftDec.greaterThanOrEqualTo(rightDec);
        }
        throw new EvalError(`Unknown comparison operator ${operator}`);
    }
    if (utils_1.BINARY_OPERATOR_GROUPS.Arithmetic.includes(operator)) {
        const leftDec = toDec(left);
        const rightDec = toDec(right);
        let res;
        if (operator === "+") {
            res = leftDec.plus(rightDec);
        }
        else if (operator === "-") {
            res = leftDec.minus(rightDec);
        }
        else if (operator === "*") {
            res = leftDec.times(rightDec);
        }
        else if (operator === "/") {
            res = leftDec.div(rightDec);
        }
        else if (operator === "%") {
            res = leftDec.modulo(rightDec);
        }
        else if (operator === "**") {
            res = leftDec.pow(rightDec);
        }
        else {
            throw new EvalError(`Unknown arithmetic operator ${operator}`);
        }
        return demoteFromDec(res);
    }
    if (utils_1.BINARY_OPERATOR_GROUPS.Bitwise.includes(operator)) {
        const leftInt = toInt(left);
        const rightInt = toInt(right);
        if (operator === "<<") {
            return leftInt << rightInt;
        }
        if (operator === ">>") {
            return leftInt >> rightInt;
        }
        if (operator === "|") {
            return leftInt | rightInt;
        }
        if (operator === "&") {
            return leftInt & rightInt;
        }
        if (operator === "^") {
            return leftInt ^ rightInt;
        }
        throw new EvalError(`Unknown bitwise operator ${operator}`);
    }
    throw new EvalError(`Unable to process ${str(left)} ${operator} ${str(right)}`);
}
exports.evalBinaryImpl = evalBinaryImpl;
function evalLiteral(node) {
    let kind = node.kind;
    /**
     * An example:
     *
     * ```solidity
     * contract Test {
     *     bytes4 constant s = "\x75\x32\xea\xac";
     * }
     * ```
     *
     * Note that compiler leaves "null" as string value,
     * so we have to rely on hexadecimal representation instead.
     */
    if ((kind === ast_1.LiteralKind.String || kind === ast_1.LiteralKind.UnicodeString) && node.value == null) {
        kind = ast_1.LiteralKind.HexString;
    }
    const value = kind === ast_1.LiteralKind.HexString ? node.hexValue : node.value;
    try {
        return evalLiteralImpl(kind, value, node.subdenomination);
    }
    catch (e) {
        if (e instanceof EvalError) {
            e.expr = node;
        }
        throw e;
    }
}
exports.evalLiteral = evalLiteral;
function evalUnary(node, inference) {
    try {
        const subT = inference.typeOf(node.vSubExpression);
        const sub = evalConstantExpr(node.vSubExpression, inference);
        if (subT instanceof ast_2.NumericLiteralType) {
            return evalUnaryImpl(node.operator, sub);
        }
        const resT = inference.typeOfUnaryOperation(node);
        const res = evalUnaryImpl(node.operator, sub);
        return castToType(res, undefined, resT);
    }
    catch (e) {
        if (e instanceof EvalError && e.expr === undefined) {
            e.expr = node;
        }
        throw e;
    }
}
exports.evalUnary = evalUnary;
function evalBinary(node, inference) {
    try {
        const leftT = inference.typeOf(node.vLeftExpression);
        const rightT = inference.typeOf(node.vRightExpression);
        let left = evalConstantExpr(node.vLeftExpression, inference);
        let right = evalConstantExpr(node.vRightExpression, inference);
        if (leftT instanceof ast_2.NumericLiteralType && rightT instanceof ast_2.NumericLiteralType) {
            return evalBinaryImpl(node.operator, left, right);
        }
        if (node.operator !== "**" && node.operator !== ">>" && node.operator !== "<<") {
            const commonT = inference.inferCommonType(leftT, rightT);
            left = castToType(left, leftT, commonT);
            right = castToType(right, rightT, commonT);
        }
        const res = evalBinaryImpl(node.operator, left, right);
        const resT = inference.typeOfBinaryOperation(node);
        return castToType(res, undefined, resT);
    }
    catch (e) {
        if (e instanceof EvalError && e.expr === undefined) {
            e.expr = node;
        }
        throw e;
    }
}
exports.evalBinary = evalBinary;
function evalIndexAccess(node, inference) {
    const base = evalConstantExpr(node.vBaseExpression, inference);
    const index = evalConstantExpr(node.vIndexExpression, inference);
    if (!(typeof index === "bigint" || index instanceof decimal_js_1.default)) {
        throw new EvalError(`Unexpected non-numeric index into base in expression ${(0, misc_1.pp)(node)}`, node);
    }
    const plainIndex = index instanceof decimal_js_1.default ? index.toNumber() : Number(index);
    if (typeof base === "bigint" || base instanceof decimal_js_1.default) {
        let baseHex = base instanceof decimal_js_1.default ? base.toHex().slice(2) : base.toString(16);
        if (baseHex.length % 2 !== 0) {
            baseHex = "0" + baseHex;
        }
        const indexInHex = plainIndex * 2;
        if (indexInHex >= baseHex.length) {
            throw new EvalError(`Out-of-bounds index access ${indexInHex} (originally ${plainIndex}) to "${baseHex}"`);
        }
        return BigInt("0x" + baseHex.slice(indexInHex, indexInHex + 2));
    }
    if (base instanceof Buffer) {
        const res = base.at(plainIndex);
        if (res === undefined) {
            throw new EvalError(`Out-of-bounds index access ${plainIndex} to ${base.toString("hex")}`);
        }
        return BigInt(res);
    }
    throw new EvalError(`Unable to process ${(0, misc_1.pp)(node)}`, node);
}
exports.evalIndexAccess = evalIndexAccess;
function evalFunctionCall(node, inference) {
    if (node.kind !== ast_1.FunctionCallKind.TypeConversion) {
        throw new EvalError(`Expected function call to have kind "${ast_1.FunctionCallKind.TypeConversion}", but got "${node.kind}" instead`, node);
    }
    if (!(node.vExpression instanceof ast_1.ElementaryTypeNameExpression)) {
        throw new EvalError(`Expected function call expression to be an ${ast_1.ElementaryTypeNameExpression.name}, but got "${node.type}" instead`, node);
    }
    const val = evalConstantExpr(node.vArguments[0], inference);
    const fromT = inference.typeOf(node.vArguments[0]);
    const toT = inference.typeOfElementaryTypeNameExpression(node.vExpression).type;
    return castToType(val, fromT, toT);
}
exports.evalFunctionCall = evalFunctionCall;
/**
 * Given a constant expression `expr` evaluate it to a concrete `Value`.
 * If `expr` is not constant throw `NonConstantExpressionError`.
 *
 * @todo The order of some operations changed in some version.
 * Current implementation does not yet take it into an account.
 */
function evalConstantExpr(node, inference) {
    if (!isConstant(node)) {
        throw new NonConstantExpressionError(node);
    }
    if (node instanceof ast_1.Literal) {
        return evalLiteral(node);
    }
    if (node instanceof ast_1.UnaryOperation) {
        return evalUnary(node, inference);
    }
    if (node instanceof ast_1.BinaryOperation) {
        return evalBinary(node, inference);
    }
    if (node instanceof ast_1.TupleExpression) {
        return evalConstantExpr(node.vOriginalComponents[0], inference);
    }
    if (node instanceof ast_1.Conditional) {
        return evalConstantExpr(node.vCondition, inference)
            ? evalConstantExpr(node.vTrueExpression, inference)
            : evalConstantExpr(node.vFalseExpression, inference);
    }
    if (node instanceof ast_1.VariableDeclaration) {
        return evalConstantExpr(node.vValue, inference);
    }
    if (node instanceof ast_1.Identifier || node instanceof ast_1.MemberAccess) {
        return evalConstantExpr(node.vReferencedDeclaration, inference);
    }
    if (node instanceof ast_1.IndexAccess) {
        return evalIndexAccess(node, inference);
    }
    if (node instanceof ast_1.FunctionCall) {
        return evalFunctionCall(node, inference);
    }
    /**
     * Note that from the point of view of the type system constant conditionals and
     * indexing in constant array literals are not considered constant expressions.
     * So for now we don't support them, but we may change that in the future.
     */
    throw new EvalError(`Unable to evaluate constant expression ${(0, misc_1.pp)(node)}`, node);
}
exports.evalConstantExpr = evalConstantExpr;
//# sourceMappingURL=eval_const.js.map