import { ASTNode, Assignment, BinaryOperation, Conditional, ContractDefinition, ElementaryTypeNameExpression, ErrorDefinition, EventDefinition, Expression, FunctionCall, FunctionDefinition, Identifier, IndexAccess, IndexRangeAccess, Literal, MemberAccess, ModifierDefinition, NewExpression, TryCatchClause, TupleExpression, TypeName, UnaryOperation, VariableDeclaration } from "../ast";
import { DataLocation } from "../ast/constants";
import { ABIEncoderVersion } from "./abi";
import { BuiltinFunctionType, ErrorType, EventType, FunctionType, IntLiteralType, IntType, TypeNameType, TypeNode } from "./ast";
/**
 * Some builtins have types that are not easy to express with our current hacky polymorphic support.
 * For those we have the custom type constructors before, that introspect the AST to determine the type.
 */
export declare const builtinTypes: {
    [key: string]: (arg: ASTNode) => TypeNode;
};
export declare class InferType {
    readonly version: string;
    constructor(version: string);
    /**
     * Infer the type of the assignment `node`. (In solidity assignments are expressions)
     */
    typeOfAssignment(node: Assignment): TypeNode;
    /**
     * Given to numeric expressions infer a common type to which they can both be implicitly casted.
     */
    inferCommonIntType(a: IntType | IntLiteralType, b: IntType | IntLiteralType): IntType | IntLiteralType;
    /**
     * Given two types `a` and `b` infer the common type that they are both
     * implicitly casted to, when appearing in a binary op/conditional.
     * Its currently usually `a` or `b`
     */
    inferCommonType(a: TypeNode, b: TypeNode): TypeNode;
    typeOfCustomizableOperation(node: UnaryOperation | BinaryOperation): TypeNode | undefined;
    /**
     * Infer the type of the binary op
     */
    typeOfBinaryOperation(node: BinaryOperation): TypeNode;
    /**
     * Infer the type of the conditional expression
     */
    typeOfConditional(node: Conditional): TypeNode;
    /**
     * Infer the type of a struct constructor expression
     */
    typeOfStructConstructorCall(node: FunctionCall): TypeNode;
    /**
     * Casts to address (address(0x...) or address(<some contract>)) have some edge cases
     * due to the introduction of 'payable' in 0.5.0.
     * In solc >=0.5.0 an address cast returns payable if
     *  1. The address is a constant
     *  2. The cast is from a contract that has a payable fallback or receive function
     *  (see https://docs.soliditylang.org/en/latest/050-breaking-changes.html#explicitness-requirements)
     * However sometimes in the AST the payability of the cast differs from the payability of the
     * elementary typename itself. We fix up the payability of the fun call here.
     */
    private typeOfAddressCast;
    /**
     * Infer the type of a type cast
     */
    typeOfTypeConversion(node: FunctionCall): TypeNode;
    /**
     * Infer the type of a call with a `new` expression as callee
     */
    typeOfNewCall(node: FunctionCall): TypeNode;
    private matchArguments;
    /**
     * Given a `BuiltunFunctionType` `calleeT` and an actual
     * callsite `node` where it is invoked, specialize `calleeT` to the callsite.
     * Specifically, if `calleeT` is polymorphic (i.e. has a TRest or TVar) substitute
     * those with the types of the actual arguments.
     */
    private specializeBuiltinTypeToCall;
    /**
     * Infer the type of the function call
     */
    typeOfFunctionCall(node: FunctionCall): TypeNode;
    typeOfIndexAccess(node: IndexAccess): TypeNode;
    typeOfIndexRangeAccess(node: IndexRangeAccess): TypeNode;
    /**
     * Infer the type of the builtin 'type' keyword. This is a function from a
     * type name to a struct with fields that depend on whether the argument is
     * a contract, interface, or numeric type. See
     * https://docs.soliditylang.org/en/v0.6.10/units-and-global-variables.html
     * for details.
     */
    typeOfBuiltinType(node: Identifier): TypeNode;
    /**
     * Infer the type of a builtin identifier `node`.
     */
    typeOfBuiltin(node: Identifier): TypeNode;
    private getRHSTypeForDecl;
    /**
     * Infer the type of the identifier
     */
    typeOfIdentifier(node: Identifier): TypeNode;
    typeOfLiteral(node: Literal): TypeNode;
    /**
     * If the `MemberAccess` corresponds to a library function
     * bound with a `using for` directive, return the type of that function.
     */
    private typeOfMemberAccessUsingFor;
    /**
     * If the `MemberAccess` corresponds to a external function or a getter invoked on a contract
     * return the type of the function/getter.
     */
    typeOfMemberAccess(node: MemberAccess): TypeNode;
    private typeOfMemberAccessImpl;
    typeOfNewExpression(newExpr: NewExpression): TypeNode;
    typeOfTupleExpression(node: TupleExpression): TypeNode;
    typeOfUnaryOperation(node: UnaryOperation): TypeNode;
    typeOfElementaryTypeNameExpression(node: ElementaryTypeNameExpression): TypeNameType;
    /**
     * Given an expression infer its type.
     */
    typeOf(node: Expression): TypeNode;
    /**
     * Given a `name` and a ASTNode `ctx`, resolve that `name` in `ctx` and compute
     * a type for the one (or more) definitions that resolve to `name`.
     *
     * There are 2 cases for contracts (determined by the `externalOnly` argument).:
     * 1. MemberAccess on contract pointer (e.g. this.foo). Only external public
     *    functions and public getters returned
     * 2. MemberAccess on a contract type name (e.g. ContractName.foo). All
     *    functions, state variables, and type defs in that contract are now
     *    visible.
     */
    typeOfResolved(name: string, ctxs: ASTNode | ASTNode[], externalOnly: boolean): TypeNode | undefined;
    /**
     * Infer the data location for the given `VariableDeclaration`.
     * For local vars with solidity <=0.4.26 we infer the location from the RHS.
     */
    inferVariableDeclLocation(decl: VariableDeclaration): DataLocation;
    /**
     * Given a `VariableDeclaration` node compute the `TypeNode` that corresponds to the variable.
     * This takes into account the storage location of the `decl`.
     */
    variableDeclarationToTypeNode(decl: VariableDeclaration): TypeNode;
    /**
     * Convert a `FunctionDefinition` `def` into a function type.
     * If `skipFirstArg` is true, omit the first parameter.
     * This is used for functions bound with `using for` directives.
     */
    funDefToType(def: FunctionDefinition, implicitFirstArg?: boolean): FunctionType;
    eventDefToType(def: EventDefinition): EventType;
    errDefToType(def: ErrorDefinition): ErrorType;
    /**
     * Computes the function type for the public accessor corresponding to a state variable
     */
    getterFunType(v: VariableDeclaration): FunctionType;
    getUnitLevelAbiEncoderVersion(node: ASTNode): ABIEncoderVersion;
    /**
     * Computes the argument types and return type for the public accessor
     * corresponding to a state variable.
     */
    getterArgsAndReturn(v: VariableDeclaration): [TypeNode[], TypeNode];
    /**
     * Given the `name` string of elementary type,
     * returns corresponding type node.
     *
     * @todo Consider fixes due to https://github.com/ConsenSys/solc-typed-ast/issues/160
     */
    static elementaryTypeNameStringToTypeNode(name: string): TypeNode | undefined;
    /**
     * Convert a given ast `TypeName` into a `TypeNode`.
     * This produces "general type patterns" without any specific storage information.
     */
    typeNameToTypeNode(node: TypeName): TypeNode;
    /**
     * Computes a `TypeNode` equivalent of given `astT`,
     * specialized for location `loc` (if applicable).
     */
    typeNameToSpecializedTypeNode(astT: TypeName, loc: DataLocation): TypeNode;
    /**
     * Determine if the specified type `typ` is dynamic or not. Dynamic means
     * that if we are trying to read `typ` at location `loc`, in `loc` there should be just a
     * uint256 offset into memory/storage/calldata, where the actual data lives. Otherwise
     * (if the type is "static"), the direct encoding of the data will start at `loc`.
     *
     * Usually "static" types are just the value types - i.e. anything of statically
     * known size that fits in a uint256. As per https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding
     * there are several exceptions to the rule when encoding types in calldata:
     *
     * 1. Fixed size arrays with fixed-sized element types
     * 2. Tuples where all the tuple elements are fixed-size
     *
     * @todo (Dimo):
     * 1. Check again that its not possible for tuples in internal calls to somehow get encoded on the stack
     * 2. What happens with return tuples? Are they always in memory?
     */
    isABITypeEncodingDynamic(typ: TypeNode): boolean;
    isABIEncodable(type: TypeNode, encoderVersion: ABIEncoderVersion): boolean;
    /**
     * Convert an internal TypeNode to the external TypeNode that would correspond to it
     * after ABI-encoding with encoder version `encoderVersion`. Follows the following rules:
     *
     * 1. Contract definitions turned to address.
     * 2. Enum definitions turned to uint of minimal fitting size.
     * 3. Storage pointer types are converted to memory pointer types when `normalizePointers` is set to `true`.
     * 4. Throw an error on any nested mapping types.
     * 5. Fixed-size arrays with fixed-sized element types are encoded as inlined tuples
     * 6. Structs with fixed-sized elements are encoded as inlined tuples
     *
     * @see https://docs.soliditylang.org/en/latest/abi-spec.html
     */
    toABIEncodedType(type: TypeNode, encoderVersion: ABIEncoderVersion, normalizePointers?: boolean): TypeNode;
    /**
     * Returns canonical representation of the signature as string.
     *
     * NOTE: Empty string will be returned for fallback functions and constructors.
     */
    signature(node: FunctionDefinition | EventDefinition | ErrorDefinition | ModifierDefinition | VariableDeclaration | TryCatchClause): string;
    /**
     * Returns HEX string containing first 4 bytes of keccak256 hash function
     * applied to the canonical representation of the passed
     * function / event / error / modifier or public state variable getter signature.
     *
     * NOTE: Empty string will be returned for fallback functions and constructors.
     */
    signatureHash(node: FunctionDefinition | EventDefinition | ErrorDefinition | ModifierDefinition | VariableDeclaration | TryCatchClause): string;
    interfaceId(contract: ContractDefinition): string | undefined;
    /**
     * Given a particular `FunctionCall` site, resolve the exact callee,
     * accounting for potential overloading.
     *
     * A callsite may come from:
     * 1. A normal call (FunctionType, BuiltinFunctionType, FunctionLikeSetType)
     * 2. An emit statement (EventType)
     * 3. A revert statement (ErrorType).
     *
     * In the case that the callee is a `FunctionLikeSetType`, resolve the exact callee
     * based on the function call arguments. Otherwise return the type of the callee.
     */
    typeOfCallee(callsite: FunctionCall): FunctionType | BuiltinFunctionType | EventType | ErrorType | undefined;
    private isExternalCallContext;
    isFunctionCallExternal(call: FunctionCall): boolean;
}
//# sourceMappingURL=infer.d.ts.map