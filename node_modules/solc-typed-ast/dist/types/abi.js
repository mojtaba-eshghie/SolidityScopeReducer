"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.abiTypeToLibraryCanonicalName = exports.abiTypeToCanonicalName = exports.ABIEncoderVersions = exports.ABIEncoderVersion = void 0;
const __1 = require("..");
const misc_1 = require("../misc");
const ast_1 = require("./ast");
const utils_1 = require("./utils");
var ABIEncoderVersion;
(function (ABIEncoderVersion) {
    ABIEncoderVersion["V1"] = "ABIEncoderV1";
    ABIEncoderVersion["V2"] = "ABIEncoderV2";
})(ABIEncoderVersion || (exports.ABIEncoderVersion = ABIEncoderVersion = {}));
exports.ABIEncoderVersions = new Set([ABIEncoderVersion.V1, ABIEncoderVersion.V2]);
/**
 * Get the canonical name for the `TypeNode` `t`, to be used in
 * function/accessor/error/event signatures
 */
function abiTypeToCanonicalName(t) {
    if (t instanceof ast_1.IntType ||
        t instanceof ast_1.FixedBytesType ||
        t instanceof ast_1.BoolType ||
        t instanceof ast_1.BytesType ||
        t instanceof ast_1.StringType) {
        return t.pp();
    }
    // Payable is ignored in canonical names
    if (t instanceof ast_1.AddressType) {
        return "address";
    }
    if (t instanceof ast_1.ArrayType) {
        return `${abiTypeToCanonicalName(t.elementT)}[${t.size ? t.size.toString(10) : ""}]`;
    }
    if (t instanceof ast_1.TupleType) {
        (0, misc_1.assert)((0, misc_1.forAll)(t.elements, (el) => el !== null), "Empty tuple elements are disallowed. Got {0}", t);
        return `(${t.elements
            .map((elementT) => abiTypeToCanonicalName(elementT))
            .join(",")})`;
    }
    // Locations are skipped in signature canonical names
    if (t instanceof ast_1.PointerType) {
        return abiTypeToCanonicalName(t.to);
    }
    if (t instanceof ast_1.FunctionType) {
        return "function";
    }
    (0, misc_1.assert)(false, "Unexpected ABI Type: {0}", t);
}
exports.abiTypeToCanonicalName = abiTypeToCanonicalName;
/**
 * Get the canonical name for the `TypeNode` `t`, to be used in
 * function/accessor/error/event signatures of a _LIBRARY_ function.
 * Apparently library signatures follow different rules, as those are internal.
 */
function abiTypeToLibraryCanonicalName(t) {
    if (t instanceof ast_1.IntType ||
        t instanceof ast_1.FixedBytesType ||
        t instanceof ast_1.BoolType ||
        t instanceof ast_1.BytesType ||
        t instanceof ast_1.StringType) {
        return t.pp();
    }
    // Payable is ignored in canonical names
    if (t instanceof ast_1.AddressType) {
        return "address";
    }
    if (t instanceof ast_1.ArrayType) {
        return `${abiTypeToLibraryCanonicalName(t.elementT)}[${t.size ? t.size.toString(10) : ""}]`;
    }
    if (t instanceof ast_1.TupleType) {
        (0, misc_1.assert)((0, misc_1.forAll)(t.elements, (el) => el !== null), "Empty tuple elements are disallowed. Got {0}", t);
        return `(${t.elements
            .map((elementT) => abiTypeToLibraryCanonicalName(elementT))
            .join(",")})`;
    }
    // Locations are skipped in signature canonical names in libraries _UNLESS_ they are storage.
    // Go figure...
    if (t instanceof ast_1.PointerType) {
        const toName = abiTypeToLibraryCanonicalName(t.to);
        return t.location === __1.DataLocation.Storage ? `${toName} storage` : toName;
    }
    if (t instanceof ast_1.UserDefinedType) {
        return (0, utils_1.getFQDefName)(t.definition);
    }
    if (t instanceof ast_1.MappingType) {
        const keyName = abiTypeToLibraryCanonicalName(t.keyType);
        const valueName = abiTypeToLibraryCanonicalName(t.valueType);
        return `mapping(${keyName} => ${valueName})`;
    }
    if (t instanceof ast_1.FunctionType) {
        return "function";
    }
    (0, misc_1.assert)(false, "Unexpected ABI Type: {0}", t);
}
exports.abiTypeToLibraryCanonicalName = abiTypeToLibraryCanonicalName;
//# sourceMappingURL=abi.js.map