"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InferType = exports.builtinTypes = void 0;
const decimal_js_1 = require("decimal.js");
const semver_1 = require("semver");
const ast_1 = require("../ast");
const constants_1 = require("../ast/constants");
const misc_1 = require("../misc");
const abi_1 = require("./abi");
const ast_2 = require("./ast");
const builtins_1 = require("./builtins");
const eval_const_1 = require("./eval_const");
const misc_2 = require("./misc");
const polymorphic_1 = require("./polymorphic");
const reserved_1 = require("./reserved");
const utils_1 = require("./utils");
const unaryImpureOperators = ["++", "--"];
const RX_ADDRESS = /^address *(payable)?$/;
const RX_INTEGER = /^(u?)int([0-9]*)$/;
const RX_FIXED_BYTES = /^bytes([0-9]+)$/;
/**
 * Some builtins have types that are not easy to express with our current hacky polymorphic support.
 * For those we have the custom type constructors before, that introspect the AST to determine the type.
 */
exports.builtinTypes = {
    revert: (arg) => {
        const hasMsg = arg.parent instanceof ast_1.FunctionCall && arg.parent.vArguments.length === 1;
        const argTs = hasMsg ? [reserved_1.types.stringMemory] : [];
        return new ast_2.BuiltinFunctionType("revert", argTs, []);
    },
    require: (arg) => {
        const hasMsg = arg.parent instanceof ast_1.FunctionCall && arg.parent.vArguments.length === 2;
        const argTs = hasMsg ? [reserved_1.types.bool, reserved_1.types.stringMemory] : [reserved_1.types.bool];
        return new ast_2.BuiltinFunctionType("require", argTs, []);
    },
    this: (node) => {
        const contract = node.getClosestParentByType(ast_1.ContractDefinition);
        (0, misc_1.assert)(contract !== undefined, "this ({0}) used outside of a contract", node);
        return new ast_2.UserDefinedType(contract.name, contract);
    }
};
function typesAreUnordered(a, b, T1Const, T2Const) {
    if (a instanceof T1Const && b instanceof T2Const) {
        return [a, b];
    }
    if (b instanceof T1Const && a instanceof T2Const) {
        return [b, a];
    }
    return [undefined, undefined];
}
/**
 * Given a `FunctionType` or `FunctionSetType` `arg` return a new `FunctionType`/`FunctionSetType` with
 * all first arguments marked as implicit.
 */
function markFirstArgImplicit(arg) {
    if (arg instanceof ast_2.FunctionType) {
        return new ast_2.FunctionType(arg.name, arg.parameters, arg.returns, arg.visibility, arg.mutability, true, arg.src);
    }
    return new ast_2.FunctionLikeSetType(arg.defs.map(markFirstArgImplicit));
}
function isSupportedByEncoderV1(type) {
    if (type instanceof ast_2.PointerType) {
        return isSupportedByEncoderV1(type.to);
    }
    if (type instanceof ast_2.UserDefinedType && type.definition instanceof ast_1.StructDefinition) {
        return false;
    }
    if (type instanceof ast_2.ArrayType) {
        const [baseT] = (0, utils_1.generalizeType)(type.elementT);
        return (isSupportedByEncoderV1(baseT) &&
            !(baseT instanceof ast_2.ArrayType && baseT.size === undefined));
    }
    return true;
}
class InferType {
    constructor(version) {
        this.version = version;
    }
    /**
     * Infer the type of the assignment `node`. (In solidity assignments are expressions)
     */
    typeOfAssignment(node) {
        const lhs = (0, utils_1.stripSingletonParens)(node.vLeftHandSide);
        if (lhs instanceof ast_1.TupleExpression) {
            // For tuple assignments some part of the LHS may be omitted. We still need to compute a type for them those
            // due to nested assignments. E.g. in `(a, b) = (c, ) = ("foo", true))` we still need to compute a type for the
            // second field in the inner tuple assignment, even though there is LHS there.
            const rhsT = this.typeOf(node.vRightHandSide);
            (0, misc_1.assert)(rhsT instanceof ast_2.TupleType, "Unexpected non-tuple in rhs of tuple assignment {0}", node);
            const comps = lhs.vOriginalComponents;
            // Its possible to do assignments (a, b,) = fun() where fun returns more than 3 elements.
            (0, misc_1.assert)(rhsT.elements.length >= comps.length, `Unexpected more lhs tuple elements (${comps.length}) than rhs tuple elements (${rhsT.elements.length}) in {0}`, node);
            const resTs = [];
            for (let i = 0; i < comps.length; i++) {
                const lhsComp = comps[i];
                resTs.push(lhsComp === null ? rhsT.elements[i] : this.typeOf(lhsComp));
            }
            return new ast_2.TupleType(resTs);
        }
        return this.typeOf(lhs);
    }
    /**
     * Given to numeric expressions infer a common type to which they can both be implicitly casted.
     */
    inferCommonIntType(a, b) {
        // If both are literals evaluate the expression
        if (a instanceof ast_2.IntLiteralType && b instanceof ast_2.IntLiteralType) {
            (0, misc_1.assert)(a.literal !== undefined && b.literal !== undefined, "Unexpected missing literals");
            const res = (0, utils_1.smallestFittingType)(a.literal, b.literal);
            (0, misc_1.assert)(res !== undefined, "Couldn't find concrete types for {0} and {1}", a, b);
            return res;
        }
        // If one of them is an int literal, and the other is not, we have 2 cases
        // 1) The literal fits in the int type - take the int type
        // 2) The literal doesn't fit in the int type - widen the int type.
        if (a instanceof ast_2.IntLiteralType || b instanceof ast_2.IntLiteralType) {
            const [literalT, concreteT] = typesAreUnordered(a, b, ast_2.IntLiteralType, ast_2.IntType);
            (0, misc_1.assert)(literalT.literal !== undefined, "TODO: Remove when we remove typestring parser");
            const decMin = concreteT.min();
            const decMax = concreteT.max();
            /// Literal less than the minimum for the concrete type
            if (decMin > literalT.literal) {
                return this.inferCommonIntType(new ast_2.IntLiteralType(literalT.literal), new ast_2.IntLiteralType(decMax));
            }
            if (decMax < literalT.literal) {
                return this.inferCommonIntType(new ast_2.IntLiteralType(decMin), new ast_2.IntLiteralType(literalT.literal));
            }
            /// Literal fits
            return concreteT;
        }
        // Otherwise find a common type to which they cast
        if (a.signed === b.signed) {
            return new ast_2.IntType(Math.max(a.nBits, b.nBits), a.signed);
        }
        const unsigned = a.signed ? b : a;
        const signed = a.signed ? a : b;
        // Prior to 0.8.1 you could implicitly cast uintN to intM if M > N
        if ((0, semver_1.lt)(this.version, "0.8.1") && signed.nBits > unsigned.nBits) {
            return new ast_2.IntType(signed.nBits, true);
        }
        throw new misc_2.SolTypeError(`Can't figure out a common type for ${(0, misc_1.pp)(a)} and ${(0, misc_1.pp)(b)}`);
    }
    /**
     * Given two types `a` and `b` infer the common type that they are both
     * implicitly casted to, when appearing in a binary op/conditional.
     * Its currently usually `a` or `b`
     */
    inferCommonType(a, b) {
        /**
         * The common type for two string literals is string memory.
         * For example the type of `flag ? "a" : "b"` is string memory,
         * not string literal.
         *
         * @todo This edge case is ugly. It suggests that perhaps we should
         * remove StringLiteralType from the type system.
         */
        if (a instanceof ast_2.StringLiteralType && b instanceof ast_2.StringLiteralType) {
            return reserved_1.types.stringMemory;
        }
        if ((0, misc_1.eq)(a, b)) {
            return a;
        }
        if ((a instanceof ast_2.IntType || a instanceof ast_2.IntLiteralType) &&
            (b instanceof ast_2.IntType || b instanceof ast_2.IntLiteralType)) {
            return this.inferCommonIntType(a, b);
        }
        if (a instanceof ast_2.PointerType &&
            b instanceof ast_2.PointerType &&
            (0, misc_1.eq)(a.to, b.to) &&
            a.location !== b.location) {
            return new ast_2.PointerType(a.to, constants_1.DataLocation.Memory);
        }
        const [stringLitT, stringT] = typesAreUnordered(a, b, ast_2.StringLiteralType, ast_2.PointerType);
        // Note: Can't rely on implicit casting here as the common type for "abcd" and string storage is string memory.
        if (stringT !== undefined && stringLitT !== undefined && stringT.to instanceof ast_2.StringType) {
            return this.inferCommonType(stringT, reserved_1.types.stringMemory);
        }
        if (a instanceof ast_2.TupleType &&
            b instanceof ast_2.TupleType &&
            a.elements.length === b.elements.length) {
            const commonElTs = [];
            for (let i = 0; i < a.elements.length; i++) {
                const aElT = a.elements[i];
                const bElT = b.elements[i];
                let commonElT;
                if (aElT !== null && bElT !== null) {
                    commonElT = this.inferCommonType(aElT, bElT);
                    if (commonElT instanceof ast_2.IntLiteralType && commonElT.literal !== undefined) {
                        const fittingT = (0, utils_1.smallestFittingType)(commonElT.literal);
                        (0, misc_1.assert)(fittingT !== undefined, "Can't infer common type for tuple elements {0} between {1} and {2}", i, a, b);
                        commonElT = fittingT;
                    }
                }
                else {
                    commonElT = aElT ?? bElT;
                }
                commonElTs.push(commonElT);
            }
            return new ast_2.TupleType(commonElTs);
        }
        const [fun, funSet] = typesAreUnordered(a, b, ast_2.FunctionType, ast_2.FunctionLikeSetType);
        if (fun && funSet) {
            for (const funT of funSet.defs) {
                if (funT instanceof ast_2.FunctionType &&
                    (0, misc_1.eq)(new ast_2.TupleType(fun.parameters), new ast_2.TupleType(funT.parameters)) &&
                    (0, misc_1.eq)(new ast_2.TupleType(fun.returns), new ast_2.TupleType(funT.returns)) &&
                    (fun.visibility === ast_1.FunctionVisibility.External) ===
                        (funT.visibility === ast_1.FunctionVisibility.External)) {
                    return fun;
                }
            }
        }
        if (a instanceof ast_2.FunctionType &&
            b instanceof ast_2.FunctionType &&
            (0, misc_1.eq)(new ast_2.TupleType(a.parameters), new ast_2.TupleType(b.parameters)) &&
            (0, misc_1.eq)(new ast_2.TupleType(a.returns), new ast_2.TupleType(b.returns)) &&
            a.mutability === b.mutability) {
            const commonVis = (0, utils_1.inferCommonVisiblity)(a.visibility, b.visibility);
            if (commonVis) {
                return new ast_2.FunctionType(undefined, a.parameters, a.returns, commonVis, a.mutability);
            }
        }
        // a implicitly castable to b - return b
        if ((0, utils_1.castable)(a, b, this.version)) {
            return b;
        }
        // b implicitly castable to a - return a
        if ((0, utils_1.castable)(b, a, this.version)) {
            return a;
        }
        throw new misc_2.SolTypeError(`Cannot infer commmon type for ${(0, misc_1.pp)(a)} and ${(0, misc_1.pp)(b)}`);
    }
    typeOfCustomizableOperation(node) {
        const userFunction = node.vUserFunction;
        if (userFunction === undefined) {
            return undefined;
        }
        const funType = this.funDefToType(userFunction);
        (0, misc_1.assert)(funType.returns.length === 1, "Expected {0} type of {1} to have a single return value for operation {2}", funType, userFunction, node);
        return funType.returns[0];
    }
    /**
     * Infer the type of the binary op
     */
    typeOfBinaryOperation(node) {
        const customType = this.typeOfCustomizableOperation(node);
        if (customType) {
            return customType;
        }
        if (utils_1.BINARY_OPERATOR_GROUPS.Comparison.includes(node.operator) ||
            utils_1.BINARY_OPERATOR_GROUPS.Equality.includes(node.operator) ||
            utils_1.BINARY_OPERATOR_GROUPS.Logical.includes(node.operator)) {
            return reserved_1.types.bool;
        }
        const a = this.typeOf(node.vLeftExpression);
        const b = this.typeOf(node.vRightExpression);
        if (a instanceof ast_2.NumericLiteralType && b instanceof ast_2.NumericLiteralType) {
            const res = (0, eval_const_1.evalConstantExpr)(node, this);
            (0, misc_1.assert)(res instanceof decimal_js_1.Decimal || typeof res === "bigint", "Unexpected result of const binary op");
            return typeof res === "bigint"
                ? new ast_2.IntLiteralType(res)
                : new ast_2.RationalLiteralType((0, utils_1.decimalToRational)(res));
        }
        // After 0.6.0 the type of ** is just the type of the lhs
        // Between 0.6.0 and 0.7.0 if the lhs is an int literal type it
        // took the type of the rhs if it wasn't a literal type. After 0.7.0 it
        // just assumes uint256.
        if (node.operator === "**") {
            if ((0, semver_1.gte)(this.version, "0.7.0")) {
                return a instanceof ast_2.IntLiteralType ? reserved_1.types.uint256 : a;
            }
            if ((0, semver_1.gte)(this.version, "0.6.0")) {
                if (a instanceof ast_2.IntLiteralType) {
                    return b instanceof ast_2.IntType ? b : reserved_1.types.uint256;
                }
                return a;
            }
        }
        if (utils_1.BINARY_OPERATOR_GROUPS.Arithmetic.includes(node.operator)) {
            (0, misc_1.assert)(a instanceof ast_2.IntType || a instanceof ast_2.IntLiteralType, "Unexpected type of {0}", a);
            (0, misc_1.assert)(b instanceof ast_2.IntType || b instanceof ast_2.IntLiteralType, "Unexpected type of {0}", b);
            return this.inferCommonIntType(a, b);
        }
        if (utils_1.BINARY_OPERATOR_GROUPS.Bitwise.includes(node.operator)) {
            // For bitshifts just take the type of the lhs
            if ([">>", "<<"].includes(node.operator)) {
                if (a instanceof ast_2.IntLiteralType) {
                    return (0, semver_1.gte)(this.version, "0.7.0") ? reserved_1.types.uint256 : b;
                }
                return a;
            }
            // For all other bitwise operators infer a common type. In earlier versions it wa allowed
            // to have bitwise ops between differing sizes
            return this.inferCommonType(a, b);
        }
        throw new Error(`NYI Binary op ${node.operator}`);
    }
    /**
     * Infer the type of the conditional expression
     */
    typeOfConditional(node) {
        const trueT = this.typeOf(node.vTrueExpression);
        const falseT = this.typeOf(node.vFalseExpression);
        return this.inferCommonType(trueT, falseT);
    }
    /**
     * Infer the type of a struct constructor expression
     */
    typeOfStructConstructorCall(node) {
        const callee = node.vCallee;
        (0, misc_1.assert)(callee instanceof ast_1.Identifier ||
            callee instanceof ast_1.IdentifierPath ||
            callee instanceof ast_1.MemberAccess, `Unexpected node in Struct construction call ${callee.constructor.name}`, callee);
        const calleeT = this.typeOf(callee);
        (0, misc_1.assert)(calleeT instanceof ast_2.TypeNameType &&
            calleeT.type instanceof ast_2.UserDefinedType &&
            calleeT.type.definition instanceof ast_1.StructDefinition, "Unexpected callee type {0}", calleeT);
        return new ast_2.PointerType(calleeT.type, constants_1.DataLocation.Memory, "ref");
    }
    /**
     * Casts to address (address(0x...) or address(<some contract>)) have some edge cases
     * due to the introduction of 'payable' in 0.5.0.
     * In solc >=0.5.0 an address cast returns payable if
     *  1. The address is a constant
     *  2. The cast is from a contract that has a payable fallback or receive function
     *  (see https://docs.soliditylang.org/en/latest/050-breaking-changes.html#explicitness-requirements)
     * However sometimes in the AST the payability of the cast differs from the payability of the
     * elementary typename itself. We fix up the payability of the fun call here.
     */
    typeOfAddressCast(node, calleeT) {
        // In solc <0.5.0 there is no address payable
        if ((0, semver_1.lt)(this.version, "0.5.0")) {
            return calleeT;
        }
        if (calleeT.payable) {
            return calleeT;
        }
        // After 0.8.0 all explicit casts to address are non-payable
        if ((0, semver_1.gte)(this.version, "0.8.0")) {
            return calleeT;
        }
        (0, misc_1.assert)(node.vArguments.length === 1, `Unexpected number of args to type cast {0}`, node);
        const arg = node.vArguments[0];
        if (arg instanceof ast_1.Literal && arg.value.startsWith("0x") && arg.value.length === 42) {
            return (0, semver_1.lt)(this.version, "0.6.0") ? reserved_1.types.addressPayable : reserved_1.types.address;
        }
        const argT = this.typeOf(arg);
        if (argT instanceof ast_2.IntType ||
            argT instanceof ast_2.IntLiteralType ||
            argT instanceof ast_2.FixedBytesType) {
            return reserved_1.types.addressPayable;
        }
        if (argT instanceof ast_2.AddressType && (0, semver_1.lt)(this.version, "0.6.0")) {
            return argT;
        }
        if (argT instanceof ast_2.UserDefinedType && argT.definition instanceof ast_1.ContractDefinition) {
            if ((0, misc_1.forAny)((0, utils_1.getFallbackRecvFuns)(argT.definition), (fn) => fn.stateMutability === ast_1.FunctionStateMutability.Payable)) {
                return reserved_1.types.addressPayable;
            }
        }
        return calleeT;
    }
    /**
     * Infer the type of a type cast
     */
    typeOfTypeConversion(node) {
        const callee = node.vCallee;
        (0, misc_1.assert)(callee instanceof ast_1.TupleExpression ||
            callee instanceof ast_1.ElementaryTypeNameExpression ||
            callee instanceof ast_1.Identifier ||
            callee instanceof ast_1.IdentifierPath ||
            callee instanceof ast_1.MemberAccess ||
            callee instanceof ast_1.IndexAccess, `Unexpected node in type convertion call ${callee.constructor.name}`, callee);
        const calleeT = this.typeOf(callee);
        if (!(calleeT instanceof ast_2.TypeNameType)) {
            throw new misc_2.SolTypeError(`Unexpected base type in type cast ${(0, misc_1.pp)(calleeT)}`);
        }
        if (calleeT.type instanceof ast_2.AddressType) {
            return this.typeOfAddressCast(node, calleeT.type);
        }
        const innerT = this.typeOf(node.vArguments[0]);
        const loc = innerT instanceof ast_2.PointerType ? innerT.location : constants_1.DataLocation.Memory;
        return (0, utils_1.specializeType)(calleeT.type, loc);
    }
    /**
     * Infer the type of a call with a `new` expression as callee
     */
    typeOfNewCall(node) {
        const newExpr = node.vCallee;
        (0, misc_1.assert)(newExpr instanceof ast_1.NewExpression, 'Unexpected "new" call {0}', newExpr);
        const typ = this.typeNameToTypeNode(newExpr.vTypeName);
        const loc = typ instanceof ast_2.UserDefinedType && typ.definition instanceof ast_1.ContractDefinition
            ? constants_1.DataLocation.Storage
            : constants_1.DataLocation.Memory;
        return (0, utils_1.specializeType)(typ, loc);
    }
    matchArguments(funs, callsite) {
        const args = callsite.vArguments;
        const callExp = callsite.vExpression;
        const argTs = args.map((arg) => this.typeOf(arg));
        const argTsWithImplictArg = callExp instanceof ast_1.MemberAccess ? [this.typeOf(callExp.vExpression), ...argTs] : argTs;
        for (let funT of funs) {
            if (funT instanceof ast_2.BuiltinFunctionType) {
                funT = this.specializeBuiltinTypeToCall(callsite, funT);
            }
            const actualTs = funT instanceof ast_2.FunctionType && funT.implicitFirstArg ? argTsWithImplictArg : argTs;
            if (funT.parameters.length !== actualTs.length) {
                continue;
            }
            let argsMatch = true;
            for (let i = 0; i < funT.parameters.length; i++) {
                argsMatch = (0, utils_1.castable)(actualTs[i], funT.parameters[i], this.version);
                if (!argsMatch) {
                    break;
                }
            }
            if (argsMatch) {
                return funT;
            }
        }
        return undefined;
    }
    /**
     * Given a `BuiltunFunctionType` `calleeT` and an actual
     * callsite `node` where it is invoked, specialize `calleeT` to the callsite.
     * Specifically, if `calleeT` is polymorphic (i.e. has a TRest or TVar) substitute
     * those with the types of the actual arguments.
     */
    specializeBuiltinTypeToCall(node, calleeT) {
        const argTs = node.vArguments.map((arg) => this.typeOf(arg));
        const m = new Map();
        /**
         * We can push fixed sized arrays (e.g. uint[1]) to storage arrays of arrays (uint[][]).
         * Add this implicit cast here
         */
        if (calleeT instanceof ast_2.BuiltinFunctionType &&
            node.vFunctionName === "push" &&
            !(0, misc_1.eq)(calleeT.parameters[0], argTs[0]) &&
            (0, utils_1.castable)(argTs[0], calleeT.parameters[0], this.version)) {
            argTs[0] = calleeT.parameters[0];
        }
        (0, polymorphic_1.buildSubstitutions)(calleeT.parameters, argTs, m, this.version);
        return (0, polymorphic_1.applySubstitution)(calleeT, m);
    }
    /**
     * Infer the type of the function call
     */
    typeOfFunctionCall(node) {
        if (node.kind === ast_1.FunctionCallKind.StructConstructorCall) {
            return this.typeOfStructConstructorCall(node);
        }
        if (node.kind === ast_1.FunctionCallKind.TypeConversion) {
            return this.typeOfTypeConversion(node);
        }
        if (node.vCallee instanceof ast_1.NewExpression) {
            return this.typeOfNewCall(node);
        }
        const resolvedCalleeT = this.typeOfCallee(node);
        let rets;
        if (resolvedCalleeT instanceof ast_2.FunctionType) {
            rets = resolvedCalleeT.returns;
            // Convert any calldata pointers back to memory for external calls
            if (node.vExpression instanceof ast_1.MemberAccess) {
                rets = rets.map((retT) => retT instanceof ast_2.PointerType && retT.location === constants_1.DataLocation.CallData
                    ? (0, utils_1.specializeType)((0, utils_1.generalizeType)(retT)[0], constants_1.DataLocation.Memory)
                    : retT);
            }
        }
        else if (resolvedCalleeT instanceof ast_2.BuiltinFunctionType) {
            rets = resolvedCalleeT.returns;
        }
        else if (resolvedCalleeT instanceof ast_2.EventType || resolvedCalleeT instanceof ast_2.ErrorType) {
            rets = [];
        }
        else {
            throw new misc_2.SolTypeError(`Unexpected unresolved calele type in function call ${(0, misc_1.pp)(node)}`);
        }
        // No returns - return the empty type ()
        if (rets.length === 0) {
            return reserved_1.types.noType;
        }
        if (rets.length === 1) {
            return rets[0];
        }
        return new ast_2.TupleType(rets);
    }
    typeOfIndexAccess(node) {
        const baseT = this.typeOf(node.vBaseExpression);
        if (baseT instanceof ast_2.FixedBytesType) {
            return reserved_1.types.byte;
        }
        if (baseT instanceof ast_2.PointerType) {
            const toT = baseT.to;
            if (toT instanceof ast_2.ArrayType) {
                return toT.elementT;
            }
            if (toT instanceof ast_2.MappingType) {
                return toT.valueType;
            }
            if (toT instanceof ast_2.BytesType) {
                return reserved_1.types.byte;
            }
        }
        /// Array index in an elementary type-name expression (e.g. new Contract[](4))
        if (baseT instanceof ast_2.TypeNameType) {
            const size = node.vIndexExpression &&
                node.vIndexExpression instanceof ast_1.Literal &&
                node.vIndexExpression.kind === ast_1.LiteralKind.Number
                ? BigInt(node.vIndexExpression.value)
                : undefined;
            return new ast_2.TypeNameType(new ast_2.ArrayType(baseT.type, size));
        }
        throw new misc_2.SolTypeError(`Cannot index into type ${(0, misc_1.pp)(baseT)} in ${(0, misc_1.pp)(node)}`);
    }
    typeOfIndexRangeAccess(node) {
        const baseT = this.typeOf(node.vBaseExpression);
        if (!(baseT instanceof ast_2.PointerType &&
            baseT.to instanceof ast_2.BytesType &&
            baseT.location === constants_1.DataLocation.CallData)) {
            throw new misc_2.SolTypeError(`Unexpected base type ${(0, misc_1.pp)(baseT)} in slice ${(0, misc_1.pp)(node)}`);
        }
        /**
         * @todo (dimo): This typing is not precise. We should add a special slice type as described
         * in the documentation here https://docs.soliditylang.org/en/latest/types.html#array-slices
         */
        return baseT;
    }
    /**
     * Infer the type of the builtin 'type' keyword. This is a function from a
     * type name to a struct with fields that depend on whether the argument is
     * a contract, interface, or numeric type. See
     * https://docs.soliditylang.org/en/v0.6.10/units-and-global-variables.html
     * for details.
     */
    typeOfBuiltinType(node) {
        (0, misc_1.assert)(node.parent instanceof ast_1.FunctionCall && node.parent.vArguments.length === 1, "Unexpected use of builtin type {0}", node);
        const typeOfArg = this.typeOf(node.parent.vArguments[0]);
        if (!(typeOfArg instanceof ast_2.TypeNameType)) {
            throw new misc_2.SolTypeError(`Unexpected argument to type() ${(0, misc_1.pp)(node.parent.vArguments[0])}`);
        }
        const innerT = typeOfArg.type;
        if (innerT instanceof ast_2.IntType ||
            (innerT instanceof ast_2.UserDefinedType && innerT.definition instanceof ast_1.EnumDefinition)) {
            return (0, polymorphic_1.applySubstitution)(builtins_1.typeInt, new Map([["T", innerT]]));
        }
        if (innerT instanceof ast_2.UserDefinedType && innerT.definition instanceof ast_1.ContractDefinition) {
            const resTemplateT = innerT.definition.kind === ast_1.ContractKind.Interface || innerT.definition.abstract
                ? builtins_1.typeInterface
                : builtins_1.typeContract;
            return (0, polymorphic_1.applySubstitution)(resTemplateT, new Map([["T", innerT]]));
        }
        throw new misc_2.SolTypeError(`Unexpected type ${innerT.pp()} in type() node ${(0, misc_1.pp)(node)}`);
    }
    /**
     * Infer the type of a builtin identifier `node`.
     */
    typeOfBuiltin(node) {
        if (node.name === "type") {
            return this.typeOfBuiltinType(node);
        }
        if (node.name === "super") {
            const contract = node.getClosestParentByType(ast_1.ContractDefinition);
            (0, misc_1.assert)(contract !== undefined, "Use of super outside of contract in {0}", node);
            return new ast_2.SuperType(contract);
        }
        const globalBuiltin = builtins_1.globalBuiltins.getFieldForVersion(node.name, this.version);
        if (globalBuiltin) {
            return globalBuiltin;
        }
        (0, misc_1.assert)(node.name in exports.builtinTypes, 'NYI builtin "{0}" for {1}', node.name, node);
        return exports.builtinTypes[node.name](node);
    }
    getRHSTypeForDecl(decl, stmt) {
        if (stmt.vInitialValue === undefined) {
            return undefined;
        }
        const rhsT = this.typeOf(stmt.vInitialValue);
        if (rhsT instanceof ast_2.TupleType && stmt.assignments.length > 0) {
            const tupleIdx = stmt.assignments.indexOf(decl.id);
            (0, misc_1.assert)(tupleIdx > -1, "Var decl {0} not found in assignments of {1}", decl, stmt);
            (0, misc_1.assert)(rhsT.elements.length > tupleIdx, "Rhs not a tuple of right size in {0}", stmt);
            const rhsElT = rhsT.elements[tupleIdx];
            return rhsElT !== null ? rhsElT : undefined;
        }
        return rhsT;
    }
    /**
     * Infer the type of the identifier
     */
    typeOfIdentifier(node) {
        const def = node.vReferencedDeclaration;
        if (def === undefined) {
            // Identifiers in import definitions (e.g. the `a` in `import a from
            // "foo.sol"` also have undefined vReferencedDeclaration and look
            // like builtins. Disambiguate them here.
            if (node.parent instanceof ast_1.ImportDirective) {
                const imp = node.parent;
                // Sanity check that vSymbolAliases were built correctly
                (0, misc_1.assert)(node.parent.symbolAliases.length === node.parent.vSymbolAliases.length, `Unexpected import directive with missing symbolic aliases {0}`, node.parent);
                for (let i = 0; i < imp.symbolAliases.length; i++) {
                    const alias = imp.symbolAliases[i];
                    if (!(alias.foreign instanceof ast_1.Identifier && alias.foreign.id === node.id)) {
                        continue;
                    }
                    const originalSym = imp.vSymbolAliases[i][0];
                    if (originalSym instanceof ast_1.ContractDefinition ||
                        originalSym instanceof ast_1.StructDefinition ||
                        originalSym instanceof ast_1.EnumDefinition ||
                        originalSym instanceof ast_1.UserDefinedValueTypeDefinition) {
                        return new ast_2.TypeNameType(new ast_2.UserDefinedType((0, utils_1.getFQDefName)(originalSym), originalSym));
                    }
                    if (originalSym instanceof ast_1.ImportDirective) {
                        return new ast_2.ImportRefType(originalSym);
                    }
                    if (originalSym instanceof ast_1.ErrorDefinition) {
                        return this.errDefToType(originalSym);
                    }
                    if (originalSym instanceof ast_1.FunctionDefinition) {
                        return this.funDefToType(originalSym);
                    }
                    if (originalSym instanceof ast_1.EventDefinition) {
                        return this.eventDefToType(originalSym);
                    }
                    return this.variableDeclarationToTypeNode(originalSym);
                }
            }
            // If not an imported identifier must be a builtin
            return this.typeOfBuiltin(node);
        }
        if (def instanceof ast_1.VariableDeclaration) {
            if (!def.vType && def.parent instanceof ast_1.VariableDeclarationStatement) {
                /// In 0.4.x the TypeName on variable declarations may be omitted. Attempt to infer it from the RHS (if any)
                const varDeclStmt = def.parent;
                let defInitT = this.getRHSTypeForDecl(def, varDeclStmt);
                (0, misc_1.assert)(defInitT !== undefined, "Initializer required when no type specified in {0}", varDeclStmt);
                if (defInitT instanceof ast_2.IntLiteralType) {
                    const concreteT = defInitT.smallestFittingType();
                    (0, misc_1.assert)(concreteT !== undefined, "RHS int literal type {0} doesn't fit in an int type", defInitT);
                    defInitT = concreteT;
                }
                if (defInitT instanceof ast_2.StringLiteralType) {
                    return reserved_1.types.stringMemory;
                }
                return defInitT;
            }
            return this.variableDeclarationToTypeNode(def);
        }
        if (def instanceof ast_1.StructDefinition ||
            def instanceof ast_1.ContractDefinition ||
            def instanceof ast_1.EnumDefinition) {
            const fqName = (0, utils_1.getFQDefName)(def);
            return new ast_2.TypeNameType(new ast_2.UserDefinedType(fqName, def));
        }
        if (def instanceof ast_1.EventDefinition) {
            const argTs = def.vParameters.vParameters.map((arg) => this.variableDeclarationToTypeNode(arg));
            return new ast_2.EventType(def.name, argTs);
        }
        if (def instanceof ast_1.ModifierDefinition) {
            const argTs = def.vParameters.vParameters.map((arg) => this.variableDeclarationToTypeNode(arg));
            return new ast_2.ModifierType(def.name, argTs);
        }
        if (def instanceof ast_1.FunctionDefinition) {
            return this.funDefToType(def);
        }
        if (def instanceof ast_1.ImportDirective) {
            return new ast_2.ImportRefType(def);
        }
        if (def instanceof ast_1.ErrorDefinition) {
            return this.errDefToType(def);
        }
        if (def instanceof ast_1.UserDefinedValueTypeDefinition) {
            return new ast_2.TypeNameType(new ast_2.UserDefinedType((0, utils_1.getFQDefName)(def), def));
        }
        throw new Error(`NYI infer of identifier ${node.name} (${(0, misc_1.pp)(node)}) with def ${def.constructor.name}`);
    }
    typeOfLiteral(node) {
        if (node.kind === ast_1.LiteralKind.Number) {
            if (node.typeString === "address") {
                return reserved_1.types.address;
            }
            if (node.typeString === "address payable") {
                return reserved_1.types.addressPayable;
            }
            let val = new decimal_js_1.Decimal(node.value.replaceAll("_", ""));
            if (node.subdenomination !== undefined) {
                const multiplier = utils_1.SUBDENOMINATION_MULTIPLIERS.get(node.subdenomination);
                (0, misc_1.assert)(multiplier !== undefined, "Unknown subdenomination {0}", node.subdenomination);
                val = val.times(multiplier);
            }
            if (val.isInteger()) {
                return new ast_2.IntLiteralType(BigInt(val.toFixed()));
            }
            return new ast_2.RationalLiteralType((0, utils_1.decimalToRational)(val));
        }
        if (node.kind === ast_1.LiteralKind.String ||
            node.kind === ast_1.LiteralKind.UnicodeString ||
            node.kind === ast_1.LiteralKind.HexString) {
            return new ast_2.StringLiteralType(node.kind);
        }
        (0, misc_1.assert)(node.kind === ast_1.LiteralKind.Bool, "Unexpected literal kind {0}", node.kind);
        return reserved_1.types.bool;
    }
    /**
     * If the `MemberAccess` corresponds to a library function
     * bound with a `using for` directive, return the type of that function.
     */
    typeOfMemberAccessUsingFor(node, baseT) {
        if (baseT instanceof ast_2.TypeNameType) {
            return undefined;
        }
        const containingContract = node.getClosestParentByType(ast_1.ContractDefinition);
        if (containingContract) {
            let matchedFuns = new ast_2.FunctionLikeSetType([]);
            for (const base of containingContract.vLinearizedBaseContracts) {
                for (const usingFor of base.vUsingForDirectives) {
                    let match = false;
                    if (usingFor.vTypeName === undefined) {
                        /// using for *;
                        match = true;
                    }
                    else {
                        const usingForTyp = this.typeNameToTypeNode(usingFor.vTypeName);
                        match = (0, misc_1.eq)(usingForTyp, (0, utils_1.generalizeType)(baseT)[0]);
                    }
                    if (!match) {
                        continue;
                    }
                    if (usingFor.vFunctionList) {
                        for (const entry of usingFor.vFunctionList) {
                            if (entry instanceof ast_1.IdentifierPath && entry.name === node.memberName) {
                                const funDef = entry.vReferencedDeclaration;
                                (0, misc_1.assert)(funDef instanceof ast_1.FunctionDefinition, "Unexpected non-function decl {0} for name {1} in using for {2}", funDef, entry.name, usingFor);
                                matchedFuns = (0, utils_1.mergeFunTypes)(matchedFuns, this.funDefToType(funDef, true));
                            }
                        }
                    }
                    if (usingFor.vLibraryName) {
                        const lib = usingFor.vLibraryName.vReferencedDeclaration;
                        (0, misc_1.assert)(lib instanceof ast_1.ContractDefinition, "Unexpected non-library decl {0} for name {1} in using for {2}", lib, usingFor.vLibraryName.name, usingFor);
                        const res = this.typeOfResolved(node.memberName, lib, false);
                        if (res) {
                            (0, misc_1.assert)(res instanceof ast_2.FunctionType || res instanceof ast_2.FunctionLikeSetType, "Unexpected type {0} for {1} in library {1}", res, node.memberName, usingFor.vLibraryName.name);
                            matchedFuns = (0, utils_1.mergeFunTypes)(matchedFuns, markFirstArgImplicit(res));
                        }
                    }
                }
            }
            if (matchedFuns.defs.length === 1) {
                return matchedFuns.defs[0];
            }
            if (matchedFuns.defs.length > 1) {
                return matchedFuns;
            }
        }
        return undefined;
    }
    /**
     * If the `MemberAccess` corresponds to a external function or a getter invoked on a contract
     * return the type of the function/getter.
     */
    typeOfMemberAccess(node) {
        const baseT = this.typeOf(node.vExpression);
        const usingForT = this.typeOfMemberAccessUsingFor(node, baseT);
        const normalT = this.typeOfMemberAccessImpl(node, baseT);
        if (usingForT !== undefined) {
            if (normalT === undefined) {
                return usingForT;
            }
            if (normalT instanceof ast_2.FunctionType ||
                normalT instanceof ast_2.FunctionLikeSetType ||
                normalT instanceof ast_2.BuiltinFunctionType) {
                (0, misc_1.assert)(usingForT instanceof ast_2.FunctionType || usingForT instanceof ast_2.FunctionLikeSetType, "Expection function-like type for using-for, not {0}", usingForT);
                return (0, utils_1.mergeFunTypes)(usingForT, normalT);
            }
        }
        (0, misc_1.assert)(normalT !== undefined, "Unknown field {0} on {1} of type {2}", node.memberName, node, baseT);
        return normalT;
    }
    typeOfMemberAccessImpl(node, baseT) {
        if (baseT instanceof ast_2.UserDefinedType && baseT.definition instanceof ast_1.ContractDefinition) {
            const contract = baseT.definition;
            const fieldT = this.typeOfResolved(node.memberName, contract, true);
            (0, misc_1.assert)(fieldT === undefined ||
                fieldT instanceof ast_2.FunctionType ||
                fieldT instanceof ast_2.FunctionLikeSetType, "External field lookup for {0} on contract must be a function, not {1}", node.memberName, fieldT);
            let builtinT;
            // For solidity <0.5.0 contract variables are implicitly castable to address
            if ((0, semver_1.lt)(this.version, "0.5.0")) {
                builtinT = builtins_1.addressBuiltins.getFieldForVersion(node.memberName, this.version);
            }
            if (fieldT) {
                if (builtinT instanceof ast_2.BuiltinFunctionType) {
                    return (0, utils_1.mergeFunTypes)(fieldT, builtinT);
                }
                return fieldT;
            }
            if (builtinT) {
                return builtinT;
            }
        }
        if (baseT instanceof ast_2.PointerType) {
            const toT = baseT.to;
            /// Fields of structs
            if (toT instanceof ast_2.UserDefinedType && toT.definition instanceof ast_1.StructDefinition) {
                const fields = toT.definition.vMembers.filter((fieldDef) => fieldDef.name === node.memberName);
                if (fields.length === 1) {
                    (0, misc_1.assert)(fields[0].vType !== undefined, "Field type is not set for {0}", fields[0]);
                    return (0, utils_1.specializeType)(this.typeNameToTypeNode(fields[0].vType), baseT.location);
                }
            }
            if (toT instanceof ast_2.ArrayType || toT instanceof ast_2.BytesType) {
                if (node.memberName === "length") {
                    return reserved_1.types.uint256;
                }
                /**
                 * https://github.com/ethereum/solidity/releases/tag/v0.6.0
                 */
                if (node.memberName === "push") {
                    const isZeroArg = node.parent instanceof ast_1.FunctionCall && node.parent.vArguments.length === 0;
                    // In newer solidity versions you are allowed to do push() with no args,
                    // Which returns a reference to the new location
                    if (isZeroArg) {
                        return new ast_2.BuiltinFunctionType(undefined, [], [toT instanceof ast_2.BytesType ? reserved_1.types.byte : toT.elementT]);
                    }
                    return new ast_2.BuiltinFunctionType(undefined, [toT instanceof ast_2.BytesType ? reserved_1.types.byte : toT.elementT], (0, semver_1.lt)(this.version, "0.6.0") ? [reserved_1.types.uint256] : []);
                }
                if (node.memberName === "pop") {
                    return new ast_2.BuiltinFunctionType(undefined, [], []);
                }
            }
        }
        if (baseT instanceof ast_2.TypeNameType) {
            if (baseT.type instanceof ast_2.UserDefinedType) {
                const def = baseT.type.definition;
                if (def instanceof ast_1.EnumDefinition) {
                    if (def.vMembers.map((val) => val.name).includes(node.memberName)) {
                        return baseT.type;
                    }
                }
                if (def instanceof ast_1.ContractDefinition) {
                    const res = this.typeOfResolved(node.memberName, def, false);
                    if (res) {
                        return res;
                    }
                }
            }
            if (baseT.type instanceof ast_2.BytesType || baseT.type instanceof ast_2.StringType) {
                if (node.memberName === "concat") {
                    const argTs = [];
                    if (node.parent instanceof ast_1.FunctionCall) {
                        argTs.push(...node.parent.vArguments.map((arg) => this.typeOf(arg)));
                        for (const argT of argTs) {
                            if (!(argT instanceof ast_2.PointerType && (0, misc_1.eq)(argT.to, baseT.type))) {
                                throw new misc_2.SolTypeError(`Unexpected arguments to concat in ${(0, misc_1.pp)(node.parent)}`);
                            }
                        }
                    }
                    return new ast_2.BuiltinFunctionType("concat", argTs, [
                        new ast_2.PointerType(baseT.type, constants_1.DataLocation.Memory)
                    ]);
                }
            }
        }
        if (baseT instanceof ast_2.BuiltinStructType) {
            /// abi.decode is a special case as we need to unwrap the types
            /// inside the tuple as return types
            if (baseT.name === "abi" && node.memberName === "decode") {
                if (node.parent instanceof ast_1.ExpressionStatement) {
                    return new ast_2.BuiltinFunctionType("decode", [], []);
                }
                (0, misc_1.assert)(node.parent instanceof ast_1.FunctionCall &&
                    node.parent.vArguments.length === 2 &&
                    node.parent.vArguments[1] instanceof ast_1.TupleExpression, "Unexpected use of abi.decode outside a function call {0}", node.parent);
                const retTs = [];
                for (const typeExpr of node.parent.vArguments[1].vComponents) {
                    const componentT = this.typeOf(typeExpr);
                    (0, misc_1.assert)(componentT instanceof ast_2.TypeNameType, "Expected type in abi.decode not {0}", componentT);
                    /**
                     * Components of second arg of decode() are plain types,
                     * however they got specialized or slightly promoted on assigment.
                     */
                    if (componentT.type instanceof ast_2.AddressType && !componentT.type.payable) {
                        retTs.push(reserved_1.types.addressPayable);
                    }
                    else {
                        retTs.push((0, utils_1.specializeType)(componentT.type, constants_1.DataLocation.Memory));
                    }
                }
                return new ast_2.BuiltinFunctionType("decode", [reserved_1.types.bytesMemory, this.typeOf(node.parent.vArguments[1])], retTs);
            }
            const type = baseT.getFieldForVersion(node.memberName, this.version);
            if (type) {
                return type;
            }
        }
        if (baseT instanceof ast_2.FunctionLikeSetType ||
            baseT instanceof ast_2.FunctionType ||
            baseT instanceof ast_2.EventType ||
            baseT instanceof ast_2.ErrorType) {
            if (node.memberName === "selector") {
                return baseT instanceof ast_2.EventType ? reserved_1.types.bytes32 : reserved_1.types.bytes4;
            }
        }
        if (baseT instanceof ast_2.FunctionLikeSetType || baseT instanceof ast_2.FunctionType) {
            if (node.memberName === "address") {
                return reserved_1.types.address;
            }
        }
        if (baseT instanceof ast_2.FunctionLikeSetType ||
            baseT instanceof ast_2.FunctionType ||
            baseT instanceof ast_2.BuiltinFunctionType) {
            if (node.memberName === "gas" || node.memberName === "value") {
                return new ast_2.BuiltinFunctionType(node.memberName, [reserved_1.types.uint256], [baseT]);
            }
        }
        if (baseT instanceof ast_2.FixedBytesType) {
            if (node.memberName === "length") {
                return reserved_1.types.uint8;
            }
        }
        if (baseT instanceof ast_2.AddressType) {
            let builtinStruct;
            if ((0, semver_1.lt)(this.version, "0.6.0")) {
                builtinStruct = builtins_1.addressBuiltins;
            }
            else {
                builtinStruct = baseT.payable ? builtins_1.address06PayableBuiltins : builtins_1.address06Builtins;
            }
            const field = builtinStruct.getFieldForVersion(node.memberName, this.version);
            if (field) {
                return field;
            }
        }
        if (baseT instanceof ast_2.ImportRefType) {
            const res = this.typeOfResolved(node.memberName, baseT.importStmt.vSourceUnit, false);
            if (res) {
                return res;
            }
        }
        if (baseT instanceof ast_2.TypeNameType &&
            baseT.type instanceof ast_2.UserDefinedType &&
            baseT.type.definition instanceof ast_1.UserDefinedValueTypeDefinition) {
            const innerT = this.typeNameToTypeNode(baseT.type.definition.underlyingType);
            if (node.memberName === "wrap") {
                return new ast_2.BuiltinFunctionType("wrap", [innerT], [baseT.type]);
            }
            if (node.memberName === "unwrap") {
                return new ast_2.BuiltinFunctionType("unwrap", [baseT.type], [innerT]);
            }
        }
        if (baseT instanceof ast_2.SuperType) {
            const res = this.typeOfResolved(node.memberName, baseT.contract.vLinearizedBaseContracts.slice(1), false);
            if (res && (res instanceof ast_2.FunctionType || res instanceof ast_2.FunctionLikeSetType)) {
                return res;
            }
        }
        return undefined;
    }
    typeOfNewExpression(newExpr) {
        const typ = this.typeNameToTypeNode(newExpr.vTypeName);
        const loc = typ instanceof ast_2.UserDefinedType && typ.definition instanceof ast_1.ContractDefinition
            ? constants_1.DataLocation.Storage
            : constants_1.DataLocation.Memory;
        const resT = (0, utils_1.specializeType)(typ, loc);
        /// If there is an explicit constructor, just return its function type.
        /// (make sure to add the proper returns, as declared constructors have no return)
        if (typ instanceof ast_2.UserDefinedType &&
            typ.definition instanceof ast_1.ContractDefinition &&
            typ.definition.vConstructor) {
            const constrType = this.funDefToType(typ.definition.vConstructor);
            constrType.returns.push(resT);
            return constrType;
        }
        /// Builtin constructor/array creation case
        const argTs = typ instanceof ast_2.ArrayType || typ instanceof ast_2.PackedArrayType ? [reserved_1.types.uint256] : [];
        return new ast_2.BuiltinFunctionType(undefined, argTs, [resT]);
    }
    typeOfTupleExpression(node) {
        const componentTs = node.vOriginalComponents.map((cmp) => cmp === null ? cmp : this.typeOf(cmp));
        if (!node.isInlineArray) {
            if (componentTs.length === 1) {
                const resT = componentTs[0];
                (0, misc_1.assert)(resT !== null, "Empty tuple elements are disallowed for inline arrays. Got {0}", node);
                return resT;
            }
            return new ast_2.TupleType(componentTs);
        }
        (0, misc_1.assert)(node.vComponents.length > 0, "Can't have an empty array initializer");
        (0, misc_1.assert)((0, misc_1.forAll)(componentTs, (elT) => elT !== null), "Empty tuple elements are disallowed. Got {0}", node);
        let elT = componentTs.reduce((prev, cur) => this.inferCommonType(prev, cur));
        if (elT instanceof ast_2.IntLiteralType) {
            const concreteT = elT.smallestFittingType();
            (0, misc_1.assert)(concreteT !== undefined, "Unable to figure out concrete type for array of literals {0}", node);
            elT = concreteT;
        }
        elT = (0, utils_1.specializeType)((0, utils_1.generalizeType)(elT)[0], constants_1.DataLocation.Memory);
        return new ast_2.PointerType(new ast_2.ArrayType(elT, BigInt(node.components.length)), constants_1.DataLocation.Memory);
    }
    typeOfUnaryOperation(node) {
        const customType = this.typeOfCustomizableOperation(node);
        if (customType) {
            return customType;
        }
        if (node.operator === "!") {
            return reserved_1.types.bool;
        }
        if (node.operator === "delete") {
            return reserved_1.types.noType;
        }
        const innerT = this.typeOf(node.vSubExpression);
        if (unaryImpureOperators.includes(node.operator)) {
            return innerT;
        }
        if (innerT instanceof ast_2.NumericLiteralType) {
            const res = (0, eval_const_1.evalConstantExpr)(node, this);
            (0, misc_1.assert)(res instanceof decimal_js_1.Decimal || typeof res === "bigint", "Unexpected result of const unary op");
            return typeof res === "bigint"
                ? new ast_2.IntLiteralType(res)
                : new ast_2.RationalLiteralType((0, utils_1.decimalToRational)(res));
        }
        if (node.operator === "-" || node.operator === "+" || node.operator === "~") {
            return innerT;
        }
        throw new Error(`NYI unary operator ${node.operator} in ${(0, misc_1.pp)(node)}`);
    }
    typeOfElementaryTypeNameExpression(node) {
        let innerT;
        if (node.typeName instanceof ast_1.TypeName) {
            innerT = this.typeNameToTypeNode(node.typeName);
        }
        else {
            const elementaryT = InferType.elementaryTypeNameStringToTypeNode(node.typeName);
            (0, misc_1.assert)(elementaryT !== undefined, 'NYI converting elementary type name "{0}"', node.typeName);
            innerT = elementaryT;
        }
        return new ast_2.TypeNameType(innerT);
    }
    /**
     * Given an expression infer its type.
     */
    typeOf(node) {
        if (node instanceof ast_1.Assignment) {
            return this.typeOfAssignment(node);
        }
        if (node instanceof ast_1.BinaryOperation) {
            return this.typeOfBinaryOperation(node);
        }
        if (node instanceof ast_1.Conditional) {
            return this.typeOfConditional(node);
        }
        if (node instanceof ast_1.ElementaryTypeNameExpression) {
            return this.typeOfElementaryTypeNameExpression(node);
        }
        if (node instanceof ast_1.FunctionCall) {
            return this.typeOfFunctionCall(node);
        }
        if (node instanceof ast_1.Identifier) {
            return this.typeOfIdentifier(node);
        }
        if (node instanceof ast_1.IndexAccess) {
            return this.typeOfIndexAccess(node);
        }
        if (node instanceof ast_1.IndexRangeAccess) {
            return this.typeOfIndexRangeAccess(node);
        }
        if (node instanceof ast_1.Literal) {
            return this.typeOfLiteral(node);
        }
        if (node instanceof ast_1.MemberAccess) {
            return this.typeOfMemberAccess(node);
        }
        if (node instanceof ast_1.NewExpression) {
            return this.typeOfNewExpression(node);
        }
        if (node instanceof ast_1.TupleExpression) {
            return this.typeOfTupleExpression(node);
        }
        if (node instanceof ast_1.UnaryOperation) {
            return this.typeOfUnaryOperation(node);
        }
        if (node instanceof ast_1.FunctionCallOptions) {
            return this.typeOf(node.vExpression);
        }
        throw new Error(`NYI type inference of node ${node.constructor.name}`);
    }
    /**
     * Given a `name` and a ASTNode `ctx`, resolve that `name` in `ctx` and compute
     * a type for the one (or more) definitions that resolve to `name`.
     *
     * There are 2 cases for contracts (determined by the `externalOnly` argument).:
     * 1. MemberAccess on contract pointer (e.g. this.foo). Only external public
     *    functions and public getters returned
     * 2. MemberAccess on a contract type name (e.g. ContractName.foo). All
     *    functions, state variables, and type defs in that contract are now
     *    visible.
     */
    typeOfResolved(name, ctxs, externalOnly) {
        if (ctxs instanceof ast_1.ASTNode) {
            ctxs = [ctxs];
        }
        const defs = [];
        for (const ctx of ctxs) {
            defs.push(...(0, ast_1.resolveAny)(name, ctx, this, true));
        }
        if (defs.length === 0) {
            return undefined;
        }
        const funs = defs.filter((def) => def instanceof ast_1.FunctionDefinition &&
            (!externalOnly || // Only external/public functions visible on lookups on contract pointers
                def.visibility === ast_1.FunctionVisibility.External ||
                def.visibility === ast_1.FunctionVisibility.Public));
        const getters = defs.filter((def) => def instanceof ast_1.VariableDeclaration &&
            (!externalOnly || def.visibility === ast_1.StateVariableVisibility.Public) // Only public vars are visible on lookups on contract pointers.
        );
        const typeDefs = defs.filter((def) => !externalOnly && // Type Defs are not visible on lookups on contract pointers.
            (def instanceof ast_1.StructDefinition ||
                def instanceof ast_1.EnumDefinition ||
                def instanceof ast_1.ContractDefinition));
        const eventDefs = defs.filter((def) => !externalOnly && def instanceof ast_1.EventDefinition);
        const errorDefs = defs.filter((def) => !externalOnly && def instanceof ast_1.ErrorDefinition);
        // For external calls its possible to have a mixture of functions and getters
        if (funs.length > 0 && externalOnly && getters.length > 0) {
            const nCallable = funs.length + getters.length;
            (0, misc_1.assert)(nCallable === defs.length, "Unexpected number of callable matching {0} in {1}", name, ctxs);
            return new ast_2.FunctionLikeSetType([
                ...funs.map((funDef) => this.funDefToType(funDef)),
                ...getters.map((varDecl) => this.getterFunType(varDecl))
            ]);
        }
        if (funs.length > 0) {
            (0, misc_1.assert)(getters.length === 0 &&
                typeDefs.length === 0 &&
                eventDefs.length === 0 &&
                errorDefs.length === 0, "Unexpected both functions and others matching {0} in {1}", name, ctxs);
            if (funs.length === 1) {
                const res = this.funDefToType(funs[0]);
                /**
                 * @todo (Pavel) Consider checking if resolved function is externally accessible (external, public)
                 */
                return res;
            }
            return new ast_2.FunctionLikeSetType(funs.map((funDef) => this.funDefToType(funDef)));
        }
        if (getters.length > 0) {
            (0, misc_1.assert)(funs.length === 0 &&
                typeDefs.length === 0 &&
                eventDefs.length === 0 &&
                errorDefs.length === 0, "Unexpected both getters and others matching {0} in {1}", name, ctxs);
            (0, misc_1.assert)(getters.length === 1, "Unexpected overloading between getters for {0}", name);
            return externalOnly
                ? this.getterFunType(getters[0])
                : this.variableDeclarationToTypeNode(getters[0]);
        }
        if (errorDefs.length > 0) {
            (0, misc_1.assert)(errorDefs.length === defs.length, "Unexpected both getters and others matching {0} in {1}", name, ctxs);
            (0, misc_1.assert)(errorDefs.length === 1, "Unexpected overloading between errorDefs for {0}", name);
            return this.errDefToType(errorDefs[0]);
        }
        if (eventDefs.length > 0) {
            (0, misc_1.assert)(eventDefs.length === defs.length, "Unexpected both events and others matching {0} in {1}", name, ctxs);
            if (eventDefs.length === 1) {
                return this.eventDefToType(eventDefs[0]);
            }
            return new ast_2.FunctionLikeSetType(eventDefs.map((evtDef) => this.eventDefToType(evtDef)));
        }
        if (typeDefs.length > 0) {
            (0, misc_1.assert)(typeDefs.length == 1, "Unexpected number of type defs {0}", name);
            const def = typeDefs[0];
            const fqName = (0, utils_1.getFQDefName)(def);
            return new ast_2.TypeNameType(new ast_2.UserDefinedType(fqName, def));
        }
        return undefined;
    }
    /**
     * Infer the data location for the given `VariableDeclaration`.
     * For local vars with solidity <=0.4.26 we infer the location from the RHS.
     */
    inferVariableDeclLocation(decl) {
        if (decl.stateVariable) {
            return decl.constant ? constants_1.DataLocation.Memory : constants_1.DataLocation.Storage;
        }
        if (decl.storageLocation !== constants_1.DataLocation.Default) {
            return decl.storageLocation;
        }
        if (decl.parent instanceof ast_1.ParameterList) {
            // In 0.4.x param/return locations may be omitted. We assume calldata
            // for external function parameters and memory for all other cases
            const fun = decl.parent.parent;
            return fun.visibility === ast_1.FunctionVisibility.External && decl.parent === fun.vParameters
                ? constants_1.DataLocation.CallData
                : constants_1.DataLocation.Memory;
        }
        if (decl.parent instanceof ast_1.VariableDeclarationStatement) {
            // In 0.4.x local var locations may be omitted. Try and infer it from the RHS, otherwise assume storage.
            const rhsT = this.getRHSTypeForDecl(decl, decl.parent);
            if (rhsT && rhsT instanceof ast_2.PointerType) {
                return rhsT.location;
            }
            return constants_1.DataLocation.Storage;
        }
        if (decl.parent instanceof ast_1.StructDefinition) {
            return constants_1.DataLocation.Default;
        }
        if (decl.parent instanceof ast_1.SourceUnit) {
            // Global vars don't have a location (no ref types yet)
            return constants_1.DataLocation.Default;
        }
        throw new Error(`NYI variable declaration ${(0, misc_1.pp)(decl)}`);
    }
    /**
     * Given a `VariableDeclaration` node compute the `TypeNode` that corresponds to the variable.
     * This takes into account the storage location of the `decl`.
     */
    variableDeclarationToTypeNode(decl) {
        (0, misc_1.assert)(decl.vType !== undefined, "Expected {0} to have type", decl);
        const generalType = this.typeNameToTypeNode(decl.vType);
        if ((0, utils_1.isReferenceType)(generalType)) {
            const loc = this.inferVariableDeclLocation(decl);
            return (0, utils_1.specializeType)(generalType, loc);
        }
        return generalType;
    }
    /**
     * Convert a `FunctionDefinition` `def` into a function type.
     * If `skipFirstArg` is true, omit the first parameter.
     * This is used for functions bound with `using for` directives.
     */
    funDefToType(def, implicitFirstArg = false) {
        const argTs = def.vParameters.vParameters.map((arg) => this.variableDeclarationToTypeNode(arg));
        const retTs = def.vReturnParameters.vParameters.map((arg) => this.variableDeclarationToTypeNode(arg));
        return new ast_2.FunctionType((0, utils_1.isVisiblityExternallyCallable)(def.visibility) ? def.name : undefined, argTs, retTs, def.visibility, def.stateMutability, implicitFirstArg);
    }
    eventDefToType(def) {
        const argTs = def.vParameters.vParameters.map((arg) => this.variableDeclarationToTypeNode(arg));
        return new ast_2.EventType(def.name, argTs);
    }
    errDefToType(def) {
        const argTs = def.vParameters.vParameters.map((arg) => this.variableDeclarationToTypeNode(arg));
        return new ast_2.ErrorType(def.name, argTs);
    }
    /**
     * Computes the function type for the public accessor corresponding to a state variable
     */
    getterFunType(v) {
        const [args, ret] = this.getterArgsAndReturn(v);
        return new ast_2.FunctionType(v.name, args, ret instanceof ast_2.TupleType ? ret.elements : [ret], ast_1.FunctionVisibility.External, ast_1.FunctionStateMutability.View);
    }
    getUnitLevelAbiEncoderVersion(node) {
        const root = node.root;
        (0, misc_1.assert)(root instanceof ast_1.SourceUnit, "Node {0} is not attached to source unit", node);
        return (0, utils_1.getABIEncoderVersion)(root, this.version);
    }
    /**
     * Computes the argument types and return type for the public accessor
     * corresponding to a state variable.
     */
    getterArgsAndReturn(v) {
        const argTypes = [];
        let type = v.vType;
        (0, misc_1.assert)(type !== undefined, "Called getterArgsAndReturn() on variable declaration without type", v);
        const encoderVersion = this.getUnitLevelAbiEncoderVersion(v);
        while (true) {
            if (type instanceof ast_1.ArrayTypeName) {
                argTypes.push(new ast_2.IntType(256, false));
                type = type.vBaseType;
            }
            else if (type instanceof ast_1.Mapping) {
                argTypes.push(this.typeNameToSpecializedTypeNode(type.vKeyType, constants_1.DataLocation.Memory));
                type = type.vValueType;
            }
            else {
                break;
            }
        }
        let retType = this.typeNameToSpecializedTypeNode(type, constants_1.DataLocation.Memory);
        if (retType instanceof ast_2.PointerType &&
            retType.to instanceof ast_2.UserDefinedType &&
            retType.to.definition instanceof ast_1.StructDefinition) {
            const elements = [];
            for (const member of retType.to.definition.vMembers) {
                const rawMemberT = member.vType;
                (0, misc_1.assert)(rawMemberT !== undefined, "Unexpected untyped struct member", retType.to.definition);
                if (rawMemberT instanceof ast_1.Mapping || rawMemberT instanceof ast_1.ArrayTypeName) {
                    continue;
                }
                const memberT = this.typeNameToSpecializedTypeNode(rawMemberT, constants_1.DataLocation.Memory);
                if (rawMemberT instanceof ast_1.UserDefinedTypeName &&
                    rawMemberT.vReferencedDeclaration instanceof ast_1.StructDefinition) {
                    (0, misc_1.assert)(encoderVersion !== abi_1.ABIEncoderVersion.V1 || isSupportedByEncoderV1(memberT), "Type {0} is not supported by encoder {1}", memberT, encoderVersion);
                }
                elements.push(memberT);
            }
            retType = new ast_2.TupleType(elements);
        }
        return [argTypes, retType];
    }
    /**
     * Given the `name` string of elementary type,
     * returns corresponding type node.
     *
     * @todo Consider fixes due to https://github.com/ConsenSys/solc-typed-ast/issues/160
     */
    static elementaryTypeNameStringToTypeNode(name) {
        name = name.trim();
        if (name === "bool") {
            return new ast_2.BoolType();
        }
        let m = name.match(RX_INTEGER);
        if (m !== null) {
            const isSigned = m[1] !== "u";
            const bitWidth = m[2] === "" ? 256 : parseInt(m[2]);
            return new ast_2.IntType(bitWidth, isSigned);
        }
        m = name.match(RX_ADDRESS);
        if (m !== null) {
            const isPayable = m[1] === "payable";
            return new ast_2.AddressType(isPayable);
        }
        m = name.match(RX_FIXED_BYTES);
        if (m !== null) {
            const size = parseInt(m[1]);
            return new ast_2.FixedBytesType(size);
        }
        if (name === "byte") {
            return new ast_2.FixedBytesType(1);
        }
        if (name === "bytes") {
            return new ast_2.BytesType();
        }
        if (name === "string") {
            return new ast_2.StringType();
        }
        return undefined;
    }
    /**
     * Convert a given ast `TypeName` into a `TypeNode`.
     * This produces "general type patterns" without any specific storage information.
     */
    typeNameToTypeNode(node) {
        if (node instanceof ast_1.ElementaryTypeName) {
            const type = InferType.elementaryTypeNameStringToTypeNode(node.name);
            (0, misc_1.assert)(type !== undefined, 'NYI converting elementary type name "{0}"', node.name);
            /**
             * The payability marker of an "address" type is contained
             * in `stateMutability` property instead of "name" string.
             */
            if (type instanceof ast_2.AddressType) {
                type.payable = node.stateMutability === "payable";
            }
            return type;
        }
        if (node instanceof ast_1.ArrayTypeName) {
            const elT = this.typeNameToTypeNode(node.vBaseType);
            let size;
            if (node.vLength) {
                const result = (0, eval_const_1.evalConstantExpr)(node.vLength, this);
                (0, misc_1.assert)(typeof result === "bigint", "Expected bigint for size of an array type", node);
                size = result;
            }
            return new ast_2.ArrayType(elT, size);
        }
        if (node instanceof ast_1.UserDefinedTypeName) {
            const def = node.vReferencedDeclaration;
            if (def instanceof ast_1.StructDefinition ||
                def instanceof ast_1.EnumDefinition ||
                def instanceof ast_1.ContractDefinition ||
                def instanceof ast_1.UserDefinedValueTypeDefinition) {
                return new ast_2.UserDefinedType((0, utils_1.getFQDefName)(def), def);
            }
            throw new Error(`NYI converting user-defined AST type ${def.print()} to TypeNode`);
        }
        if (node instanceof ast_1.FunctionTypeName) {
            /**
             * `vType` is always defined here for parameters if a function type.
             * Even in 0.4.x can't have function declarations with `var` args.
             */
            const args = node.vParameterTypes.vParameters.map((arg) => this.variableDeclarationToTypeNode(arg));
            const rets = node.vReturnParameterTypes.vParameters.map((arg) => this.variableDeclarationToTypeNode(arg));
            return new ast_2.FunctionType(undefined, args, rets, node.visibility, node.stateMutability);
        }
        if (node instanceof ast_1.Mapping) {
            const keyT = this.typeNameToTypeNode(node.vKeyType);
            const valueT = this.typeNameToTypeNode(node.vValueType);
            return new ast_2.MappingType(keyT, valueT);
        }
        throw new Error(`NYI converting AST type ${node.print()} to TypeNode`);
    }
    /**
     * Computes a `TypeNode` equivalent of given `astT`,
     * specialized for location `loc` (if applicable).
     */
    typeNameToSpecializedTypeNode(astT, loc) {
        return (0, utils_1.specializeType)(this.typeNameToTypeNode(astT), loc);
    }
    /**
     * Determine if the specified type `typ` is dynamic or not. Dynamic means
     * that if we are trying to read `typ` at location `loc`, in `loc` there should be just a
     * uint256 offset into memory/storage/calldata, where the actual data lives. Otherwise
     * (if the type is "static"), the direct encoding of the data will start at `loc`.
     *
     * Usually "static" types are just the value types - i.e. anything of statically
     * known size that fits in a uint256. As per https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding
     * there are several exceptions to the rule when encoding types in calldata:
     *
     * 1. Fixed size arrays with fixed-sized element types
     * 2. Tuples where all the tuple elements are fixed-size
     *
     * @todo (Dimo):
     * 1. Check again that its not possible for tuples in internal calls to somehow get encoded on the stack
     * 2. What happens with return tuples? Are they always in memory?
     */
    isABITypeEncodingDynamic(typ) {
        if (typ instanceof ast_2.PointerType ||
            typ instanceof ast_2.ArrayType ||
            typ instanceof ast_2.StringType ||
            typ instanceof ast_2.BytesType) {
            return true;
        }
        // Tuples in calldata with static elements
        if (typ instanceof ast_2.TupleType) {
            for (const elT of typ.elements) {
                (0, misc_1.assert)(elT !== null, `Unexpected empty tuple element in {0}`, typ);
                if (this.isABITypeEncodingDynamic(elT)) {
                    return true;
                }
            }
            return false;
        }
        return false;
    }
    isABIEncodable(type, encoderVersion) {
        if (type instanceof ast_2.AddressType ||
            type instanceof ast_2.BoolType ||
            type instanceof ast_2.BytesType ||
            type instanceof ast_2.FixedBytesType ||
            (type instanceof ast_2.FunctionType &&
                (type.visibility === ast_1.FunctionVisibility.External ||
                    type.visibility === ast_1.FunctionVisibility.Public)) ||
            type instanceof ast_2.IntType ||
            type instanceof ast_2.IntLiteralType ||
            type instanceof ast_2.StringLiteralType ||
            type instanceof ast_2.StringType) {
            return true;
        }
        if (type instanceof ast_2.PointerType) {
            return this.isABIEncodable(type.to, encoderVersion);
        }
        if (encoderVersion === abi_1.ABIEncoderVersion.V1 && !isSupportedByEncoderV1(type)) {
            return false;
        }
        if (type instanceof ast_2.ArrayType) {
            return this.isABIEncodable(type.elementT, encoderVersion);
        }
        if (type instanceof ast_2.UserDefinedType) {
            if (type.definition instanceof ast_1.ContractDefinition ||
                type.definition instanceof ast_1.EnumDefinition ||
                type.definition instanceof ast_1.UserDefinedValueTypeDefinition) {
                return true;
            }
            if (type.definition instanceof ast_1.StructDefinition) {
                return type.definition.vMembers.every((field) => this.isABIEncodable(this.variableDeclarationToTypeNode(field), encoderVersion));
            }
        }
        return false;
    }
    /**
     * Convert an internal TypeNode to the external TypeNode that would correspond to it
     * after ABI-encoding with encoder version `encoderVersion`. Follows the following rules:
     *
     * 1. Contract definitions turned to address.
     * 2. Enum definitions turned to uint of minimal fitting size.
     * 3. Storage pointer types are converted to memory pointer types when `normalizePointers` is set to `true`.
     * 4. Throw an error on any nested mapping types.
     * 5. Fixed-size arrays with fixed-sized element types are encoded as inlined tuples
     * 6. Structs with fixed-sized elements are encoded as inlined tuples
     *
     * @see https://docs.soliditylang.org/en/latest/abi-spec.html
     */
    toABIEncodedType(type, encoderVersion, normalizePointers = false) {
        (0, misc_1.assert)(this.isABIEncodable(type, encoderVersion), 'Can not ABI-encode type "{0}" with encoder "{1}"', type, encoderVersion);
        if (type instanceof ast_2.ArrayType) {
            const elT = this.toABIEncodedType(type.elementT, encoderVersion);
            return new ast_2.ArrayType(elT, type.size);
        }
        if (type instanceof ast_2.PointerType) {
            const toT = this.toABIEncodedType(type.to, encoderVersion, normalizePointers);
            return this.isABITypeEncodingDynamic(toT)
                ? new ast_2.PointerType(toT, normalizePointers ? constants_1.DataLocation.Memory : type.location)
                : toT;
        }
        if (type instanceof ast_2.UserDefinedType) {
            if (type.definition instanceof ast_1.UserDefinedValueTypeDefinition) {
                return this.typeNameToTypeNode(type.definition.underlyingType);
            }
            if (type.definition instanceof ast_1.ContractDefinition) {
                return reserved_1.types.address;
            }
            if (type.definition instanceof ast_1.EnumDefinition) {
                return (0, utils_1.enumToIntType)(type.definition);
            }
            if (type.definition instanceof ast_1.StructDefinition) {
                const fieldTs = type.definition.vMembers.map((fieldT) => this.variableDeclarationToTypeNode(fieldT));
                return new ast_2.TupleType(fieldTs.map((fieldT) => this.toABIEncodedType(fieldT, encoderVersion, normalizePointers)));
            }
        }
        return type;
    }
    /**
     * Returns canonical representation of the signature as string.
     *
     * NOTE: Empty string will be returned for fallback functions and constructors.
     */
    signature(node) {
        let name;
        let args;
        const encoderVersion = this.getUnitLevelAbiEncoderVersion(node);
        if (node instanceof ast_1.VariableDeclaration) {
            name = node.name;
            const [getterArgs] = this.getterArgsAndReturn(node);
            args = getterArgs.map((type) => (0, abi_1.abiTypeToCanonicalName)(this.toABIEncodedType(type, encoderVersion, true)));
        }
        else if (node instanceof ast_1.TryCatchClause) {
            if (node.errorName === "") {
                return "";
            }
            name = node.errorName;
            args = node.vParameters
                ? node.vParameters.vParameters.map((arg) => {
                    const type = this.variableDeclarationToTypeNode(arg);
                    const abiType = this.toABIEncodedType(type, encoderVersion);
                    return (0, abi_1.abiTypeToCanonicalName)((0, utils_1.generalizeType)(abiType)[0]);
                })
                : [];
        }
        else {
            if (node instanceof ast_1.FunctionDefinition && (node.name === "" || node.isConstructor)) {
                return "";
            }
            name = node.name;
            // Signatures are computed differently depending on
            // whether this is a library function or a contract method
            if (node.vScope instanceof ast_1.ContractDefinition &&
                (node.vScope.kind === ast_1.ContractKind.Library ||
                    (node instanceof ast_1.FunctionDefinition &&
                        !(0, utils_1.isVisiblityExternallyCallable)(node.visibility)))) {
                args = node.vParameters.vParameters.map((arg) => {
                    const type = this.variableDeclarationToTypeNode(arg);
                    return (0, abi_1.abiTypeToLibraryCanonicalName)(type);
                });
            }
            else {
                args = node.vParameters.vParameters.map((arg) => {
                    const type = this.variableDeclarationToTypeNode(arg);
                    const abiType = this.toABIEncodedType(type, encoderVersion);
                    return (0, abi_1.abiTypeToCanonicalName)((0, utils_1.generalizeType)(abiType)[0]);
                });
            }
        }
        return name + "(" + args.join(",") + ")";
    }
    /**
     * Returns HEX string containing first 4 bytes of keccak256 hash function
     * applied to the canonical representation of the passed
     * function / event / error / modifier or public state variable getter signature.
     *
     * NOTE: Empty string will be returned for fallback functions and constructors.
     */
    signatureHash(node) {
        if (node instanceof ast_1.FunctionDefinition || node instanceof ast_1.TryCatchClause) {
            const signature = this.signature(node);
            return signature ? (0, ast_1.encodeFuncSignature)(signature) : "";
        }
        if (node instanceof ast_1.VariableDeclaration ||
            node instanceof ast_1.ErrorDefinition ||
            node instanceof ast_1.ModifierDefinition) {
            return (0, ast_1.encodeFuncSignature)(this.signature(node));
        }
        if (node instanceof ast_1.EventDefinition) {
            return (0, ast_1.encodeEventSignature)(this.signature(node));
        }
        throw new Error(`Unable to compute signature hash for node ${(0, misc_1.pp)(node)}`);
    }
    interfaceId(contract) {
        if (contract.kind === ast_1.ContractKind.Interface ||
            (contract.kind === ast_1.ContractKind.Contract && contract.abstract)) {
            const selectors = [];
            for (const fn of contract.vFunctions) {
                const hash = this.signatureHash(fn);
                if (hash) {
                    selectors.push(hash);
                }
            }
            for (const v of contract.vStateVariables) {
                if (v.visibility === ast_1.StateVariableVisibility.Public) {
                    selectors.push(this.signatureHash(v));
                }
            }
            return selectors
                .map((selector) => BigInt("0x" + selector))
                .reduce((a, b) => a ^ b, 0n)
                .toString(16)
                .padStart(8, "0");
        }
        return undefined;
    }
    /**
     * Given a particular `FunctionCall` site, resolve the exact callee,
     * accounting for potential overloading.
     *
     * A callsite may come from:
     * 1. A normal call (FunctionType, BuiltinFunctionType, FunctionLikeSetType)
     * 2. An emit statement (EventType)
     * 3. A revert statement (ErrorType).
     *
     * In the case that the callee is a `FunctionLikeSetType`, resolve the exact callee
     * based on the function call arguments. Otherwise return the type of the callee.
     */
    typeOfCallee(callsite) {
        (0, misc_1.assert)(callsite.kind === ast_1.FunctionCallKind.FunctionCall, `typeOfCallee() cannot be called on a call {0} of type {1}`, callsite, callsite.kind);
        const calleeT = this.typeOf(callsite.vExpression);
        (0, misc_1.assert)(calleeT instanceof ast_2.FunctionType ||
            calleeT instanceof ast_2.BuiltinFunctionType ||
            calleeT instanceof ast_2.EventType ||
            calleeT instanceof ast_2.ErrorType ||
            calleeT instanceof ast_2.FunctionLikeSetType, `Unexpected type {0} of callee {1}`, calleeT, callsite.vExpression);
        if (calleeT instanceof ast_2.FunctionType ||
            calleeT instanceof ast_2.EventType ||
            calleeT instanceof ast_2.ErrorType) {
            return calleeT;
        }
        if (calleeT instanceof ast_2.BuiltinFunctionType) {
            return this.specializeBuiltinTypeToCall(callsite, calleeT);
        }
        // FunctionLikeSetType - resolve based on call arguments
        const resolvedCalleeT = this.matchArguments(calleeT.defs, callsite);
        return resolvedCalleeT;
    }
    isExternalCallContext(expr) {
        if (expr instanceof ast_1.Identifier ||
            expr instanceof ast_1.MemberAccess ||
            expr instanceof ast_1.FunctionCallOptions ||
            expr instanceof ast_1.FunctionCall) {
            const exprT = this.typeOf(expr);
            if (exprT instanceof ast_2.UserDefinedType) {
                if (exprT.definition instanceof ast_1.ContractDefinition) {
                    return true;
                }
            }
            if (exprT instanceof ast_2.TypeNameType) {
                return (exprT.type instanceof ast_2.UserDefinedType &&
                    exprT.type.definition instanceof ast_1.ContractDefinition &&
                    exprT.type.definition.kind === ast_1.ContractKind.Library);
            }
        }
        if (expr instanceof ast_1.MemberAccess ||
            expr instanceof ast_1.FunctionCallOptions ||
            expr instanceof ast_1.FunctionCall) {
            return this.isExternalCallContext(expr.vExpression);
        }
        if (expr instanceof ast_1.Conditional) {
            return (this.isExternalCallContext(expr.vTrueExpression) ||
                this.isExternalCallContext(expr.vFalseExpression));
        }
        if (expr instanceof ast_1.TupleExpression && expr.vComponents.length === 1) {
            return this.isExternalCallContext(expr.vComponents[0]);
        }
        return false;
    }
    isFunctionCallExternal(call) {
        if (call.kind !== ast_1.FunctionCallKind.FunctionCall) {
            return false;
        }
        if (call.vFunctionCallType === constants_1.ExternalReferenceType.Builtin &&
            utils_1.CALL_BUILTINS.includes(call.vFunctionName)) {
            return true;
        }
        let exprT = this.typeOf(call.vExpression);
        if (exprT instanceof ast_2.FunctionLikeSetType) {
            const calleeT = this.typeOfCallee(call);
            if (!(calleeT instanceof ast_2.FunctionType)) {
                return false;
            }
            exprT = calleeT;
        }
        if (exprT instanceof ast_2.FunctionType) {
            if (exprT.implicitFirstArg) {
                /**
                 * Calls via using-for are not considered as external.
                 * Currently "implicitFirstArg" is used only for using-for.
                 */
                return false;
            }
            if (exprT.visibility === ast_1.FunctionVisibility.External) {
                return true;
            }
            if (exprT.visibility === ast_1.FunctionVisibility.Public) {
                return this.isExternalCallContext(call.vExpression);
            }
        }
        return false;
    }
}
exports.InferType = InferType;
//# sourceMappingURL=infer.js.map