import { TypeNode } from "./ast";
import { SolTypeError } from "./misc";
export declare class SolTypePatternMismatchError extends SolTypeError {
    readonly expected: TypeNode | TypeNode[];
    readonly actual: TypeNode | TypeNode[];
    constructor(expected: TypeNode | TypeNode[], actual: TypeNode | TypeNode[]);
}
/**
 * To support type elipses in certain builtin constructs (abi.decode* family and
 * type(...)) we introduce a simple notion of polymorphism with 2 types of type
 * var - a normal type-var (used for example to type `type(T) => { min: T, max:
 * T} where T is numeric) and a type 'elispsis' var, that corresponds to the
 * remaining types in a tuple or argument list.
 */
export type TypeSubstituion = Map<string, TypeNode | TypeNode[]>;
/**
 * Given two types `a` and `b` where `a` may contain type vars, but
 * `b` doesn't have any type vars, compute a substituion from type var names
 * to type nodes that converts a to b
 */
export declare function buildSubstituion(a: TypeNode, b: TypeNode, m: TypeSubstituion, compilerVersion: string): void;
/**
 * Given two lists of types as and bs, and a partially computed TypeMap m,
 * accumulate the neccessary substitutions to convert as into bs. Note that as
 * may contain TVars and TRest, but bs must be concrete.
 */
export declare function buildSubstitutions(as: TypeNode[], bs: TypeNode[], m: TypeSubstituion, compilerVersion: string): void;
/**
 * Given a type node `a` that may contain type vars, and a substitution `m`, apply all the
 * substitutions in `m` to `a` and return the resulting TypeNode.
 */
export declare function applySubstitution(a: TypeNode, m: TypeSubstituion): TypeNode;
/**
 * Given a list of type nodes `as` that may contain type vars and type elipsis, and a substitution `m`, apply all the
 * substitutions in `m` to `as` and return the resulting list of type nodes.
 */
export declare function applySubstitutions(as: TypeNode[], m: TypeSubstituion): TypeNode[];
//# sourceMappingURL=polymorphic.d.ts.map