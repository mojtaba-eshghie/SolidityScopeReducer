"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applySubstitutions = exports.applySubstitution = exports.buildSubstitutions = exports.buildSubstituion = exports.SolTypePatternMismatchError = void 0;
const misc_1 = require("../misc");
const ast_1 = require("./ast");
const misc_2 = require("./misc");
const utils_1 = require("./utils");
class SolTypePatternMismatchError extends misc_2.SolTypeError {
    constructor(expected, actual) {
        super(`Pattern mismatch: expected ${(0, misc_1.pp)(expected)} got ${(0, misc_1.pp)(actual)}`);
        this.expected = expected;
        this.actual = actual;
    }
}
exports.SolTypePatternMismatchError = SolTypePatternMismatchError;
/**
 * Given two types `a` and `b` where `a` may contain type vars, but
 * `b` doesn't have any type vars, compute a substituion from type var names
 * to type nodes that converts a to b
 */
function buildSubstituion(a, b, m, compilerVersion) {
    if (a instanceof ast_1.TVar) {
        const existingMapping = m.get(a.name);
        if (existingMapping !== undefined) {
            if (!(0, misc_1.eq)(existingMapping, b)) {
                throw new misc_2.SolTypeError(`Type var ${a.name} mapped to two different things: ${(0, misc_1.pp)(existingMapping)} and ${b.pp()}`);
            }
        }
        else {
            m.set(a.name, b);
        }
        return;
    }
    if (a instanceof ast_1.ArrayType && b instanceof ast_1.ArrayType) {
        if (a.size !== b.size) {
            throw new SolTypePatternMismatchError(a, b);
        }
        buildSubstituion(a.elementT, b.elementT, m, compilerVersion);
        return;
    }
    if (a instanceof ast_1.FunctionType && b instanceof ast_1.FunctionType) {
        if (a.visibility !== b.visibility || a.mutability !== b.mutability) {
            throw new SolTypePatternMismatchError(a, b);
        }
        buildSubstitutions(a.parameters, b.parameters, m, compilerVersion);
        buildSubstitutions(a.returns, b.returns, m, compilerVersion);
        return;
    }
    if (a instanceof ast_1.BuiltinFunctionType && b instanceof ast_1.BuiltinFunctionType) {
        buildSubstitutions(a.parameters, b.parameters, m, compilerVersion);
        buildSubstitutions(a.returns, b.returns, m, compilerVersion);
        return;
    }
    if (a instanceof ast_1.MappingType && b instanceof ast_1.MappingType) {
        buildSubstituion(a.keyType, b.keyType, m, compilerVersion);
        buildSubstituion(a.valueType, b.valueType, m, compilerVersion);
        return;
    }
    if (a instanceof ast_1.PointerType && b instanceof ast_1.PointerType) {
        buildSubstituion(a.to, b.to, m, compilerVersion);
        return;
    }
    if (a instanceof ast_1.TupleType && b instanceof ast_1.TupleType) {
        (0, misc_1.assert)((0, misc_1.forAll)(a.elements, (el) => el !== null) && (0, misc_1.forAll)(b.elements, (el) => el !== null), `Unexpected tuple with empty elements when building type substitution: {0} or {1}`, a, b);
        buildSubstitutions(a.elements, b.elements, m, compilerVersion);
        return;
    }
    if (a instanceof ast_1.TypeNameType && b instanceof ast_1.TypeNameType) {
        buildSubstituion(a.type, b.type, m, compilerVersion);
        return;
    }
    if (a instanceof ast_1.BuiltinStructType && b instanceof ast_1.BuiltinStructType) {
        if (a.members.size !== b.members.size) {
            throw new SolTypePatternMismatchError(a, b);
        }
        for (const [aName, aVerDepTypes] of a.members) {
            const bVerDepTypes = b.members.get(aName);
            if (bVerDepTypes === undefined) {
                throw new SolTypePatternMismatchError(a, b);
            }
            if (aVerDepTypes.length !== bVerDepTypes.length) {
                throw new SolTypePatternMismatchError(a, b);
            }
            for (let i = 0; i < aVerDepTypes.length; i++) {
                const [aType, aVer] = aVerDepTypes[i];
                const [bType, bVer] = bVerDepTypes[i];
                if (aVer !== bVer) {
                    throw new SolTypePatternMismatchError(a, b);
                }
                buildSubstituion(aType, bType, m, compilerVersion);
            }
        }
        return;
    }
    if ((0, misc_1.eq)(a, b)) {
        return;
    }
    if ((0, utils_1.castable)(b, a, compilerVersion)) {
        return;
    }
    throw new SolTypePatternMismatchError(a, b);
}
exports.buildSubstituion = buildSubstituion;
/**
 * Given two lists of types as and bs, and a partially computed TypeMap m,
 * accumulate the neccessary substitutions to convert as into bs. Note that as
 * may contain TVars and TRest, but bs must be concrete.
 */
function buildSubstitutions(as, bs, m, compilerVersion) {
    for (let i = 0; i < as.length; i++) {
        // Note below we allow the last TRest to match to an empty list of types.
        if (i >= bs.length && !(i === as.length - 1 && as[i] instanceof ast_1.TRest)) {
            throw new SolTypePatternMismatchError(as, bs);
        }
        const patternT = as[i];
        if (patternT instanceof ast_1.TRest) {
            const existingMapping = m.get(patternT.name);
            const actual = bs.slice(i);
            if (existingMapping !== undefined) {
                if (!(0, misc_1.eq)(existingMapping, actual)) {
                    throw new misc_2.SolTypeError(`Type var ${patternT.name} mapped to two different things: ${(0, misc_1.pp)(existingMapping)} and ${(0, misc_1.pp)(actual)}`);
                }
            }
            else {
                m.set(patternT.name, actual);
            }
            return;
        }
        buildSubstituion(patternT, bs[i], m, compilerVersion);
    }
}
exports.buildSubstitutions = buildSubstitutions;
/**
 * Given a type node `a` that may contain type vars, and a substitution `m`, apply all the
 * substitutions in `m` to `a` and return the resulting TypeNode.
 */
function applySubstitution(a, m) {
    if (a instanceof ast_1.TVar) {
        const mapped = m.get(a.name);
        (0, misc_1.assert)(!(mapped instanceof Array), "Unexpected mapping from tvar {0} to list of types {1}", a.name, mapped);
        return mapped ? mapped : a;
    }
    if (a instanceof ast_1.ArrayType) {
        return new ast_1.ArrayType(applySubstitution(a.elementT, m), a.size);
    }
    if (a instanceof ast_1.FunctionType) {
        return new ast_1.FunctionType(a.name, applySubstitutions(a.parameters, m), applySubstitutions(a.returns, m), a.visibility, a.mutability, a.implicitFirstArg);
    }
    if (a instanceof ast_1.BuiltinFunctionType) {
        return new ast_1.BuiltinFunctionType(a.name, applySubstitutions(a.parameters, m), applySubstitutions(a.returns, m));
    }
    if (a instanceof ast_1.EventType) {
        return new ast_1.EventType(a.name, applySubstitutions(a.parameters, m));
    }
    if (a instanceof ast_1.ErrorType) {
        return new ast_1.ErrorType(a.name, applySubstitutions(a.parameters, m));
    }
    if (a instanceof ast_1.MappingType) {
        return new ast_1.MappingType(applySubstitution(a.keyType, m), applySubstitution(a.valueType, m));
    }
    if (a instanceof ast_1.PointerType) {
        return new ast_1.PointerType(applySubstitution(a.to, m), a.location, a.kind);
    }
    if (a instanceof ast_1.TupleType) {
        (0, misc_1.assert)((0, misc_1.forAll)(a.elements, (el) => el !== null), "Unexpected tuple with empty elements when applying type substitution: {0}", a);
        return new ast_1.TupleType(applySubstitutions(a.elements, m));
    }
    if (a instanceof ast_1.TypeNameType) {
        return new ast_1.TypeNameType(applySubstitution(a.type, m));
    }
    if (a instanceof ast_1.BuiltinStructType) {
        const oldMembers = [...a.members.entries()];
        return new ast_1.BuiltinStructType(a.name, new Map(oldMembers.map(([name, verDepTypes]) => [
            name,
            verDepTypes.map(([type, ver]) => [applySubstitution(type, m), ver])
        ])));
    }
    return a;
}
exports.applySubstitution = applySubstitution;
/**
 * Given a list of type nodes `as` that may contain type vars and type elipsis, and a substitution `m`, apply all the
 * substitutions in `m` to `as` and return the resulting list of type nodes.
 */
function applySubstitutions(as, m) {
    const resTs = [];
    for (let i = 0; i < as.length; i++) {
        const elT = as[i];
        if (elT instanceof ast_1.TRest) {
            (0, misc_1.assert)(i === as.length - 1, "Unexpected TRest not in the last place in a type list`");
            const mapped = m.get(elT.name);
            if (mapped) {
                (0, misc_1.assert)(mapped instanceof Array, `TRest ${elT.name} not mapped to array. Instead mapped to ${(0, misc_1.pp)(mapped)}`);
                resTs.push(...mapped);
            }
            else {
                resTs.push(elT);
            }
        }
        else {
            resTs.push(applySubstitution(elT, m));
        }
    }
    return resTs;
}
exports.applySubstitutions = applySubstitutions;
//# sourceMappingURL=polymorphic.js.map