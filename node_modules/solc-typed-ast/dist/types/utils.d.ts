import Decimal from "decimal.js";
import { ContractDefinition, DataLocation, EnumDefinition, ErrorDefinition, EventDefinition, Expression, FunctionDefinition, FunctionVisibility, ModifierDefinition, SourceUnit, VariableDeclaration } from "../ast";
import { ABIEncoderVersion } from "./abi";
import { BuiltinFunctionType, FixedBytesType, FunctionSetType, FunctionType, IntType, Rational, TypeNode, UserDefinition } from "./ast";
import { VersionDependentType } from "./builtins";
export declare const SUBDENOMINATION_MULTIPLIERS: Map<string, Decimal>;
export declare const CALL_BUILTINS: string[];
export declare const BINARY_OPERATOR_GROUPS: {
    Arithmetic: string[];
    Bitwise: string[];
    Comparison: string[];
    Equality: string[];
    Logical: string[];
};
export declare function getTypeForCompilerVersion(typing: TypeNode | VersionDependentType, compilerVersion: string): TypeNode | undefined;
/**
 * Given 2 function pointer's visibilities infer a common visibility thats compatible with both.
 * This is used to infer the visibility of the expression `flag ? fun1 : fun2` where fun1 and fun2 are
 * function pointers.
 */
export declare function inferCommonVisiblity(a: FunctionVisibility, b: FunctionVisibility): FunctionVisibility | undefined;
/**
 * Given two `FunctionType`s/`BuiltinFunctionType`s/`FunctionSetType`s `a` and `b`
 * return a `FunctionSetType` that includes everything in `a` and `b`.
 */
export declare function mergeFunTypes(a: FunctionType | BuiltinFunctionType | FunctionSetType, b: FunctionType | BuiltinFunctionType | FunctionSetType): FunctionSetType;
/**
 * Strip any singleton parens from expressions. I.e. given (((e))) returns e.
 */
export declare function stripSingletonParens(e: Expression): Expression;
/**
 * Given a general type 'pattern' that doesn't contain any data locations, and a data location,
 * produce a concrete instance of the general type for the target location.
 * This is the inverse of `specializeType()`
 *
 * Note that this has to recursively fix sub-parts of compount types such as arrays and maps.
 * Note that this doesn't handle all possible expression types - just the ones that that may appear
 * in a variable declaration.
 *
 * @param type - general type "pattern"
 * @param loc - target location to specialize to
 * @returns specialized type
 */
export declare function specializeType(type: TypeNode, loc: DataLocation): TypeNode;
/**
 * Given a `TypeNode` `type` that is specialized to some storage location,
 * compute the original 'general' type that is independent of location.
 * This is the inverse of `specializeType()`
 *
 * Note that this doesn't handle all possible expression types - just the ones that that may appear
 * in a variable declaration.
 *
 * @param type - specialized type
 * @returns computed generalized type.
 */
export declare function generalizeType(type: TypeNode): [TypeNode, DataLocation | undefined];
export type NamedDefinition = UserDefinition | FunctionDefinition | ErrorDefinition | EventDefinition | VariableDeclaration | ModifierDefinition;
export declare function getFQDefName(def: NamedDefinition): string;
export declare function isReferenceType(generalT: TypeNode): boolean;
export declare function enumToIntType(decl: EnumDefinition): IntType;
export declare function fixedBytesTypeToIntType(type: FixedBytesType): IntType;
export declare function getABIEncoderVersion(unit: SourceUnit, compilerVersion: string): ABIEncoderVersion;
export declare function getFallbackRecvFuns(contract: ContractDefinition): FunctionDefinition[];
export declare function isVisiblityExternallyCallable(a: FunctionVisibility): boolean;
/**
 * Return true IFF `fromT` can be implicitly casted to `toT`
 */
export declare function castable(fromT: TypeNode, toT: TypeNode, compilerVersion: string): boolean;
/**
 * Find the smallest concrete int type that can hold the passed in `literals`.
 */
export declare function smallestFittingType(...literals: bigint[]): IntType | undefined;
/**
 * Helper to cast the bigint `val` to the `IntType` `type`.
 */
export declare function clampIntToType(val: bigint, type: IntType): bigint;
export declare function decimalToRational(d: Decimal): Rational;
//# sourceMappingURL=utils.d.ts.map