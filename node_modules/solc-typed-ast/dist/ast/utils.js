"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.detectFunctionKind = exports.parseSourceLocation = exports.sequence = exports.encodeEventSignature = exports.encodeFuncSignature = exports.split = void 0;
const web3_eth_abi_1 = require("web3-eth-abi");
const constants_1 = require("./constants");
/**
 * Splits the string using the separator.
 * If the string contains well formed parenthesized expressions
 * then those expression will not be split even if they contain separators.
 *
 * E.g. if we call `split("a,b,c(d,e)", ",", "(", ")")` we will get `["a", "b", "c(d,e)"]`.
 *
 * @param string       String to split
 * @param separator    Separator to use to split the string
 * @param openBrace    String to consider to be an "opening brace"
 * @param closeBrace   String to consider to be a "closing brace"
 *
 * @returns Return the parts into which s has been split.
 */
function split(string, separator, openBrace, closeBrace) {
    const result = [];
    let current = "";
    let index = 0;
    let depth = 0;
    while (index < string.length) {
        if (depth === 0 && string.startsWith(separator, index)) {
            result.push(current);
            current = "";
            index += separator.length;
        }
        else {
            let addStr = "";
            if (string.startsWith(openBrace, index)) {
                depth++;
                addStr = openBrace;
            }
            else if (string.startsWith(closeBrace, index)) {
                depth--;
                if (depth < 0) {
                    throw new Error(`Mismatched braces in string "${string}"`);
                }
                addStr = closeBrace;
            }
            else {
                addStr = string.slice(index, index + 1);
            }
            current += addStr;
            index += addStr.length;
        }
    }
    if (depth !== 0) {
        throw new Error(`Mismatched braces in string "${string}"`);
    }
    result.push(current);
    return result;
}
exports.split = split;
function encodeFuncSignature(signature, hexPrefix = false) {
    const selector = (0, web3_eth_abi_1.encodeFunctionSignature)(signature);
    return hexPrefix ? selector : selector.slice(2);
}
exports.encodeFuncSignature = encodeFuncSignature;
function encodeEventSignature(signature, hexPrefix = false) {
    const selector = (0, web3_eth_abi_1.encodeEventSignature)(signature);
    return hexPrefix ? selector : selector.slice(2);
}
exports.encodeEventSignature = encodeEventSignature;
function* sequence(start = 0, step = 1) {
    while (true) {
        yield (start += step);
    }
}
exports.sequence = sequence;
function parseSourceLocation(range) {
    const parts = range.split(":");
    const offset = parseInt(parts[0], 10);
    const length = parseInt(parts[1], 10);
    const sourceIndex = parseInt(parts[2], 10);
    return { offset, length, sourceIndex };
}
exports.parseSourceLocation = parseSourceLocation;
function detectFunctionKind(attributes) {
    if (attributes.kind) {
        return attributes.kind;
    }
    if (attributes.isConstructor) {
        return constants_1.FunctionKind.Constructor;
    }
    return attributes.name === "" ? constants_1.FunctionKind.Fallback : constants_1.FunctionKind.Function;
}
exports.detectFunctionKind = detectFunctionKind;
//# sourceMappingURL=utils.js.map