import { ASTContext } from "./ast_reader";
import { SourceLocation } from "./utils";
export type ASTNodeCallback = (node: ASTNode) => void;
export type ASTNodeSelector = (node: ASTNode) => boolean;
export declare class ASTNode {
    /**
     * Current tree context of the node
     */
    context?: ASTContext;
    /**
     * Unique identifier number for the node in the tree context
     */
    id: number;
    /**
     * Source mapping data corresponting to the AST node.
     *
     * The value has format `start:length:sourceIndex`:
     * - `start` is the starting index of the corresponding
     *   code fragment substring in the source string;
     * - `length` is the length of corresponding code fragment substring;
     * - `sourceIndex` is the index number of the source unit (file),
     *   that contains the AST node.
     *
     * To get parsed values, use `sourceInfo` accessor.
     */
    src: string;
    /**
     * Raw original Solc AST node that was used to create current node.
     */
    raw?: any;
    /**
     * The AST node that is containing current node
     */
    parent?: ASTNode;
    constructor(id: number, src: string, raw?: any);
    protected pickNodes(...args: Array<any | Iterable<any>>): ASTNode[];
    /**
     * Sets `parent` to the current node for each of the accessible children node.
     */
    acceptChildren(): void;
    /**
     * Type of the AST node
     */
    get type(): string;
    /**
     * Returns current node AST context. Throws an error if no context is set.
     */
    get requiredContext(): ASTContext;
    /**
     * Returns children nodes of the current node
     */
    get children(): readonly ASTNode[];
    /**
     * Returns the first immediate child of the node,
     * or `undefined` if the node has no children.
     */
    get firstChild(): ASTNode | undefined;
    /**
     * Returns the last immediate child of the node,
     * or `undefined` if the node has no children.
     */
    get lastChild(): ASTNode | undefined;
    /**
     * Returns the node immediately preceding the current one
     * in its `parent`'s `children`.
     *
     * Returns `undefined` if the current node is the first child
     * in its `parent`'s children.
     */
    get previousSibling(): ASTNode | undefined;
    /**
     * Returns the node immediately following the current one
     * in its `parent`'s children.
     *
     * Returns `undefined` if the current node is the last child
     * in its `parent`'s children.
     */
    get nextSibling(): ASTNode | undefined;
    /**
     * Returns most parent node in tree hierarchy
     */
    get root(): ASTNode;
    /**
     * Returns parsed parts of the `src` property value
     */
    get sourceInfo(): SourceLocation;
    walk(callback: ASTNodeCallback): void;
    walkChildren(callback: ASTNodeCallback): void;
    walkParents(callback: ASTNodeCallback): void;
    getChildren(inclusive?: boolean): ASTNode[];
    getChildrenBySelector<T extends ASTNode>(selector: ASTNodeSelector, inclusive?: boolean): T[];
    getChildrenByType<T extends ASTNode>(type: ASTNodeConstructor<T>, inclusive?: boolean): T[];
    getChildrenByTypeString<T extends ASTNode>(typeString: string, inclusive?: boolean): T[];
    getParents(): ASTNode[];
    getClosestParentBySelector<T extends ASTNode>(selector: ASTNodeSelector): T | undefined;
    getClosestParentByType<T extends ASTNode>(type: ASTNodeConstructor<T>): T | undefined;
    getClosestParentByTypeString<T extends ASTNode>(typeString: string): T | undefined;
    getParentsBySelector<T extends ASTNode>(selector: ASTNodeSelector): T[];
    /**
     * Returns string representation of the node properties.

     * @param depth The number of children node levels to output
     */
    print(depth?: number): string;
    getFieldValues(): Map<string, any>;
    getGettersValues(): Map<string, any>;
    /**
     * Extracts and returns substring from `source`,
     * that corresponds to `src` property value of the current node.
     *
     * In other words, returns corresponding code fragment substring.
     */
    extractSourceFragment(source: Uint8Array): Uint8Array;
    private createWalker;
}
export declare class ASTNodeWithChildren<T extends ASTNode> extends ASTNode {
    protected ownChildren: T[];
    get children(): readonly T[];
    removeChild(node: T): T;
    appendChild(node: T): T;
    insertBefore(node: T, referenceNode: T): T;
    insertAfter(node: T, referenceNode: T): T;
    insertAtBeginning(node: T): T;
    replaceChild(newNode: T, oldNode: T): T;
}
export type ASTNodeConstructor<T extends ASTNode> = new (id: number, src: string, ...args: any[]) => T;
/**
 * Replace the node `oldNode` in the tree with `newNode`.
 *
 * If `p` is the parent of `oldNode`, this function needs to find a property
 * `propName` of `p` such that `p[propName] === oldNode`.
 *
 * Once found, it re-assigns `p[propName] = newNode` and sets
 * `newNode.parent=p` using `acceptChildren`. Since `children` is a getter
 * there is nothing further to do.
 */
export declare function replaceNode(oldNode: ASTNode, newNode: ASTNode): void;
//# sourceMappingURL=ast_node.d.ts.map