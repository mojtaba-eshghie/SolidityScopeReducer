"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceNode = exports.ASTNodeWithChildren = exports.ASTNode = void 0;
const ast_node_formatter_1 = require("./ast_node_formatter");
const utils_1 = require("./utils");
const formatter = new ast_node_formatter_1.ASTNodeFormatter();
class ASTNode {
    constructor(id, src, raw) {
        this.id = id;
        this.src = src;
        this.raw = raw;
    }
    pickNodes(...args) {
        const result = [];
        for (const arg of args) {
            if (arg instanceof ASTNode) {
                result.push(arg);
            }
            else if (arg === null || arg === undefined || typeof arg === "string") {
                continue;
            }
            else if (typeof arg[Symbol.iterator] === "function") {
                result.push(...this.pickNodes(...arg));
            }
        }
        return result;
    }
    /**
     * Sets `parent` to the current node for each of the accessible children node.
     */
    acceptChildren() {
        for (const node of this.children) {
            node.parent = this;
        }
    }
    /**
     * Type of the AST node
     */
    get type() {
        return this.constructor.name;
    }
    /**
     * Returns current node AST context. Throws an error if no context is set.
     */
    get requiredContext() {
        if (this.context) {
            return this.context;
        }
        throw new Error("AST context is not set");
    }
    /**
     * Returns children nodes of the current node
     */
    get children() {
        return this.pickNodes();
    }
    /**
     * Returns the first immediate child of the node,
     * or `undefined` if the node has no children.
     */
    get firstChild() {
        return this.children[0];
    }
    /**
     * Returns the last immediate child of the node,
     * or `undefined` if the node has no children.
     */
    get lastChild() {
        return this.children[this.children.length - 1];
    }
    /**
     * Returns the node immediately preceding the current one
     * in its `parent`'s `children`.
     *
     * Returns `undefined` if the current node is the first child
     * in its `parent`'s children.
     */
    get previousSibling() {
        if (this.parent === undefined) {
            return undefined;
        }
        const nodes = this.parent.children;
        const index = nodes.indexOf(this);
        return nodes[index - 1];
    }
    /**
     * Returns the node immediately following the current one
     * in its `parent`'s children.
     *
     * Returns `undefined` if the current node is the last child
     * in its `parent`'s children.
     */
    get nextSibling() {
        if (this.parent === undefined) {
            return undefined;
        }
        const nodes = this.parent.children;
        const index = nodes.indexOf(this);
        return nodes[index + 1];
    }
    /**
     * Returns most parent node in tree hierarchy
     */
    get root() {
        let node = this;
        while (node.parent) {
            node = node.parent;
        }
        return node;
    }
    /**
     * Returns parsed parts of the `src` property value
     */
    get sourceInfo() {
        return (0, utils_1.parseSourceLocation)(this.src);
    }
    walk(callback) {
        const walker = this.createWalker(callback);
        walker(this);
    }
    walkChildren(callback) {
        const walker = this.createWalker(callback);
        for (const node of this.children) {
            walker(node);
        }
    }
    walkParents(callback) {
        let node = this.parent;
        while (node) {
            callback(node);
            node = node.parent;
        }
    }
    getChildren(inclusive = false) {
        const nodes = [];
        const callback = (node) => {
            nodes.push(node);
        };
        if (inclusive) {
            this.walk(callback);
        }
        else {
            this.walkChildren(callback);
        }
        return nodes;
    }
    getChildrenBySelector(selector, inclusive = true) {
        const nodes = [];
        const callback = (node) => {
            if (selector(node)) {
                nodes.push(node);
            }
        };
        if (inclusive) {
            this.walk(callback);
        }
        else {
            this.walkChildren(callback);
        }
        return nodes;
    }
    getChildrenByType(type, inclusive = false) {
        return this.getChildrenBySelector((node) => node instanceof type, inclusive);
    }
    getChildrenByTypeString(typeString, inclusive = false) {
        return this.getChildrenBySelector((node) => node.type === typeString, inclusive);
    }
    getParents() {
        const nodes = [];
        this.walkParents((node) => {
            nodes.push(node);
        });
        return nodes;
    }
    getClosestParentBySelector(selector) {
        let node = this.parent;
        while (node) {
            if (selector(node)) {
                return node;
            }
            node = node.parent;
        }
        return undefined;
    }
    getClosestParentByType(type) {
        return this.getClosestParentBySelector((node) => node instanceof type);
    }
    getClosestParentByTypeString(typeString) {
        return this.getClosestParentBySelector((node) => node.type === typeString);
    }
    getParentsBySelector(selector) {
        const nodes = [];
        const callback = (node) => {
            if (selector(node)) {
                nodes.push(node);
            }
        };
        this.walkParents(callback);
        return nodes;
    }
    /**
     * Returns string representation of the node properties.

     * @param depth The number of children node levels to output
     */
    print(depth = 0) {
        return formatter.format(this, depth);
    }
    getFieldValues() {
        return new Map(Object.entries(this));
    }
    getGettersValues() {
        const getters = [];
        let proto = Object.getPrototypeOf(this);
        while (proto) {
            for (const name of Object.getOwnPropertyNames(proto)) {
                if (name === "__proto__") {
                    continue;
                }
                const descriptor = Object.getOwnPropertyDescriptor(proto, name);
                if (descriptor && typeof descriptor.get === "function" && !getters.includes(name)) {
                    getters.push(name);
                }
            }
            proto = Object.getPrototypeOf(proto);
        }
        const result = new Map();
        for (const g of getters) {
            result.set(g, this[g]);
        }
        return result;
    }
    /**
     * Extracts and returns substring from `source`,
     * that corresponds to `src` property value of the current node.
     *
     * In other words, returns corresponding code fragment substring.
     */
    extractSourceFragment(source) {
        const { offset, length } = this.sourceInfo;
        return source.slice(offset, offset + length);
    }
    createWalker(callback) {
        const walker = (node) => {
            callback(node);
            for (const child of node.children) {
                walker(child);
            }
        };
        return walker;
    }
}
exports.ASTNode = ASTNode;
class ASTNodeWithChildren extends ASTNode {
    constructor() {
        super(...arguments);
        this.ownChildren = [];
    }
    get children() {
        return this.ownChildren;
    }
    removeChild(node) {
        const index = this.ownChildren.indexOf(node);
        if (index === -1) {
            throw new Error("Reference node is not a child of current node");
        }
        this.ownChildren.splice(index, 1);
        node.parent = undefined;
        return node;
    }
    appendChild(node) {
        this.ownChildren.push(node);
        node.parent = this;
        return node;
    }
    insertBefore(node, referenceNode) {
        const index = this.ownChildren.indexOf(referenceNode);
        if (index === -1) {
            throw new Error("Reference node is not a child of current node");
        }
        this.ownChildren.splice(index, 0, node);
        node.parent = this;
        return node;
    }
    insertAfter(node, referenceNode) {
        if (this.ownChildren.indexOf(referenceNode) === -1) {
            throw new Error("Reference node is not a child of current node");
        }
        const sibling = referenceNode.nextSibling;
        return sibling ? this.insertBefore(node, sibling) : this.appendChild(node);
    }
    insertAtBeginning(node) {
        const firstChild = this.firstChild;
        return firstChild ? this.insertBefore(node, firstChild) : this.appendChild(node);
    }
    replaceChild(newNode, oldNode) {
        const index = this.ownChildren.indexOf(oldNode);
        if (index === -1) {
            throw new Error("Old node is not a child of current node");
        }
        this.ownChildren.splice(index, 1, newNode);
        newNode.parent = this;
        oldNode.parent = undefined;
        return oldNode;
    }
}
exports.ASTNodeWithChildren = ASTNodeWithChildren;
/**
 * Replace the node `oldNode` in the tree with `newNode`.
 *
 * If `p` is the parent of `oldNode`, this function needs to find a property
 * `propName` of `p` such that `p[propName] === oldNode`.
 *
 * Once found, it re-assigns `p[propName] = newNode` and sets
 * `newNode.parent=p` using `acceptChildren`. Since `children` is a getter
 * there is nothing further to do.
 */
function replaceNode(oldNode, newNode) {
    if (oldNode.context !== newNode.context) {
        throw new Error("Context mismatch");
    }
    const parent = oldNode.parent;
    if (parent === undefined) {
        return;
    }
    const ownProps = Object.getOwnPropertyDescriptors(parent);
    for (const name in ownProps) {
        const val = ownProps[name].value;
        if (val === oldNode) {
            const tmpObj = {};
            tmpObj[name] = newNode;
            Object.assign(parent, tmpObj);
            oldNode.parent = undefined;
            parent.acceptChildren();
            return;
        }
        if (val instanceof Array) {
            for (let i = 0; i < val.length; i++) {
                if (val[i] === oldNode) {
                    val[i] = newNode;
                    oldNode.parent = undefined;
                    parent.acceptChildren();
                    return;
                }
            }
        }
        if (val instanceof Map) {
            for (const [k, v] of val.entries()) {
                if (v === oldNode) {
                    val.set(k, newNode);
                    oldNode.parent = undefined;
                    parent.acceptChildren();
                    return;
                }
            }
        }
    }
    throw new Error(`Couldn't find child ${oldNode.type}#${oldNode.id} under parent ${parent.type}#${parent.id}`);
}
exports.replaceNode = replaceNode;
//# sourceMappingURL=ast_node.js.map