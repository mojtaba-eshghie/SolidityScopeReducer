import { ASTNode, ASTNodeConstructor } from "./ast_node";
import { ASTContext, ASTPostprocessor } from "./ast_reader";
import { ContractDefinition } from "./implementation/declaration/contract_definition";
import { EnumDefinition } from "./implementation/declaration/enum_definition";
import { EnumValue } from "./implementation/declaration/enum_value";
import { ErrorDefinition } from "./implementation/declaration/error_definition";
import { EventDefinition } from "./implementation/declaration/event_definition";
import { FunctionDefinition } from "./implementation/declaration/function_definition";
import { ModifierDefinition } from "./implementation/declaration/modifier_definition";
import { StructDefinition } from "./implementation/declaration/struct_definition";
import { UserDefinedValueTypeDefinition } from "./implementation/declaration/user_defined_value_type_definition";
import { VariableDeclaration } from "./implementation/declaration/variable_declaration";
import { Assignment } from "./implementation/expression/assignment";
import { BinaryOperation } from "./implementation/expression/binary_operation";
import { Conditional } from "./implementation/expression/conditional";
import { ElementaryTypeNameExpression } from "./implementation/expression/elementary_type_name_expression";
import { FunctionCall } from "./implementation/expression/function_call";
import { FunctionCallOptions } from "./implementation/expression/function_call_options";
import { Identifier } from "./implementation/expression/identifier";
import { IndexAccess } from "./implementation/expression/index_access";
import { IndexRangeAccess } from "./implementation/expression/index_range_access";
import { Literal } from "./implementation/expression/literal";
import { MemberAccess } from "./implementation/expression/member_access";
import { NewExpression } from "./implementation/expression/new_expression";
import { PrimaryExpression } from "./implementation/expression/primary_expression";
import { TupleExpression } from "./implementation/expression/tuple_expression";
import { UnaryOperation } from "./implementation/expression/unary_operation";
import { IdentifierPath } from "./implementation/meta/identifier_path";
import { ImportDirective } from "./implementation/meta/import_directive";
import { InheritanceSpecifier } from "./implementation/meta/inheritance_specifier";
import { ModifierInvocation } from "./implementation/meta/modifier_invocation";
import { OverrideSpecifier } from "./implementation/meta/override_specifier";
import { ParameterList } from "./implementation/meta/parameter_list";
import { PragmaDirective } from "./implementation/meta/pragma_directive";
import { SourceUnit } from "./implementation/meta/source_unit";
import { StructuredDocumentation } from "./implementation/meta/structured_documentation";
import { UsingForDirective } from "./implementation/meta/using_for_directive";
import { Block } from "./implementation/statement/block";
import { Break } from "./implementation/statement/break";
import { Continue } from "./implementation/statement/continue";
import { DoWhileStatement } from "./implementation/statement/do_while_statement";
import { EmitStatement } from "./implementation/statement/emit_statement";
import { ExpressionStatement } from "./implementation/statement/expression_statement";
import { ForStatement } from "./implementation/statement/for_statement";
import { IfStatement } from "./implementation/statement/if_statement";
import { InlineAssembly } from "./implementation/statement/inline_assembly";
import { PlaceholderStatement } from "./implementation/statement/placeholder_statement";
import { Return } from "./implementation/statement/return";
import { RevertStatement } from "./implementation/statement/revert_statement";
import { Throw } from "./implementation/statement/throw";
import { TryCatchClause } from "./implementation/statement/try_catch_clause";
import { TryStatement } from "./implementation/statement/try_statement";
import { UncheckedBlock } from "./implementation/statement/unchecked_block";
import { VariableDeclarationStatement } from "./implementation/statement/variable_declaration_statement";
import { WhileStatement } from "./implementation/statement/while_statement";
import { ArrayTypeName } from "./implementation/type/array_type_name";
import { ElementaryTypeName } from "./implementation/type/elementary_type_name";
import { FunctionTypeName } from "./implementation/type/function_type_name";
import { Mapping } from "./implementation/type/mapping";
import { UserDefinedTypeName } from "./implementation/type/user_defined_type_name";
/**
 * When applied to following tuple type:
 * ```
 * [id: number, src: string, type: string, rest: any]
 * ```
 * Skips first three arguments (`id`, `src` and `type`) and infers only `rest`.
 *
 * This will further be applied to constructor argument tuple types, like
 * `ConstructorParameters<typeof VariableDeclaration>` (for example)
 * to infer only `VariableDeclaration`-specific arguments as the necessary.
 * The leading `id`, `src` and `type` will be generated by `ASTNodeFactory`.
 */
type Specific<Args extends any[]> = Args["length"] extends 0 ? undefined : ((...args: Args) => void) extends (id: number, src: string, ...rest: infer Rest) => void ? Rest : [];
export declare class ASTNodeFactory {
    context: ASTContext;
    postprocessor: ASTPostprocessor;
    private lastId;
    constructor(context?: ASTContext, postprocessor?: ASTPostprocessor);
    makeContractDefinition(...args: Specific<ConstructorParameters<typeof ContractDefinition>>): ContractDefinition;
    makeEnumDefinition(...args: Specific<ConstructorParameters<typeof EnumDefinition>>): EnumDefinition;
    makeEnumValue(...args: Specific<ConstructorParameters<typeof EnumValue>>): EnumValue;
    makeErrorDefinition(...args: Specific<ConstructorParameters<typeof ErrorDefinition>>): ErrorDefinition;
    makeEventDefinition(...args: Specific<ConstructorParameters<typeof EventDefinition>>): EventDefinition;
    makeFunctionDefinition(...args: Specific<ConstructorParameters<typeof FunctionDefinition>>): FunctionDefinition;
    makeModifierDefinition(...args: Specific<ConstructorParameters<typeof ModifierDefinition>>): ModifierDefinition;
    makeStructDefinition(...args: Specific<ConstructorParameters<typeof StructDefinition>>): StructDefinition;
    makeUserDefinedValueTypeDefinition(...args: Specific<ConstructorParameters<typeof UserDefinedValueTypeDefinition>>): UserDefinedValueTypeDefinition;
    makeVariableDeclaration(...args: Specific<ConstructorParameters<typeof VariableDeclaration>>): VariableDeclaration;
    makeAssignment(...args: Specific<ConstructorParameters<typeof Assignment>>): Assignment;
    makeBinaryOperation(...args: Specific<ConstructorParameters<typeof BinaryOperation>>): BinaryOperation;
    makeConditional(...args: Specific<ConstructorParameters<typeof Conditional>>): Conditional;
    makeElementaryTypeNameExpression(...args: Specific<ConstructorParameters<typeof ElementaryTypeNameExpression>>): ElementaryTypeNameExpression;
    makeFunctionCallOptions(...args: Specific<ConstructorParameters<typeof FunctionCallOptions>>): FunctionCallOptions;
    makeFunctionCall(...args: Specific<ConstructorParameters<typeof FunctionCall>>): FunctionCall;
    makeIdentifier(...args: Specific<ConstructorParameters<typeof Identifier>>): Identifier;
    makeIdentifierPath(...args: Specific<ConstructorParameters<typeof IdentifierPath>>): IdentifierPath;
    makeIndexAccess(...args: Specific<ConstructorParameters<typeof IndexAccess>>): IndexAccess;
    makeIndexRangeAccess(...args: Specific<ConstructorParameters<typeof IndexRangeAccess>>): IndexRangeAccess;
    makeLiteral(...args: Specific<ConstructorParameters<typeof Literal>>): Literal;
    makeMemberAccess(...args: Specific<ConstructorParameters<typeof MemberAccess>>): MemberAccess;
    makeNewExpression(...args: Specific<ConstructorParameters<typeof NewExpression>>): NewExpression;
    makePrimaryExpression(...args: Specific<ConstructorParameters<typeof PrimaryExpression>>): PrimaryExpression;
    makeTupleExpression(...args: Specific<ConstructorParameters<typeof TupleExpression>>): TupleExpression;
    makeUnaryOperation(...args: Specific<ConstructorParameters<typeof UnaryOperation>>): UnaryOperation;
    makeImportDirective(...args: Specific<ConstructorParameters<typeof ImportDirective>>): ImportDirective;
    makeInheritanceSpecifier(...args: Specific<ConstructorParameters<typeof InheritanceSpecifier>>): InheritanceSpecifier;
    makeModifierInvocation(...args: Specific<ConstructorParameters<typeof ModifierInvocation>>): ModifierInvocation;
    makeOverrideSpecifier(...args: Specific<ConstructorParameters<typeof OverrideSpecifier>>): OverrideSpecifier;
    makeParameterList(...args: Specific<ConstructorParameters<typeof ParameterList>>): ParameterList;
    makePragmaDirective(...args: Specific<ConstructorParameters<typeof PragmaDirective>>): PragmaDirective;
    makeSourceUnit(...args: Specific<ConstructorParameters<typeof SourceUnit>>): SourceUnit;
    makeStructuredDocumentation(...args: Specific<ConstructorParameters<typeof StructuredDocumentation>>): StructuredDocumentation;
    makeUsingForDirective(...args: Specific<ConstructorParameters<typeof UsingForDirective>>): UsingForDirective;
    makeBlock(...args: Specific<ConstructorParameters<typeof Block>>): Block;
    makeUncheckedBlock(...args: Specific<ConstructorParameters<typeof UncheckedBlock>>): UncheckedBlock;
    makeBreak(...args: Specific<ConstructorParameters<typeof Break>>): Break;
    makeContinue(...args: Specific<ConstructorParameters<typeof Continue>>): Continue;
    makeDoWhileStatement(...args: Specific<ConstructorParameters<typeof DoWhileStatement>>): DoWhileStatement;
    makeEmitStatement(...args: Specific<ConstructorParameters<typeof EmitStatement>>): EmitStatement;
    makeExpressionStatement(...args: Specific<ConstructorParameters<typeof ExpressionStatement>>): ExpressionStatement;
    makeForStatement(...args: Specific<ConstructorParameters<typeof ForStatement>>): ForStatement;
    makeIfStatement(...args: Specific<ConstructorParameters<typeof IfStatement>>): IfStatement;
    makeInlineAssembly(...args: Specific<ConstructorParameters<typeof InlineAssembly>>): InlineAssembly;
    makePlaceholderStatement(...args: Specific<ConstructorParameters<typeof PlaceholderStatement>>): PlaceholderStatement;
    makeReturn(...args: Specific<ConstructorParameters<typeof Return>>): Return;
    makeRevertStatement(...args: Specific<ConstructorParameters<typeof RevertStatement>>): RevertStatement;
    makeThrow(...args: Specific<ConstructorParameters<typeof Throw>>): Throw;
    makeTryCatchClause(...args: Specific<ConstructorParameters<typeof TryCatchClause>>): TryCatchClause;
    makeTryStatement(...args: Specific<ConstructorParameters<typeof TryStatement>>): TryStatement;
    makeVariableDeclarationStatement(...args: Specific<ConstructorParameters<typeof VariableDeclarationStatement>>): VariableDeclarationStatement;
    makeWhileStatement(...args: Specific<ConstructorParameters<typeof WhileStatement>>): WhileStatement;
    makeArrayTypeName(...args: Specific<ConstructorParameters<typeof ArrayTypeName>>): ArrayTypeName;
    makeElementaryTypeName(...args: Specific<ConstructorParameters<typeof ElementaryTypeName>>): ElementaryTypeName;
    makeFunctionTypeName(...args: Specific<ConstructorParameters<typeof FunctionTypeName>>): FunctionTypeName;
    makeMapping(...args: Specific<ConstructorParameters<typeof Mapping>>): Mapping;
    makeUserDefinedTypeName(...args: Specific<ConstructorParameters<typeof UserDefinedTypeName>>): UserDefinedTypeName;
    makeIdentifierFor(target: VariableDeclaration | ContractDefinition | FunctionDefinition | StructDefinition | ErrorDefinition | EventDefinition | EnumDefinition | UserDefinedValueTypeDefinition | ImportDirective): Identifier;
    makeUnfinalized<T extends ASTNode>(type: ASTNodeConstructor<T>, ...args: Specific<ConstructorParameters<typeof type>>): T;
    make<T extends ASTNode>(type: ASTNodeConstructor<T>, ...args: Specific<ConstructorParameters<typeof type>>): T;
    copy<T extends ASTNode>(node: T): T;
    private patchIds;
    private copyHelper;
    private copyValue;
    private typeExtractor;
}
export {};
//# sourceMappingURL=ast_node_factory.d.ts.map