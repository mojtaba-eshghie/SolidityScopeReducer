import { ASTNode, ASTNodeWithChildren } from "../../ast_node";
import { WithDanglingDocs, WithPrecedingDocs } from "../../documentation";
import { StructuredDocumentation } from "../meta";
export declare class Statement extends ASTNode {
    /**
     * Optional documentation appearing above the statement:
     * - Is `undefined` when not specified.
     * - Is type of `string` for compatibility reasons.
     */
    documentation?: string | StructuredDocumentation;
    constructor(id: number, src: string, documentation?: string | StructuredDocumentation, raw?: any);
    get children(): readonly ASTNode[];
}
export declare class StatementWithChildren<T extends ASTNode> extends ASTNodeWithChildren<T> implements WithPrecedingDocs, WithDanglingDocs {
    docString?: string;
    danglingDocString?: string;
    constructor(id: number, src: string, documentation?: string | StructuredDocumentation, raw?: any);
    /**
     * Optional documentation appearing above the contract definition:
     * - Is `undefined` when not specified.
     * - Is type of `string` when specified and compiler version is older than `0.6.3`.
     * - Is instance of `StructuredDocumentation` when specified and compiler version is `0.6.3` or newer.
     */
    get documentation(): string | StructuredDocumentation | undefined;
    set documentation(value: string | StructuredDocumentation | undefined);
    /**
     * Optional documentation that is dangling in the source fragment,
     * that is after end of last child and before the end of the current node.
     *
     * It is:
     * - Is `undefined` when not detected.
     * - Is type of `string` for compatibility reasons.
     */
    get danglingDocumentation(): string | StructuredDocumentation | undefined;
    set danglingDocumentation(value: string | StructuredDocumentation | undefined);
}
//# sourceMappingURL=statement.d.ts.map