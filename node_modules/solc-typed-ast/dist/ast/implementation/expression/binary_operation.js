"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryOperation = void 0;
const declaration_1 = require("../declaration");
const expression_1 = require("./expression");
class BinaryOperation extends expression_1.Expression {
    constructor(id, src, typeString, operator, leftExpression, rightExpression, userFunction, raw) {
        super(id, src, typeString, raw);
        this.operator = operator;
        this.vLeftExpression = leftExpression;
        this.vRightExpression = rightExpression;
        this.userFunction = userFunction;
        this.acceptChildren();
    }
    get children() {
        return this.pickNodes(this.vLeftExpression, this.vRightExpression);
    }
    /**
     * Attribute to access the defintion, bound to the operator.
     *
     * Is `undefined` when there is no definition bound to the operator.
     */
    get vUserFunction() {
        if (!this.userFunction) {
            return undefined;
        }
        const def = this.requiredContext.locate(this.userFunction);
        if (def instanceof declaration_1.FunctionDefinition) {
            return def;
        }
        throw new Error(`Invalid function reference for operation "${this.operator}" of node ${this.type}#${this.id}`);
    }
    set vUserFunction(value) {
        if (value === undefined) {
            this.userFunction = undefined;
        }
        else {
            if (!this.requiredContext.contains(value)) {
                throw new Error(`Node ${value.type}#${value.id} not belongs to a current context`);
            }
            this.userFunction = value.id;
        }
    }
}
exports.BinaryOperation = BinaryOperation;
//# sourceMappingURL=binary_operation.js.map