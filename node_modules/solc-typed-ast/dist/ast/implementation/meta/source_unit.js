"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceUnit = void 0;
const types_1 = require("../../../types");
const ast_node_1 = require("../../ast_node");
const declaration_1 = require("../declaration");
const contract_definition_1 = require("../declaration/contract_definition");
const enum_definition_1 = require("../declaration/enum_definition");
const error_definition_1 = require("../declaration/error_definition");
const function_definition_1 = require("../declaration/function_definition");
const struct_definition_1 = require("../declaration/struct_definition");
const user_defined_value_type_definition_1 = require("../declaration/user_defined_value_type_definition");
const variable_declaration_1 = require("../declaration/variable_declaration");
const import_directive_1 = require("./import_directive");
const pragma_directive_1 = require("./pragma_directive");
const using_for_directive_1 = require("./using_for_directive");
class SourceUnit extends ast_node_1.ASTNodeWithChildren {
    constructor(id, src, sourceEntryKey, sourceListIndex, absolutePath, exportedSymbols, children, license, raw) {
        super(id, src, raw);
        this.sourceEntryKey = sourceEntryKey;
        this.sourceListIndex = sourceListIndex;
        this.absolutePath = absolutePath;
        this.exportedSymbols = exportedSymbols;
        this.license = license;
        if (children) {
            for (const node of children) {
                this.appendChild(node);
            }
        }
    }
    /**
     * References to pragma directives
     */
    get vPragmaDirectives() {
        return this.ownChildren.filter((node) => node instanceof pragma_directive_1.PragmaDirective);
    }
    /**
     * References to import directives
     */
    get vImportDirectives() {
        return this.ownChildren.filter((node) => node instanceof import_directive_1.ImportDirective);
    }
    /**
     * References to contract definitions
     */
    get vContracts() {
        return this.ownChildren.filter((node) => node instanceof contract_definition_1.ContractDefinition);
    }
    /**
     * References to file-level enum definitions
     */
    get vEnums() {
        return this.ownChildren.filter((node) => node instanceof enum_definition_1.EnumDefinition);
    }
    /**
     * References to file-level error definitions
     */
    get vErrors() {
        return this.ownChildren.filter((node) => node instanceof error_definition_1.ErrorDefinition);
    }
    /**
     * References to file-level struct definitions
     */
    get vStructs() {
        return this.ownChildren.filter((node) => node instanceof struct_definition_1.StructDefinition);
    }
    /**
     * References to file-level function definitions (free functions)
     */
    get vFunctions() {
        return this.ownChildren.filter((node) => node instanceof function_definition_1.FunctionDefinition);
    }
    /**
     * References to file-level event definitions
     */
    get vEvents() {
        return this.ownChildren.filter((node) => node instanceof declaration_1.EventDefinition);
    }
    /**
     * References to file-level constant variable definitions
     */
    get vVariables() {
        return this.ownChildren.filter((node) => node instanceof variable_declaration_1.VariableDeclaration);
    }
    /**
     * References to file-level user-defined value type definitions
     */
    get vUserDefinedValueTypes() {
        return this.ownChildren.filter((node) => node instanceof user_defined_value_type_definition_1.UserDefinedValueTypeDefinition);
    }
    /**
     * References to file-level using-for directives
     */
    get vUsingForDirectives() {
        return this.ownChildren.filter((node) => node instanceof using_for_directive_1.UsingForDirective);
    }
    /**
     * Referenced exported symbols
     */
    get vExportedSymbols() {
        const result = new Map();
        const context = this.requiredContext;
        for (const [name, id] of this.exportedSymbols.entries()) {
            result.set(name, context.locate(id));
        }
        return result;
    }
    /**
     * Returns user-defined ABI encoder version for the source unit.
     * If there is no encoder version defined in the pragma directives,
     * then returns `undefined`.
     */
    get abiEncoderVersion() {
        for (const directive of this.vPragmaDirectives) {
            if (directive.vIdentifier === "abicoder") {
                const raw = directive.literals[1];
                if (raw === "v1") {
                    return types_1.ABIEncoderVersion.V1;
                }
                if (raw === "v2") {
                    return types_1.ABIEncoderVersion.V2;
                }
                throw new Error(`Unknown abicoder pragma version ${raw}`);
            }
            if (directive.vIdentifier === "experimental" &&
                directive.literals.length === 2 &&
                types_1.ABIEncoderVersions.has(directive.literals[1])) {
                return directive.literals[1];
            }
        }
        return undefined;
    }
}
exports.SourceUnit = SourceUnit;
//# sourceMappingURL=source_unit.js.map