"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructDefinition = void 0;
const __1 = require("../../..");
const ast_node_1 = require("../../ast_node");
const variable_declaration_1 = require("./variable_declaration");
class StructDefinition extends ast_node_1.ASTNodeWithChildren {
    constructor(id, src, name, scope, visibility, members, documentation, nameLocation, raw) {
        super(id, src, raw);
        this.name = name;
        this.scope = scope;
        this.visibility = visibility;
        this.documentation = documentation;
        this.nameLocation = nameLocation;
        for (const member of members) {
            this.appendChild(member);
        }
    }
    /**
     * Canonical name (or qualified name), e.g. `DefiningContract.SomeStruct`
     */
    get canonicalName() {
        return (0, __1.getFQDefName)(this);
    }
    /**
     * Optional documentation appearing above the contract definition:
     * - Is `undefined` when not specified.
     * - Is type of `string` when specified and compiler version is older than `0.6.3`.
     * - Is instance of `StructuredDocumentation` when specified and compiler version is `0.6.3` or newer.
     */
    get documentation() {
        return (0, __1.getDocumentation)(this);
    }
    set documentation(value) {
        (0, __1.setDocumentation)(this, value);
    }
    /**
     * Optional documentation that is dangling in the source fragment,
     * that is after end of last child and before the end of the current node.
     *
     * It is:
     * - Is `undefined` when not detected.
     * - Is type of `string` for compatibility reasons.
     */
    get danglingDocumentation() {
        return (0, __1.getDanglingDocumentation)(this);
    }
    set danglingDocumentation(value) {
        (0, __1.setDanglingDocumentation)(this, value);
    }
    /**
     * Members of the struct
     */
    get vMembers() {
        return this.ownChildren.filter((node) => node instanceof variable_declaration_1.VariableDeclaration);
    }
    /**
     * Reference to its scoped contract or source unit
     */
    get vScope() {
        return this.requiredContext.locate(this.scope);
    }
    set vScope(value) {
        if (!this.requiredContext.contains(value)) {
            throw new Error(`Node ${value.type}#${value.id} not belongs to a current context`);
        }
        this.scope = value.id;
    }
}
exports.StructDefinition = StructDefinition;
//# sourceMappingURL=struct_definition.js.map