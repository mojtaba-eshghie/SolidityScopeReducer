import { ASTNode, ASTNodeWithChildren } from "../../ast_node";
import { ContractKind } from "../../constants";
import { WithDanglingDocs, WithPrecedingDocs } from "../../documentation";
import { InheritanceSpecifier } from "../meta/inheritance_specifier";
import { SourceUnit } from "../meta/source_unit";
import { StructuredDocumentation } from "../meta/structured_documentation";
import { UsingForDirective } from "../meta/using_for_directive";
import { EnumDefinition } from "./enum_definition";
import { ErrorDefinition } from "./error_definition";
import { EventDefinition } from "./event_definition";
import { FunctionDefinition } from "./function_definition";
import { ModifierDefinition } from "./modifier_definition";
import { StructDefinition } from "./struct_definition";
import { UserDefinedValueTypeDefinition } from "./user_defined_value_type_definition";
import { VariableDeclaration } from "./variable_declaration";
export declare class ContractDefinition extends ASTNodeWithChildren<ASTNode> implements WithPrecedingDocs, WithDanglingDocs {
    docString?: string;
    danglingDocString?: string;
    /**
     * The contract name
     */
    name: string;
    /**
     * The source range for name string
     */
    nameLocation?: string;
    /**
     *  Id of its scoped source unit
     */
    scope: number;
    /**
     * Type of contract declaration, e.g. `contract`, `library` or `interface`.
     */
    kind: ContractKind;
    /**
     * Is `true` if contract is declared as an abstract
     * (using `abstract` keyword since Solidity 0.6).
     *
     * Is `false` otherwise.
     */
    abstract: boolean;
    /**
     * Is `false` if one of the functions is not implemented.
     *
     * Is `true` otherwise.
     */
    fullyImplemented: boolean;
    /**
     * C3-linearized base contract ids including the current contract's id
     */
    linearizedBaseContracts: number[];
    /**
     * Used error definition ids (including external definition ids)
     */
    usedErrors: number[];
    /**
     * Used error definition ids (including external definition ids)
     */
    usedEvents: number[];
    constructor(id: number, src: string, name: string, scope: number, kind: ContractKind, abstract: boolean, fullyImplemented: boolean, linearizedBaseContracts: number[], usedErrors: number[], usedEvents: number[], documentation?: string | StructuredDocumentation, children?: Iterable<ASTNode>, nameLocation?: string, raw?: any);
    /**
     * Optional documentation appearing above the contract definition:
     * - Is `undefined` when not specified.
     * - Is type of `string` when specified and compiler version is older than `0.6.3`.
     * - Is instance of `StructuredDocumentation` when specified and compiler version is `0.6.3` or newer.
     */
    get documentation(): string | StructuredDocumentation | undefined;
    set documentation(value: string | StructuredDocumentation | undefined);
    /**
     * Optional documentation that is dangling in the source fragment,
     * that is after end of last child and before the end of the current node.
     *
     * It is:
     * - Is `undefined` when not detected.
     * - Is type of `string` for compatibility reasons.
     */
    get danglingDocumentation(): string | StructuredDocumentation | undefined;
    set danglingDocumentation(value: string | StructuredDocumentation | undefined);
    /**
     * Reference to its scoped source unit
     */
    get vScope(): SourceUnit;
    set vScope(value: SourceUnit);
    /**
     * C3-linearized base contract references including the current contract
     */
    get vLinearizedBaseContracts(): readonly ContractDefinition[];
    /**
     * Used error definitions (including external definitions)
     */
    get vUsedErrors(): readonly ErrorDefinition[];
    /**
     * Used event definitions (including external definitions)
     */
    get vUsedEvents(): readonly EventDefinition[];
    /**
     * Inheritance specifiers
     */
    get vInheritanceSpecifiers(): readonly InheritanceSpecifier[];
    /**
     * State variables are `VariableDeclaration`s
     * that have the attribute `stateVariable` set to `true`
     * and that are direct children of a contract
     */
    get vStateVariables(): readonly VariableDeclaration[];
    /**
     * Modifiers of the contract
     */
    get vModifiers(): readonly ModifierDefinition[];
    /**
     * Events of the contract
     */
    get vEvents(): readonly EventDefinition[];
    /**
     * Errors of the contract
     */
    get vErrors(): readonly ErrorDefinition[];
    /**
     * Functions of the contract
     */
    get vFunctions(): readonly FunctionDefinition[];
    /**
     * Type-bound libraries directives of the contract
     */
    get vUsingForDirectives(): readonly UsingForDirective[];
    /**
     * Structs of the contract
     */
    get vStructs(): readonly StructDefinition[];
    /**
     * Enums of the contract
     */
    get vEnums(): readonly EnumDefinition[];
    /**
     * User-defined value type definitions of contract
     */
    get vUserDefinedValueTypes(): readonly UserDefinedValueTypeDefinition[];
    /**
     * Constructor reference (if definition is present for this contract)
     */
    get vConstructor(): FunctionDefinition | undefined;
    /**
     * Returns `true` if `other` contract is present in the inheritance chain
     * of the current contract. Returns `false` otherwise.
     */
    isSubclassOf(other: ContractDefinition): boolean;
}
//# sourceMappingURL=contract_definition.d.ts.map