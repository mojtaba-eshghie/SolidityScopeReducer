"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractDefinition = void 0;
const ast_node_1 = require("../../ast_node");
const documentation_1 = require("../../documentation");
const inheritance_specifier_1 = require("../meta/inheritance_specifier");
const using_for_directive_1 = require("../meta/using_for_directive");
const enum_definition_1 = require("./enum_definition");
const error_definition_1 = require("./error_definition");
const event_definition_1 = require("./event_definition");
const function_definition_1 = require("./function_definition");
const modifier_definition_1 = require("./modifier_definition");
const struct_definition_1 = require("./struct_definition");
const user_defined_value_type_definition_1 = require("./user_defined_value_type_definition");
const variable_declaration_1 = require("./variable_declaration");
class ContractDefinition extends ast_node_1.ASTNodeWithChildren {
    constructor(id, src, name, scope, kind, abstract, fullyImplemented, linearizedBaseContracts, usedErrors, usedEvents, documentation, children, nameLocation, raw) {
        super(id, src, raw);
        this.name = name;
        this.scope = scope;
        this.kind = kind;
        this.abstract = abstract;
        this.fullyImplemented = fullyImplemented;
        this.linearizedBaseContracts = linearizedBaseContracts;
        this.usedErrors = usedErrors;
        this.usedEvents = usedEvents;
        if (children) {
            for (const node of children) {
                this.appendChild(node);
            }
        }
        this.documentation = documentation;
        this.nameLocation = nameLocation;
    }
    /**
     * Optional documentation appearing above the contract definition:
     * - Is `undefined` when not specified.
     * - Is type of `string` when specified and compiler version is older than `0.6.3`.
     * - Is instance of `StructuredDocumentation` when specified and compiler version is `0.6.3` or newer.
     */
    get documentation() {
        return (0, documentation_1.getDocumentation)(this);
    }
    set documentation(value) {
        (0, documentation_1.setDocumentation)(this, value);
    }
    /**
     * Optional documentation that is dangling in the source fragment,
     * that is after end of last child and before the end of the current node.
     *
     * It is:
     * - Is `undefined` when not detected.
     * - Is type of `string` for compatibility reasons.
     */
    get danglingDocumentation() {
        return (0, documentation_1.getDanglingDocumentation)(this);
    }
    set danglingDocumentation(value) {
        (0, documentation_1.setDanglingDocumentation)(this, value);
    }
    /**
     * Reference to its scoped source unit
     */
    get vScope() {
        return this.requiredContext.locate(this.scope);
    }
    set vScope(value) {
        if (!this.requiredContext.contains(value)) {
            throw new Error(`Node ${value.type}#${value.id} not belongs to a current context`);
        }
        this.scope = value.id;
    }
    /**
     * C3-linearized base contract references including the current contract
     */
    get vLinearizedBaseContracts() {
        const context = this.requiredContext;
        return this.linearizedBaseContracts.map((id) => context.locate(id));
    }
    /**
     * Used error definitions (including external definitions)
     */
    get vUsedErrors() {
        const context = this.requiredContext;
        return this.usedErrors.map((id) => context.locate(id));
    }
    /**
     * Used event definitions (including external definitions)
     */
    get vUsedEvents() {
        const context = this.requiredContext;
        return this.usedEvents.map((id) => context.locate(id));
    }
    /**
     * Inheritance specifiers
     */
    get vInheritanceSpecifiers() {
        return this.ownChildren.filter((node) => node instanceof inheritance_specifier_1.InheritanceSpecifier);
    }
    /**
     * State variables are `VariableDeclaration`s
     * that have the attribute `stateVariable` set to `true`
     * and that are direct children of a contract
     */
    get vStateVariables() {
        return this.ownChildren.filter((node) => node instanceof variable_declaration_1.VariableDeclaration);
    }
    /**
     * Modifiers of the contract
     */
    get vModifiers() {
        return this.ownChildren.filter((node) => node instanceof modifier_definition_1.ModifierDefinition);
    }
    /**
     * Events of the contract
     */
    get vEvents() {
        return this.ownChildren.filter((node) => node instanceof event_definition_1.EventDefinition);
    }
    /**
     * Errors of the contract
     */
    get vErrors() {
        return this.ownChildren.filter((node) => node instanceof error_definition_1.ErrorDefinition);
    }
    /**
     * Functions of the contract
     */
    get vFunctions() {
        return this.ownChildren.filter((node) => node instanceof function_definition_1.FunctionDefinition);
    }
    /**
     * Type-bound libraries directives of the contract
     */
    get vUsingForDirectives() {
        return this.ownChildren.filter((node) => node instanceof using_for_directive_1.UsingForDirective);
    }
    /**
     * Structs of the contract
     */
    get vStructs() {
        return this.ownChildren.filter((node) => node instanceof struct_definition_1.StructDefinition);
    }
    /**
     * Enums of the contract
     */
    get vEnums() {
        return this.ownChildren.filter((node) => node instanceof enum_definition_1.EnumDefinition);
    }
    /**
     * User-defined value type definitions of contract
     */
    get vUserDefinedValueTypes() {
        return this.ownChildren.filter((node) => node instanceof user_defined_value_type_definition_1.UserDefinedValueTypeDefinition);
    }
    /**
     * Constructor reference (if definition is present for this contract)
     */
    get vConstructor() {
        return this.vFunctions.find((fn) => fn.isConstructor);
    }
    /**
     * Returns `true` if `other` contract is present in the inheritance chain
     * of the current contract. Returns `false` otherwise.
     */
    isSubclassOf(other) {
        return this.vLinearizedBaseContracts.includes(other);
    }
}
exports.ContractDefinition = ContractDefinition;
//# sourceMappingURL=contract_definition.js.map