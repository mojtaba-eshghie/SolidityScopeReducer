"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LegacyFunctionDefinitionProcessor = void 0;
const constants_1 = require("../constants");
const modifier_invocation_1 = require("../implementation/meta/modifier_invocation");
const override_specifier_1 = require("../implementation/meta/override_specifier");
const structured_documentation_1 = require("../implementation/meta/structured_documentation");
const utils_1 = require("../utils");
const node_processor_1 = require("./node_processor");
class LegacyFunctionDefinitionProcessor extends node_processor_1.LegacyNodeProcessor {
    process(reader, config, raw) {
        const [id, src] = super.process(reader, config, raw);
        const attributes = raw.attributes;
        const children = reader.convertArray(raw.children, config);
        const scope = attributes.scope;
        const isConstructor = attributes.isConstructor;
        const visibility = attributes.visibility;
        const virtual = "virtual" in attributes ? attributes.virtual : false;
        const name = attributes.name;
        const kind = (0, utils_1.detectFunctionKind)(attributes);
        const stateMutability = this.detectStateMutability(attributes);
        const [structuredDocumentation, overrideSpecifier, parameters, returnParameters, modifiers, body] = this.extract(children);
        let documentation;
        if (structuredDocumentation) {
            documentation = structuredDocumentation;
        }
        else if (typeof attributes.documentation === "string") {
            documentation = attributes.documentation;
        }
        return [
            id,
            src,
            scope,
            kind,
            name,
            virtual,
            visibility,
            stateMutability,
            isConstructor,
            parameters,
            returnParameters,
            modifiers,
            overrideSpecifier,
            body,
            documentation,
            undefined,
            raw
        ];
    }
    detectStateMutability(attributes) {
        if (attributes.stateMutability) {
            return attributes.stateMutability;
        }
        if (attributes.constant) {
            return constants_1.FunctionStateMutability.Constant;
        }
        return attributes.payable
            ? constants_1.FunctionStateMutability.Payable
            : constants_1.FunctionStateMutability.NonPayable;
    }
    extract(children) {
        let node = children.shift();
        let documentation;
        if (node instanceof structured_documentation_1.StructuredDocumentation) {
            documentation = node;
            node = children.shift();
        }
        let overrideSpecifier;
        if (node instanceof override_specifier_1.OverrideSpecifier) {
            overrideSpecifier = node;
            node = children.shift();
        }
        const parameters = node;
        node = children.shift();
        const returnParameters = node;
        node = children.shift();
        const modifiers = [];
        while (node instanceof modifier_invocation_1.ModifierInvocation) {
            modifiers.push(node);
            node = children.shift();
        }
        let body;
        if (node) {
            body = node;
        }
        return [documentation, overrideSpecifier, parameters, returnParameters, modifiers, body];
    }
}
exports.LegacyFunctionDefinitionProcessor = LegacyFunctionDefinitionProcessor;
//# sourceMappingURL=function_definition_processor.js.map