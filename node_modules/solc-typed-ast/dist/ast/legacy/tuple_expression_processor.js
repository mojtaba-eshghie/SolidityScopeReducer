"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LegacyTupleExpressionProcessor = void 0;
const utils_1 = require("../utils");
const expression_processor_1 = require("./expression_processor");
class LegacyTupleExpressionProcessor extends expression_processor_1.LegacyExpressionProcessor {
    process(reader, config, raw) {
        const [id, src, typeString] = super.process(reader, config, raw);
        const attributes = raw.attributes;
        const children = raw.children ? reader.convertArray(raw.children, config) : undefined;
        const isInlineArray = attributes.isInlineArray;
        const components = attributes.components
            ? this.extractComponentsFromRaw(attributes.components, reader, config)
            : this.extractComponentsFromTypeString(typeString, children);
        return [id, src, typeString, isInlineArray, components, raw];
    }
    extractComponentsFromRaw(components, reader, config) {
        const nodes = [];
        for (const component of components) {
            const node = component === null ? null : reader.convert(component, config);
            nodes.push(node);
        }
        return nodes;
    }
    extractComponentsFromTypeString(typeString, children) {
        const matches = typeString.match(/^tuple\((.*)\)$/);
        if (matches === null) {
            return children ? children : [];
        }
        /**
         * @todo split() approach may be too fragile, so pay special attention here.
         * Consider to use more robust type string parser instead.
         */
        const componentTypes = (0, utils_1.split)(matches[1], ",", "(", ")");
        const nodes = [];
        let index = 0;
        for (const componentType of componentTypes) {
            if (componentType === "") {
                nodes.push(null);
            }
            else {
                const node = children ? children[index] : undefined;
                if (!node) {
                    throw new Error("Expected component of type " +
                        componentType +
                        " but there is no corresponding child component");
                }
                if (componentType !== node.typeString) {
                    throw new Error("Expected component of type " +
                        componentType +
                        " but got component of type " +
                        node.typeString);
                }
                nodes.push(node);
                index++;
            }
        }
        return nodes;
    }
}
exports.LegacyTupleExpressionProcessor = LegacyTupleExpressionProcessor;
//# sourceMappingURL=tuple_expression_processor.js.map