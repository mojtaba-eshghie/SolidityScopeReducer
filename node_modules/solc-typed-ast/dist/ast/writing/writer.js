"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ASTWriter = exports.YulWriter = exports.ASTNodeWriter = void 0;
const misc_1 = require("../../misc");
const ast_node_1 = require("../ast_node");
/**
 * Base class for all `ASTNodeWriter`s.
 * Child classes are responsible for generating a `SrcDesc` for every node.
 */
class ASTNodeWriter {
    /**
     * Add the node to the descrioption generated by `writeInner`,
     * any additional "wrappings" and return it.
     * Usually `writeWhole` is responsible for adding semicolons and documentation,
     * since these are not generally part of source mappings.
     *
     * For example given this source:
     *
     * ```
     * a = 1;
     * ```
     *
     * `ExpressionStatement.writeInner` would return the following desc:
     *
     * ```
     * [[Assignment#3, [[Identifier#1, ["a"]], " = ", [Literal#2, ["1"]] ]]]
     * ```
     *
     * Then `ExpressionStatement.writeWhole` would add in
     * the `ExpressionStatement` node and the semicolon to return:
     *
     * ```
     * [[ExpressionStatement#4, [[Assignment#3, [[Identifier#1, ["a"]], " = ", [Literal#2, ["1"]] ]]]], ";"]
     * ```
     */
    writeWhole(node, writer) {
        return [[node, this.writeInner(node, writer)]];
    }
}
exports.ASTNodeWriter = ASTNodeWriter;
class YulWriter {
    constructor(mapping, formatter) {
        this.mapping = mapping;
        this.formatter = formatter;
    }
    write(node) {
        const writer = this.mapping.get(node.nodeType);
        if (writer) {
            return writer.write(node, this);
        }
        const data = JSON.stringify(node, undefined, 4);
        throw new Error("Unable to find writer for Yul node: " + data);
    }
}
exports.YulWriter = YulWriter;
class ASTWriter {
    constructor(mapping, formatter, targetCompilerVersion) {
        this.mapping = mapping;
        this.formatter = formatter;
        this.targetCompilerVersion = targetCompilerVersion;
    }
    /**
     * Convert the source description `desc`
     * generated by the `ASTNodeWriter`s into a source string,
     * while also populating the given source map `sourceMap`.
     */
    descToSourceString(desc, sourceMap) {
        let source = "";
        let size = 0;
        const helper = (current) => {
            for (const element of current) {
                if (typeof element === "string") {
                    source += element;
                    size += (0, misc_1.strUTF8Len)(element);
                }
                else {
                    const [node, nodeDesc] = element;
                    const start = size;
                    helper(nodeDesc);
                    const length = size - start;
                    sourceMap.set(node, [start, length]);
                }
            }
        };
        helper(desc);
        return source;
    }
    /**
     * Generate `SrcDesc` for element of `DescArgs`.
     *
     * Used by `ASTNodeWriter`s to handle different nested nodes.
     */
    desc(...args) {
        const result = [];
        for (const arg of args) {
            if (arg === null || arg === undefined) {
                /**
                 * Intentionally skip
                 */
            }
            else if (typeof arg === "string") {
                result.push(arg);
            }
            else {
                const writer = this.mapping.get(arg.constructor);
                if (writer === undefined) {
                    if (arg instanceof ast_node_1.ASTNode) {
                        throw new Error("Unable to find writer for AST arg: " + arg.print());
                    }
                    const data = JSON.stringify(arg, undefined, 4);
                    throw new Error("Expected an instance of ASTNode but got following: " + data);
                }
                result.push(...writer.writeWhole(arg, this));
            }
        }
        return result;
    }
    /**
     * Write out the given `node` to a string.
     *
     * If given a source map `sourceMap`, add a mapping from every child of `node`
     * to its corrseponding range in the resulting string in `sourceMap`.
     */
    write(node, sourceMap = new Map()) {
        const desc = this.desc(node);
        return this.descToSourceString(desc, sourceMap);
    }
}
exports.ASTWriter = ASTWriter;
//# sourceMappingURL=writer.js.map