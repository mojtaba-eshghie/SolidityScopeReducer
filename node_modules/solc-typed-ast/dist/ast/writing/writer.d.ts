import { ASTNode, ASTNodeConstructor } from "../ast_node";
import { YulNode } from "../implementation/statement/inline_assembly";
import { SourceFormatter } from "./formatter";
export interface YulNodeWriter {
    write(node: YulNode, writer: YulWriter): string;
}
export type SrcRangeMap = Map<ASTNode, [number, number]>;
export type DescArgs = Array<string | ASTNode | undefined | null>;
/**
 * The `SrcDesc` is the intermediate description for source that is generated by
 * `ASTNodeWriter`s. It has a tree-like structure, defined by the following grammar:
 *
 * ```
 * SrcDesc ::= (string | [ASTNode, SrcDesc])*
 * ```
 *
 * Essentially its a tree of strings, with some ASTNode attached to it at given locations.
 *
 * For example having `[ASTNode#5, <SrcDescX>]` in the tree, indicates that
 * the source generated by `<SrcDescX>` corresponds precisely to `ASTNode#5`
 * in the source map.
 */
export type SrcDesc = Array<string | [ASTNode, any[]]>;
/**
 * Base class for all `ASTNodeWriter`s.
 * Child classes are responsible for generating a `SrcDesc` for every node.
 */
export declare abstract class ASTNodeWriter {
    /**
     * Generate a `SrcDesc` for a given node,
     * but without adding the node itself to the tree.
     */
    abstract writeInner(node: ASTNode, writer: ASTWriter): SrcDesc;
    /**
     * Add the node to the descrioption generated by `writeInner`,
     * any additional "wrappings" and return it.
     * Usually `writeWhole` is responsible for adding semicolons and documentation,
     * since these are not generally part of source mappings.
     *
     * For example given this source:
     *
     * ```
     * a = 1;
     * ```
     *
     * `ExpressionStatement.writeInner` would return the following desc:
     *
     * ```
     * [[Assignment#3, [[Identifier#1, ["a"]], " = ", [Literal#2, ["1"]] ]]]
     * ```
     *
     * Then `ExpressionStatement.writeWhole` would add in
     * the `ExpressionStatement` node and the semicolon to return:
     *
     * ```
     * [[ExpressionStatement#4, [[Assignment#3, [[Identifier#1, ["a"]], " = ", [Literal#2, ["1"]] ]]]], ";"]
     * ```
     */
    writeWhole(node: ASTNode, writer: ASTWriter): SrcDesc;
}
export declare class YulWriter {
    mapping: Map<string, YulNodeWriter>;
    formatter: SourceFormatter;
    constructor(mapping: Map<string, YulNodeWriter>, formatter: SourceFormatter);
    write(node: YulNode): string;
}
export declare class ASTWriter {
    mapping: Map<ASTNodeConstructor<ASTNode>, ASTNodeWriter>;
    formatter: SourceFormatter;
    targetCompilerVersion: string;
    constructor(mapping: Map<ASTNodeConstructor<ASTNode>, ASTNodeWriter>, formatter: SourceFormatter, targetCompilerVersion: string);
    /**
     * Convert the source description `desc`
     * generated by the `ASTNodeWriter`s into a source string,
     * while also populating the given source map `sourceMap`.
     */
    descToSourceString(desc: SrcDesc, sourceMap: SrcRangeMap): string;
    /**
     * Generate `SrcDesc` for element of `DescArgs`.
     *
     * Used by `ASTNodeWriter`s to handle different nested nodes.
     */
    desc(...args: DescArgs): SrcDesc;
    /**
     * Write out the given `node` to a string.
     *
     * If given a source map `sourceMap`, add a mapping from every child of `node`
     * to its corrseponding range in the resulting string in `sourceMap`.
     */
    write(node: ASTNode, sourceMap?: SrcRangeMap): string;
}
//# sourceMappingURL=writer.d.ts.map