"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultASTWriterMapping = void 0;
const semver_1 = require("semver");
const constants_1 = require("../constants");
const declaration_1 = require("../implementation/declaration");
const expression_1 = require("../implementation/expression");
const meta_1 = require("../implementation/meta");
const statement_1 = require("../implementation/statement");
const type_1 = require("../implementation/type");
const writer_1 = require("./writer");
const yul_mapping_1 = require("./yul_mapping");
const RX_SPACE_OR_EMPTY = /^\s*$/;
function descTrimRight(desc) {
    while (desc.length > 0) {
        const last = desc[desc.length - 1];
        if (typeof last === "string") {
            if (RX_SPACE_OR_EMPTY.test(last)) {
                desc.pop();
                continue;
            }
        }
        else {
            descTrimRight(last[1]);
        }
        break;
    }
}
function hasSpdxLicence(desc) {
    const first = desc[0];
    if (typeof first === "string") {
        return first.includes("SPDX-License-Identifier");
    }
    return hasSpdxLicence(first[1]);
}
/**
 * A small hack to handle semicolons in the last statement of compound statements like if and while. Given:
 *
 * ```
 * if (cond) x++;
 * ```
 *
 * The last semicolon belongs to the SrcDesc of the true body of the if. This function would move it from that SrcDesc
 * to the end of the top-level SrcDesc of the if statement. This way we can more easily exclude semicolons from the src range of
 * compound statements like ifs.
 */
function pushSemicolonsDown(desc) {
    if (desc.length === 0) {
        return;
    }
    const last = desc[desc.length - 1];
    if (typeof last === "string") {
        return;
    }
    if (last[1].length === 0) {
        return;
    }
    const lastLast = last[1][last[1].length - 1];
    if (lastLast === ";") {
        last[1].pop();
        desc.push(";");
    }
}
function wrapCompoundStatement(node, desc) {
    const last = desc[desc.length - 1];
    if (last !== ";") {
        return [[node, desc]];
    }
    return [[node, desc.slice(0, -1)], ";"];
}
function join(arr, join) {
    const result = [];
    for (let i = 0; i < arr.length; i++) {
        result.push(arr[i]);
        if (i !== arr.length - 1) {
            result.push(join);
        }
    }
    return result;
}
function flatJoin(arr, join) {
    const result = [];
    for (let i = 0; i < arr.length; i++) {
        result.push(...arr[i]);
        if (i !== arr.length - 1) {
            result.push(join);
        }
    }
    return result;
}
function flatten(arr) {
    const result = [];
    for (let i = 0; i < arr.length; i++) {
        result.push(...arr[i]);
    }
    return result;
}
/**
 * Determine if a given unary/binary/conditional expression needs to be surrounded
 * by parenthesis to clarify order of evaluation.
 */
function needsParenthesis(e) {
    return (e.parent instanceof expression_1.UnaryOperation ||
        e.parent instanceof expression_1.BinaryOperation ||
        e.parent instanceof expression_1.Conditional);
}
function wrapWithParens(node, desc) {
    if (needsParenthesis(node)) {
        desc.unshift("(");
        desc.push(")");
    }
    return desc;
}
function writePrecedingDocs(documentation, writer) {
    if (documentation === undefined) {
        return [];
    }
    const indent = writer.formatter.renderIndent();
    if (documentation instanceof meta_1.StructuredDocumentation) {
        return writer.desc(documentation, "\n", indent);
    }
    return [StructuredDocumentationWriter.render(documentation, writer.formatter), "\n", indent];
}
class StructuredDocumentationWriter extends writer_1.ASTNodeWriter {
    static render(text, formatter) {
        const indent = formatter.renderIndent();
        const prefix = "/// ";
        const documentation = text.replace(/\n/g, (sub) => sub + indent + prefix);
        return prefix + documentation;
    }
    writeInner(node, writer) {
        return [StructuredDocumentationWriter.render(node.text, writer.formatter)];
    }
}
class ElementaryTypeNameWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        if ((0, semver_1.satisfies)(writer.targetCompilerVersion, "0.4")) {
            return [node.name];
        }
        if ((0, semver_1.gte)(writer.targetCompilerVersion, "0.6.0") &&
            node.name === "address" &&
            node.parent instanceof expression_1.ElementaryTypeNameExpression) {
            return [node.stateMutability === "payable" ? "payable" : "address"];
        }
        return [node.stateMutability === "payable" ? node.name + " payable" : node.name];
    }
}
class ArrayTypeNameWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        if (node.vLength) {
            return writer.desc(node.vBaseType, "[", node.vLength, "]");
        }
        return writer.desc(node.vBaseType, "[]");
    }
}
class MappingTypeNameWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        return writer.desc("mapping(", node.vKeyType, " => ", node.vValueType, ")");
    }
}
class UserDefinedTypeNameWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        if (node.path) {
            return writer.desc(node.path);
        }
        if (node.name === undefined) {
            throw new Error("Unable to detect name of user-defined type reference node: " + node.print());
        }
        return [node.name];
    }
}
class IdentifierPathWriter extends writer_1.ASTNodeWriter {
    writeInner(node) {
        return [node.name];
    }
}
class FunctionTypeNameWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        const elements = ["function", node.vParameterTypes, ` ${node.visibility}`];
        if (node.stateMutability !== constants_1.FunctionStateMutability.NonPayable) {
            elements.push(" " + node.stateMutability);
        }
        if (node.vReturnParameterTypes.vParameters.length) {
            elements.push(` returns `, node.vReturnParameterTypes);
        }
        return writer.desc(...elements);
    }
}
class LiteralWriter extends writer_1.ASTNodeWriter {
    writeInner(node) {
        if (node.kind === constants_1.LiteralKind.String) {
            return [
                node.value === null ? 'hex"' + node.hexValue + '"' : JSON.stringify(node.value)
            ];
        }
        if (node.kind === constants_1.LiteralKind.HexString) {
            return ['hex"' + node.hexValue + '"'];
        }
        if (node.kind === constants_1.LiteralKind.UnicodeString) {
            return ['unicode"' + node.value + '"'];
        }
        let result = node.value;
        if (node.subdenomination !== undefined) {
            result += " " + node.subdenomination;
        }
        return [result];
    }
}
class IdentifierWriter extends writer_1.ASTNodeWriter {
    writeInner(node) {
        return [node.name];
    }
}
class FunctionCallOptionsWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        const elements = [node.vExpression, "{"];
        elements.push(...flatJoin([...node.vOptionsMap.entries()].map(([name, value]) => [name, ": ", value]), ", "));
        elements.push("}");
        return writer.desc(...elements);
    }
}
class FunctionCallWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        const elements = [node.vExpression, "("];
        const fields = node.fieldNames;
        const args = node.vArguments;
        if (fields) {
            if (fields.length !== args.length) {
                throw new Error("Unexpected different length of field names and arguments in function call node: " +
                    node.print());
            }
            elements.push("{", ...flatJoin(fields.map((field, i) => [field, ": ", args[i]]), ", "), "}");
        }
        else {
            elements.push(...join(args, ", "));
        }
        elements.push(")");
        return writer.desc(...elements);
    }
}
class MemberAccessWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        return writer.desc(node.vExpression, `.${node.memberName}`);
    }
}
class IndexAccessWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        return writer.desc(node.vBaseExpression, "[", node.vIndexExpression, "]");
    }
}
class IndexRangeAccessWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        return writer.desc(node.vBaseExpression, "[", node.vStartExpression, ":", node.vEndExpression, "]");
    }
}
class UnaryOperationWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        if (node.operator === "delete") {
            return writer.desc("delete ", node.vSubExpression);
        }
        const elements = [node.vSubExpression];
        if (node.prefix) {
            elements.unshift(node.operator);
        }
        else {
            elements.push(node.operator);
        }
        return writer.desc(...elements);
    }
    writeWhole(node, writer) {
        const innerDesc = [[node, this.writeInner(node, writer)]];
        /**
         * Don't include the implicit parenthesis in the src range for the unary operation
         */
        return wrapWithParens(node, innerDesc);
    }
}
class BinaryOperationWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        const elements = [
            node.vLeftExpression,
            ` ${node.operator} `,
            node.vRightExpression
        ];
        return writer.desc(...elements);
    }
    writeWhole(node, writer) {
        const innerDesc = [[node, this.writeInner(node, writer)]];
        /**
         * Don't include the implicit parenthesis in the src range for the binary operation
         */
        return wrapWithParens(node, innerDesc);
    }
}
class ConditionalWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        const elements = [
            node.vCondition,
            " ? ",
            node.vTrueExpression,
            " : ",
            node.vFalseExpression
        ];
        return writer.desc(...elements);
    }
    writeWhole(node, writer) {
        const innerDesc = [[node, this.writeInner(node, writer)]];
        /**
         * Don't include the implicit parenthesis in the src range for the conditional
         */
        return wrapWithParens(node, innerDesc);
    }
}
class AssignmentWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        return writer.desc(node.vLeftHandSide, ` ${node.operator} `, node.vRightHandSide);
    }
}
class ElementaryTypeNameExpressionWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        return writer.desc(node.typeName);
    }
}
class NewExpressionWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        return writer.desc("new ", node.vTypeName);
    }
}
class TupleExpressionWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        if (node.isInlineArray) {
            return writer.desc("[", ...join(node.vOriginalComponents, ", "), "]");
        }
        return writer.desc("(", ...join(node.vOriginalComponents, ", "), ")");
    }
}
/**
 * For most statements we don't want to include the ";" in the
 * source map range.
 */
class SimpleStatementWriter extends writer_1.ASTNodeWriter {
    writeWhole(node, writer) {
        const stmtDesc = super.writeWhole(node, writer);
        stmtDesc.unshift(...writePrecedingDocs(node.documentation, writer));
        stmtDesc.push(";");
        return stmtDesc;
    }
}
class ExpressionStatementWriter extends SimpleStatementWriter {
    writeInner(node, writer) {
        return writer.desc(node.vExpression);
    }
    /**
     * For ExpressionStatements we want to omit the semicolon when
     * they are a part of vLoopExpression of a for statement.
     */
    writeWhole(node, writer) {
        const stmtDesc = [[node, this.writeInner(node, writer)]];
        stmtDesc.unshift(...writePrecedingDocs(node.documentation, writer));
        if (!(node.parent instanceof statement_1.ForStatement && node.parent.vLoopExpression === node)) {
            stmtDesc.push(";");
        }
        return stmtDesc;
    }
}
class VariableDeclarationStatementWriter extends SimpleStatementWriter {
    writeInner(node, writer) {
        const elements = this.getDeclarations(node);
        if (node.vInitialValue) {
            elements.push(" = ", node.vInitialValue);
        }
        return writer.desc(...elements);
    }
    getDeclarations(node) {
        const assignments = node.assignments;
        const children = node.children;
        if (assignments.length < 2 || assignments.every((id) => id === null)) {
            const declaration = node.vDeclarations[0];
            return declaration.vType === undefined ? ["var ", declaration] : [declaration];
        }
        const declarations = join(assignments.map((id) => {
            if (id === null) {
                return "";
            }
            const declaration = children.find((c) => c.id === id);
            if (!declaration) {
                throw new Error(`Unable to find assigned declaration ${id} in children of ${node.print()}`);
            }
            return declaration;
        }), ", ");
        const tuple = ["(", ...declarations, ")"];
        const isUntyped = node.vDeclarations.every((declaration) => declaration.vType === undefined);
        if (isUntyped) {
            tuple.unshift("var ");
        }
        return tuple;
    }
}
/**
 * Compound statemetns don't have their own semicolons. However if a
 * child has a semi-colon, we must make sure to exclude it from our source map.
 */
class CompoundStatementWriter extends SimpleStatementWriter {
    writeWhole(node, writer) {
        const stmtDesc = this.writeInner(node, writer);
        pushSemicolonsDown(stmtDesc);
        return writePrecedingDocs(node.documentation, writer).concat(wrapCompoundStatement(node, stmtDesc));
    }
}
class IfStatementWriter extends CompoundStatementWriter {
    writeInner(node, writer) {
        if (node.vFalseBody) {
            return writer.desc("if (", node.vCondition, ") ", node.vTrueBody, " else ", node.vFalseBody);
        }
        return writer.desc("if (", node.vCondition, ") ", node.vTrueBody);
    }
}
class ForStatementWriter extends CompoundStatementWriter {
    writeInner(node, writer) {
        return writer.desc("for (", ...(node.vInitializationExpression === undefined
            ? ["; "]
            : [node.vInitializationExpression, " "]), node.vCondition, "; ", node.vLoopExpression, ") ", node.vBody);
    }
}
class WhileStatementWriter extends CompoundStatementWriter {
    writeInner(node, writer) {
        return writer.desc("while (", node.vCondition, ") ", node.vBody);
    }
}
class DoWhileStatementWriter extends SimpleStatementWriter {
    writeInner(node, writer) {
        return writer.desc("do ", node.vBody, " while(", node.vCondition, ")");
    }
}
class ReturnWriter extends SimpleStatementWriter {
    writeInner(node, writer) {
        if (node.vExpression) {
            return writer.desc("return ", node.vExpression);
        }
        return ["return"];
    }
}
class RevertStatementWriter extends SimpleStatementWriter {
    writeInner(node, writer) {
        return writer.desc("revert ", node.errorCall);
    }
}
class BreakWriter extends SimpleStatementWriter {
    writeInner() {
        return ["break"];
    }
}
class ContinueWriter extends SimpleStatementWriter {
    writeInner() {
        return ["continue"];
    }
}
class ThrowWriter extends SimpleStatementWriter {
    writeInner() {
        return ["throw"];
    }
}
class EmitStatementWriter extends SimpleStatementWriter {
    writeInner(node, writer) {
        return writer.desc("emit ", node.vEventCall);
    }
}
class PlaceholderStatementWriter extends SimpleStatementWriter {
    writeInner() {
        return ["_"];
    }
}
class InlineAssemblyWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        const result = ["assembly "];
        if (node.flags !== undefined) {
            const quotedFlags = node.flags.map((flag) => `"${flag}"`);
            result.push("(", ...join(quotedFlags, ", "), ") ");
        }
        if (node.operations !== undefined) {
            result.push(node.operations);
        }
        else if (node.yul !== undefined) {
            const yulWriter = new writer_1.YulWriter(yul_mapping_1.DefaultYulWriterMapping, writer.formatter);
            result.push(yulWriter.write(node.yul));
        }
        else {
            throw new Error("Unable to detect Yul data in inline assembly node: " + node.print());
        }
        return result;
    }
    writeWhole(node, writer) {
        return [
            ...writePrecedingDocs(node.documentation, writer),
            [node, this.writeInner(node, writer)]
        ];
    }
}
class TryCatchClauseWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        // Success clause (always the first child of the try-catch after the call)
        if (node.previousSibling instanceof expression_1.FunctionCall) {
            if (node.vParameters === undefined || node.vParameters.vParameters.length === 0) {
                return writer.desc(node.vBlock);
            }
            return writer.desc("returns ", node.vParameters, " ", node.vBlock);
        }
        /**
         * Empty catch clause without parameters and error name
         */
        if (node.errorName === "" && node.vParameters === undefined) {
            return writer.desc("catch ", node.vBlock);
        }
        /**
         * Catch clause with error name and parameters
         */
        return writer.desc("catch ", node.errorName, node.vParameters, " ", node.vBlock);
    }
    writeWhole(node, writer) {
        return [
            ...writePrecedingDocs(node.documentation, writer),
            [node, this.writeInner(node, writer)]
        ];
    }
}
class TryStatementWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        return writer.desc("try ", node.vExternalCall, " ", ...join(node.vClauses, " "));
    }
    writeWhole(node, writer) {
        return [
            ...writePrecedingDocs(node.documentation, writer),
            [node, this.writeInner(node, writer)]
        ];
    }
}
class VariableDeclarationWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        if (node.vScope instanceof meta_1.SourceUnit) {
            return this.getUnitConstant(node, writer);
        }
        return node.stateVariable
            ? this.getStateVariable(node, writer)
            : this.getLocalVariable(node, writer);
    }
    writeWhole(node, writer) {
        return [
            ...writePrecedingDocs(node.documentation, writer),
            [node, this.writeInner(node, writer)]
        ];
    }
    getUnitConstant(node, writer) {
        if (!(node.vType && node.vValue && node.mutability === constants_1.Mutability.Constant)) {
            throw new Error("Malformed unit-level constant variable: " + node.print());
        }
        return writer.desc(node.vType, " ", node.mutability, " ", node.name, " = ", node.vValue);
    }
    getStateVariable(node, writer) {
        if (!node.vType) {
            throw new Error("Unexpected untyped state variable: " + node.print());
        }
        const elements = [node.vType];
        if (node.visibility !== constants_1.StateVariableVisibility.Default) {
            elements.push(" ", node.visibility);
        }
        if (node.mutability !== constants_1.Mutability.Mutable) {
            elements.push(" ", node.mutability);
        }
        if (node.vOverrideSpecifier) {
            elements.push(" ", node.vOverrideSpecifier);
        }
        elements.push(" ", node.name);
        if (node.vValue) {
            elements.push(" = ", node.vValue);
        }
        return writer.desc(...elements);
    }
    getLocalVariable(node, writer) {
        const elements = [];
        if (node.vType) {
            elements.push(node.vType);
        }
        if (node.storageLocation !== constants_1.DataLocation.Default) {
            elements.push(node.storageLocation);
        }
        if (node.indexed) {
            elements.push("indexed");
        }
        if (node.name !== "") {
            elements.push(node.name);
        }
        return writer.desc(...join(elements, " "));
    }
}
class ParameterListWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        return [
            "(",
            ...flatJoin(node.vParameters.map((vDecl) => writer.desc(vDecl)), ", "),
            ")"
        ];
    }
}
class BlockWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        if (node.children.length === 0 ||
            (node.children.length === 1 && node.documentation === node.firstChild)) {
            return ["{}"];
        }
        const formatter = writer.formatter;
        const wrap = formatter.renderWrap();
        const oldIndent = formatter.renderIndent();
        formatter.increaseNesting();
        const doc = node.documentation;
        const nested = node.children.filter((node) => node !== doc);
        const res = [
            "{",
            wrap,
            ...flatJoin(nested.map((stmt) => [formatter.renderIndent(), ...writer.desc(stmt)]), wrap),
            wrap,
            oldIndent,
            "}"
        ];
        formatter.decreaseNesting();
        return res;
    }
    writeWhole(node, writer) {
        return [
            ...writePrecedingDocs(node.documentation, writer),
            [node, this.writeInner(node, writer)]
        ];
    }
}
class UncheckedBlockWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        if (node.children.length === 0 ||
            (node.children.length === 1 && node.documentation === node.firstChild)) {
            return ["unchecked {}"];
        }
        const formatter = writer.formatter;
        const wrap = formatter.renderWrap();
        const oldIndent = formatter.renderIndent();
        formatter.increaseNesting();
        const doc = node.documentation;
        const nested = node.children.filter((node) => node !== doc);
        const res = [
            "unchecked {",
            wrap,
            ...flatJoin(nested.map((stmt) => [formatter.renderIndent(), ...writer.desc(stmt)]), wrap),
            wrap,
            oldIndent,
            "}"
        ];
        formatter.decreaseNesting();
        return res;
    }
    writeWhole(node, writer) {
        return [
            ...writePrecedingDocs(node.documentation, writer),
            [node, this.writeInner(node, writer)]
        ];
    }
}
class ErrorDefinitionWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        return writer.desc("error ", node.name, node.vParameters, ";");
    }
    writeWhole(node, writer) {
        return [
            ...writePrecedingDocs(node.documentation, writer),
            [node, this.writeInner(node, writer)]
        ];
    }
}
class EventDefinitionWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        return writer.desc("event ", node.name, node.vParameters, node.anonymous ? " anonymous" : "", ";");
    }
    writeWhole(node, writer) {
        return [
            ...writePrecedingDocs(node.documentation, writer),
            [node, this.writeInner(node, writer)]
        ];
    }
}
class StructDefinitionWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        return ["struct ", node.name, " ", ...this.getBody(node, writer)];
    }
    writeWhole(node, writer) {
        return [
            ...writePrecedingDocs(node.documentation, writer),
            [node, this.writeInner(node, writer)]
        ];
    }
    getBody(node, writer) {
        if (node.children.length === 0) {
            return ["{}"];
        }
        const formatter = writer.formatter;
        const wrap = formatter.renderWrap();
        formatter.increaseNesting();
        const result = [
            "{",
            wrap,
            ...flatJoin(node.vMembers.map((vDecl) => [
                formatter.renderIndent(),
                ...writer.desc(vDecl),
                ";"
            ]), wrap),
            wrap
        ];
        if (node.danglingDocumentation) {
            result.push(formatter.renderIndent(), ...writer.desc(node.danglingDocumentation), wrap);
        }
        formatter.decreaseNesting();
        result.push(formatter.renderIndent(), "}");
        return result;
    }
}
class ModifierDefinitionWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        const args = ["modifier ", node.name, node.vParameters];
        if ((0, semver_1.gte)(writer.targetCompilerVersion, "0.6.0")) {
            if (node.virtual) {
                args.push(" virtual");
            }
            if (node.vOverrideSpecifier) {
                args.push(" ", node.vOverrideSpecifier);
            }
        }
        if (node.vBody) {
            args.push(" ", node.vBody);
        }
        else {
            args.push(";");
        }
        return writer.desc(...args);
    }
    writeWhole(node, writer) {
        return [
            ...writePrecedingDocs(node.documentation, writer),
            [node, this.writeInner(node, writer)]
        ];
    }
}
class ModifierInvocationWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        return writer.desc(node.vModifierName, "(", ...join(node.vArguments, ","), ")");
    }
}
class OverrideSpecifierWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        if (node.vOverrides.length) {
            return writer.desc("override", "(", ...join(node.vOverrides, ", "), ")");
        }
        return ["override"];
    }
}
class FunctionDefinitionWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        const args = this.getHeader(node, writer);
        if (!node.vBody) {
            return writer.desc(...args, ";");
        }
        const result = writer.desc(...args);
        result.push(" ", ...writer.desc(node.vBody));
        return result;
    }
    writeWhole(node, writer) {
        return [
            ...writePrecedingDocs(node.documentation, writer),
            [node, this.writeInner(node, writer)]
        ];
    }
    getHeader(node, writer) {
        const isGte06 = (0, semver_1.gte)(writer.targetCompilerVersion, "0.6.0");
        const isGte07 = (0, semver_1.gte)(writer.targetCompilerVersion, "0.7.0");
        const isFileLevel = node.kind === constants_1.FunctionKind.Free;
        let name;
        if (isGte06) {
            name =
                node.kind === constants_1.FunctionKind.Function || isFileLevel
                    ? `function ${node.name}`
                    : node.kind;
        }
        else {
            name = node.isConstructor && node.name === "" ? "constructor" : `function ${node.name}`;
        }
        const result = [name, node.vParameters];
        if (isGte06) {
            if (node.virtual) {
                result.push(" virtual");
            }
            if (node.vOverrideSpecifier) {
                result.push(" ", node.vOverrideSpecifier);
            }
        }
        if (!((isGte07 && node.isConstructor) || isFileLevel)) {
            result.push(" ", node.visibility);
        }
        if (node.stateMutability !== constants_1.FunctionStateMutability.NonPayable) {
            result.push(" ", node.stateMutability);
        }
        if (node.vModifiers.length) {
            result.push(" ", ...join(node.vModifiers, " "));
        }
        if (node.vReturnParameters.vParameters.length) {
            result.push(" returns ", node.vReturnParameters);
        }
        return result;
    }
}
class UsingForDirectiveWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        const result = ["using "];
        if ((node.vLibraryName && node.vFunctionList) ||
            !(node.vLibraryName || node.vFunctionList)) {
            throw new Error("Malformed using-for directive: " + node.print());
        }
        if (node.vLibraryName) {
            result.push(node.vLibraryName);
        }
        else if (node.vFunctionList) {
            const entries = node.vFunctionList.map((entry) => entry instanceof meta_1.IdentifierPath
                ? [entry]
                : [entry.definition, " as ", entry.operator]);
            result.push("{ ", ...flatJoin(entries, ", "), " }");
        }
        result.push(" for ", node.vTypeName ? node.vTypeName : "*");
        if (node.isGlobal) {
            result.push(" global");
        }
        result.push(";");
        return writer.desc(...result);
    }
}
class EnumValueWriter extends writer_1.ASTNodeWriter {
    writeInner(node) {
        return [node.name];
    }
}
class EnumDefinitionWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        return ["enum ", node.name, " ", ...this.getBody(node, writer)];
    }
    writeWhole(node, writer) {
        return [
            ...writePrecedingDocs(node.documentation, writer),
            [node, this.writeInner(node, writer)]
        ];
    }
    getBody(node, writer) {
        if (node.children.length === 0) {
            return ["{}"];
        }
        const formatter = writer.formatter;
        const wrap = formatter.renderWrap();
        formatter.increaseNesting();
        const result = [
            "{",
            wrap,
            ...flatJoin(node.vMembers.map((vDecl) => [formatter.renderIndent(), ...writer.desc(vDecl)]), "," + wrap),
            wrap
        ];
        if (node.danglingDocumentation) {
            result.push(formatter.renderIndent(), ...writer.desc(node.danglingDocumentation), wrap);
        }
        formatter.decreaseNesting();
        result.push(formatter.renderIndent(), "}");
        return result;
    }
}
class UserDefinedValueTypeDefinitionWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        return writer.desc("type ", node.name, " is ", node.underlyingType, ";");
    }
}
class InheritanceSpecifierWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        const args = [node.vBaseType];
        if (node.vArguments.length) {
            args.push("(", ...join(node.vArguments, ", "), ")");
        }
        return writer.desc(...args);
    }
}
class ContractDefinitionWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        const headerArgs = this.getHeader(node, writer);
        const headerDesc = writer.desc(...headerArgs);
        const bodyDesc = this.getBody(node, writer);
        const res = [...headerDesc, " ", ...bodyDesc];
        descTrimRight(res);
        return res;
    }
    writeWhole(node, writer) {
        return [
            ...writePrecedingDocs(node.documentation, writer),
            [node, this.writeInner(node, writer)]
        ];
    }
    getHeader(node, writer) {
        const result = [];
        if ((0, semver_1.gte)(writer.targetCompilerVersion, "0.6.0") && node.abstract) {
            result.push("abstract ");
        }
        result.push(node.kind, " ", node.name);
        if (node.vInheritanceSpecifiers.length) {
            result.push(" is ", ...join(node.vInheritanceSpecifiers, ", "));
        }
        return result;
    }
    getBody(node, writer) {
        const formatter = writer.formatter;
        const wrap = formatter.renderWrap();
        const writeFn = (n) => [formatter.renderIndent(), n];
        const writeLineFn = (n) => [formatter.renderIndent(), n, wrap];
        const result = [];
        const oldIndent = formatter.renderIndent();
        formatter.increaseNesting();
        if (node.vUsingForDirectives.length) {
            result.push(...flatten(node.vUsingForDirectives.map(writeLineFn)), wrap);
        }
        if (node.vEnums.length) {
            result.push(...flatJoin(node.vEnums.map(writeLineFn), wrap), wrap);
        }
        if (node.vUserDefinedValueTypes.length) {
            result.push(...flatJoin(node.vUserDefinedValueTypes.map(writeLineFn), wrap), wrap);
        }
        if (node.vErrors.length) {
            result.push(...flatJoin(node.vErrors.map(writeLineFn), wrap), wrap);
        }
        if (node.vEvents.length) {
            result.push(...flatJoin(node.vEvents.map(writeLineFn), wrap), wrap);
        }
        if (node.vStructs.length) {
            result.push(...flatJoin(node.vStructs.map(writeLineFn), wrap), wrap);
        }
        if (node.vStateVariables.length) {
            result.push(...flatten(node.vStateVariables.map((n) => [...writeFn(n), ";", wrap])), wrap);
        }
        if (node.vModifiers.length) {
            result.push(...flatJoin(node.vModifiers.map(writeLineFn), wrap), wrap);
        }
        if (node.vFunctions.length) {
            result.push(...flatJoin(node.vFunctions.map(writeLineFn), wrap));
        }
        if (node.danglingDocumentation) {
            result.push(...writeFn(node.danglingDocumentation));
        }
        if (result.length) {
            const bodyDesc = writer.desc(...result);
            descTrimRight(bodyDesc);
            formatter.decreaseNesting();
            return ["{", wrap, ...bodyDesc, wrap, oldIndent, "}"];
        }
        formatter.decreaseNesting();
        return ["{}"];
    }
}
class ImportDirectiveWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        if (node.unitAlias) {
            return [`import "${node.file}" as ${node.unitAlias};`];
        }
        if (node.vSymbolAliases.length) {
            const entries = [];
            for (let i = 0; i < node.vSymbolAliases.length; i++) {
                const rawSymAlias = node.symbolAliases[i];
                const [origin, alias] = node.vSymbolAliases[i];
                if (rawSymAlias.foreign instanceof expression_1.Identifier) {
                    const desc = writer.desc(rawSymAlias.foreign);
                    if (alias) {
                        desc.push(` as ${alias}`);
                    }
                    entries.push(desc);
                }
                else {
                    const symbol = origin instanceof meta_1.ImportDirective ? origin.unitAlias : origin.name;
                    entries.push([alias !== undefined ? symbol + " as " + alias : symbol]);
                }
            }
            return [`import { `, ...flatJoin(entries, ", "), ` } from "${node.file}";`];
        }
        return [`import "${node.file}";`];
    }
}
class PragmaDirectiveWriter extends writer_1.ASTNodeWriter {
    writeInner(node) {
        return [`pragma ${node.vIdentifier} ${node.vValue};`];
    }
}
class SourceUnitWriter extends writer_1.ASTNodeWriter {
    writeInner(node, writer) {
        const wrap = writer.formatter.renderWrap();
        const writeFn = (n) => writer.desc(n);
        const writeLineFn = (n) => writer.desc(n, wrap);
        const result = [];
        if (node.vPragmaDirectives.length > 0) {
            result.push(...flatten(node.vPragmaDirectives.map(writeLineFn)), wrap);
        }
        if (node.vImportDirectives.length > 0) {
            result.push(...flatten(node.vImportDirectives.map(writeLineFn)), wrap);
        }
        const typeDefs = [...node.vEnums, ...node.vUserDefinedValueTypes, ...node.vStructs];
        if (typeDefs.length > 0) {
            result.push(...flatJoin(typeDefs.map(writeLineFn), wrap), wrap);
        }
        if (node.vUsingForDirectives.length > 0) {
            result.push(...flatten(node.vUsingForDirectives.map(writeLineFn)), wrap);
        }
        if (node.vVariables.length > 0) {
            result.push(...flatten(node.vVariables.map((n) => [...writeFn(n), ";", wrap])), wrap);
        }
        const otherDefs = [
            ...node.vErrors,
            ...node.vEvents,
            ...node.vFunctions,
            ...node.vContracts
        ];
        if (otherDefs.length > 0) {
            result.push(...flatJoin(otherDefs.map(writeLineFn), wrap));
        }
        descTrimRight(result);
        if (node.license && !hasSpdxLicence(result)) {
            result.unshift(StructuredDocumentationWriter.render("SPDX-License-Identifier: " + node.license, writer.formatter), wrap);
        }
        return result;
    }
}
exports.DefaultASTWriterMapping = new Map([
    [type_1.ElementaryTypeName, new ElementaryTypeNameWriter()],
    [type_1.ArrayTypeName, new ArrayTypeNameWriter()],
    [type_1.Mapping, new MappingTypeNameWriter()],
    [type_1.UserDefinedTypeName, new UserDefinedTypeNameWriter()],
    [type_1.FunctionTypeName, new FunctionTypeNameWriter()],
    [expression_1.Literal, new LiteralWriter()],
    [expression_1.Identifier, new IdentifierWriter()],
    [meta_1.IdentifierPath, new IdentifierPathWriter()],
    [expression_1.FunctionCallOptions, new FunctionCallOptionsWriter()],
    [expression_1.FunctionCall, new FunctionCallWriter()],
    [expression_1.MemberAccess, new MemberAccessWriter()],
    [expression_1.IndexAccess, new IndexAccessWriter()],
    [expression_1.IndexRangeAccess, new IndexRangeAccessWriter()],
    [expression_1.UnaryOperation, new UnaryOperationWriter()],
    [expression_1.BinaryOperation, new BinaryOperationWriter()],
    [expression_1.Conditional, new ConditionalWriter()],
    [expression_1.ElementaryTypeNameExpression, new ElementaryTypeNameExpressionWriter()],
    [expression_1.NewExpression, new NewExpressionWriter()],
    [expression_1.TupleExpression, new TupleExpressionWriter()],
    [statement_1.ExpressionStatement, new ExpressionStatementWriter()],
    [expression_1.Assignment, new AssignmentWriter()],
    [declaration_1.VariableDeclaration, new VariableDeclarationWriter()],
    [statement_1.Block, new BlockWriter()],
    [statement_1.UncheckedBlock, new UncheckedBlockWriter()],
    [statement_1.VariableDeclarationStatement, new VariableDeclarationStatementWriter()],
    [statement_1.IfStatement, new IfStatementWriter()],
    [statement_1.ForStatement, new ForStatementWriter()],
    [statement_1.WhileStatement, new WhileStatementWriter()],
    [statement_1.DoWhileStatement, new DoWhileStatementWriter()],
    [statement_1.Return, new ReturnWriter()],
    [statement_1.EmitStatement, new EmitStatementWriter()],
    [statement_1.RevertStatement, new RevertStatementWriter()],
    [statement_1.PlaceholderStatement, new PlaceholderStatementWriter()],
    [statement_1.InlineAssembly, new InlineAssemblyWriter()],
    [statement_1.TryCatchClause, new TryCatchClauseWriter()],
    [statement_1.TryStatement, new TryStatementWriter()],
    [statement_1.Break, new BreakWriter()],
    [statement_1.Continue, new ContinueWriter()],
    [statement_1.Throw, new ThrowWriter()],
    [meta_1.ParameterList, new ParameterListWriter()],
    [meta_1.ModifierInvocation, new ModifierInvocationWriter()],
    [meta_1.OverrideSpecifier, new OverrideSpecifierWriter()],
    [declaration_1.FunctionDefinition, new FunctionDefinitionWriter()],
    [declaration_1.ModifierDefinition, new ModifierDefinitionWriter()],
    [declaration_1.ErrorDefinition, new ErrorDefinitionWriter()],
    [declaration_1.EventDefinition, new EventDefinitionWriter()],
    [declaration_1.StructDefinition, new StructDefinitionWriter()],
    [declaration_1.EnumValue, new EnumValueWriter()],
    [declaration_1.EnumDefinition, new EnumDefinitionWriter()],
    [declaration_1.UserDefinedValueTypeDefinition, new UserDefinedValueTypeDefinitionWriter()],
    [meta_1.UsingForDirective, new UsingForDirectiveWriter()],
    [meta_1.InheritanceSpecifier, new InheritanceSpecifierWriter()],
    [declaration_1.ContractDefinition, new ContractDefinitionWriter()],
    [meta_1.StructuredDocumentation, new StructuredDocumentationWriter()],
    [meta_1.ImportDirective, new ImportDirectiveWriter()],
    [meta_1.PragmaDirective, new PragmaDirectiveWriter()],
    [meta_1.SourceUnit, new SourceUnitWriter()]
]);
//# sourceMappingURL=ast_mapping.js.map