"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultYulWriterMapping = void 0;
class YulBlockWriter {
    write(node, writer) {
        if (node.statements.length === 0) {
            return "{}";
        }
        const formatter = writer.formatter;
        formatter.increaseNesting();
        const statements = node.statements.map((stmt) => formatter.renderIndent() + writer.write(stmt));
        formatter.decreaseNesting();
        const wrap = formatter.renderWrap();
        const indent = formatter.renderIndent();
        return "{" + wrap + statements.join(wrap) + wrap + indent + "}";
    }
}
class YulLiteralWriter {
    write(node) {
        let result;
        if (node.kind === "string") {
            if ("value" in node) {
                result = JSON.stringify(node.value);
            }
            else if ("hexValue" in node) {
                result = `hex"${node.hexValue}"`;
            }
            else {
                throw new Error("Unable to pick string YulLiteral value: " + JSON.stringify(node));
            }
        }
        else {
            result = node.value;
        }
        return node.type !== "" ? result + ":" + node.type : result;
    }
}
class YulIdentifierWriter {
    write(node) {
        return node.name;
    }
}
class YulTypedNameWriter {
    write(node) {
        return node.type !== "" ? node.name + ":" + node.type : node.name;
    }
}
class YulFunctionCallWriter {
    write(node, writer) {
        const id = writer.write(node.functionName);
        const args = node.arguments.map((arg) => writer.write(arg));
        return id + "(" + args.join(", ") + ")";
    }
}
class YulVariableDeclarationWriter {
    write(node, writer) {
        const vars = node.variables.map((v) => writer.write(v));
        const rhs = node.value === null ? undefined : writer.write(node.value);
        const lhs = "let " + vars.join(", ");
        return rhs !== undefined ? lhs + " := " + rhs : lhs;
    }
}
class YulExpressionStatementWriter {
    write(node, writer) {
        return writer.write(node.expression);
    }
}
class YulAssignmentWriter {
    write(node, writer) {
        const lhs = node.variableNames.map((v) => writer.write(v));
        const rhs = writer.write(node.value);
        return lhs.join(", ") + " := " + rhs;
    }
}
class YulIfWriter {
    write(node, writer) {
        const condition = writer.write(node.condition);
        const body = writer.write(node.body);
        return "if " + condition + " " + body;
    }
}
class YulCaseWriter {
    write(node, writer) {
        const body = writer.write(node.body);
        if (node.value === "default") {
            return "default " + body;
        }
        const value = writer.write(node.value);
        return "case " + value + " " + body;
    }
}
class YulSwitchWriter {
    write(node, writer) {
        const expression = writer.write(node.expression);
        const formatter = writer.formatter;
        const cases = node.cases.map((clause) => formatter.renderIndent() + writer.write(clause));
        const wrap = formatter.renderWrap();
        return "switch " + expression + wrap + cases.join(wrap);
    }
}
class YulContinueWriter {
    write() {
        return "continue";
    }
}
class YulBreakWriter {
    write() {
        return "break";
    }
}
class YulLeaveWriter {
    write() {
        return "leave";
    }
}
class YulForLoopWriter {
    write(node, writer) {
        const pre = writer.write(node.pre);
        const condition = writer.write(node.condition);
        const post = writer.write(node.post);
        const body = writer.write(node.body);
        return `for ${pre} ${condition} ${post} ${body}`;
    }
}
class YulFunctionDefinitionWriter {
    write(node, writer) {
        const args = node.parameters
            ? node.parameters.map((arg) => writer.write(arg))
            : undefined;
        const rets = node.returnVariables
            ? node.returnVariables.map((v) => writer.write(v))
            : undefined;
        const body = writer.write(node.body);
        const definition = ["function", node.name];
        definition.push(args ? "(" + args.join(", ") + ")" : "()");
        if (rets) {
            definition.push("-> " + rets.join(", "));
        }
        definition.push(body);
        return definition.join(" ");
    }
}
exports.DefaultYulWriterMapping = new Map([
    ["YulBlock", new YulBlockWriter()],
    ["YulLiteral", new YulLiteralWriter()],
    ["YulIdentifier", new YulIdentifierWriter()],
    ["YulTypedName", new YulTypedNameWriter()],
    ["YulFunctionCall", new YulFunctionCallWriter()],
    ["YulVariableDeclaration", new YulVariableDeclarationWriter()],
    ["YulExpressionStatement", new YulExpressionStatementWriter()],
    ["YulAssignment", new YulAssignmentWriter()],
    ["YulIf", new YulIfWriter()],
    ["YulCase", new YulCaseWriter()],
    ["YulSwitch", new YulSwitchWriter()],
    ["YulContinue", new YulContinueWriter()],
    ["YulBreak", new YulBreakWriter()],
    ["YulLeave", new YulLeaveWriter()],
    ["YulForLoop", new YulForLoopWriter()],
    ["YulFunctionDefinition", new YulFunctionDefinitionWriter()]
]);
//# sourceMappingURL=yul_mapping.js.map