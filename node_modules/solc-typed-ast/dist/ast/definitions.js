"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveAny = void 0;
const semver_1 = require("semver");
const _1 = require(".");
const misc_1 = require("../misc");
const constants_1 = require("./constants");
const contract_definition_1 = require("./implementation/declaration/contract_definition");
const enum_definition_1 = require("./implementation/declaration/enum_definition");
const error_definition_1 = require("./implementation/declaration/error_definition");
const event_definition_1 = require("./implementation/declaration/event_definition");
const function_definition_1 = require("./implementation/declaration/function_definition");
const modifier_definition_1 = require("./implementation/declaration/modifier_definition");
const struct_definition_1 = require("./implementation/declaration/struct_definition");
const user_defined_value_type_definition_1 = require("./implementation/declaration/user_defined_value_type_definition");
const variable_declaration_1 = require("./implementation/declaration/variable_declaration");
const meta_1 = require("./implementation/meta");
const statement_1 = require("./implementation/statement");
/**
 * Given an ASTNode `node` and a compiler version `version` determine if `node` is a
 * scope node. Note that `Block` is only a scope in 0.4.x
 */
function isScope(node, version) {
    if ((0, semver_1.lt)(version, "0.5.0") && node instanceof statement_1.Block) {
        return true;
    }
    return (node instanceof meta_1.SourceUnit ||
        node instanceof contract_definition_1.ContractDefinition ||
        node instanceof function_definition_1.FunctionDefinition ||
        node instanceof modifier_definition_1.ModifierDefinition ||
        node instanceof statement_1.VariableDeclarationStatement ||
        node instanceof statement_1.TryCatchClause);
}
/**
 * Given any `ASTNode` `node` and a compiler verison `version` return the `ScopeNode` containing `node`, or undefined
 * if `node` is a top-level scope. (i.e. a `SourceUnit`)
 */
function getContainingScope(node, version) {
    if (node instanceof meta_1.SourceUnit) {
        return undefined;
    }
    let pt = node.parent;
    while (pt !== undefined &&
        !(pt instanceof meta_1.SourceUnit ||
            pt instanceof contract_definition_1.ContractDefinition ||
            pt instanceof function_definition_1.FunctionDefinition ||
            pt instanceof modifier_definition_1.ModifierDefinition ||
            pt instanceof statement_1.Block ||
            pt instanceof statement_1.UncheckedBlock ||
            pt instanceof statement_1.ForStatement ||
            pt instanceof statement_1.TryCatchClause)) {
        node = pt;
        pt = pt.parent;
    }
    if (pt === undefined) {
        return undefined;
    }
    if (pt instanceof statement_1.ForStatement) {
        if (node !== pt.vInitializationExpression &&
            pt.vInitializationExpression instanceof statement_1.VariableDeclarationStatement) {
            return pt.vInitializationExpression;
        }
        return getContainingScope(pt, version);
    }
    if (pt instanceof statement_1.Block || pt instanceof statement_1.UncheckedBlock) {
        if ((0, semver_1.gte)(version, "0.5.0")) {
            const ptChildren = pt.children;
            for (let i = ptChildren.indexOf(node) - 1; i >= 0; i--) {
                const sibling = ptChildren[i];
                if (sibling instanceof statement_1.VariableDeclarationStatement) {
                    return sibling;
                }
            }
            // Note that in >=0.5.0 Block/UncheckedBlock IS NOT a scope. VariableDeclarationStatement IS.
            return getContainingScope(pt, version);
        }
    }
    return pt;
}
/**
 * Lookup the definition corresponding to `name` in the `SourceUnit` `scope`. Yield all matches.
 */
function* lookupInSourceUnit(name, inference, scope, visitedUnits) {
    /**
     * Hit a cycle during lookup due to recursive imports
     */
    if (visitedUnits.has(scope)) {
        return [];
    }
    visitedUnits.add(scope);
    // Note order of checking SourceUnit children doesn't matter
    // since any conflict would result in a compilation error.
    for (const child of scope.children) {
        if ((child instanceof variable_declaration_1.VariableDeclaration ||
            child instanceof function_definition_1.FunctionDefinition ||
            child instanceof contract_definition_1.ContractDefinition ||
            child instanceof struct_definition_1.StructDefinition ||
            child instanceof enum_definition_1.EnumDefinition ||
            child instanceof event_definition_1.EventDefinition ||
            child instanceof error_definition_1.ErrorDefinition ||
            child instanceof user_defined_value_type_definition_1.UserDefinedValueTypeDefinition) &&
            child.name === name) {
            yield child;
        }
        if (child instanceof meta_1.ImportDirective) {
            if (child.unitAlias === name) {
                // `import "..." as <name>`
                yield child;
            }
            else if (child.vSymbolAliases.length === 0) {
                // import "..."
                // @todo maybe its better to go through child.vSourceUnit.vExportedSymbols here?
                yield* lookupInScope(name, child.vSourceUnit, inference, visitedUnits, false);
            }
            else {
                // `import {<name>} from "..."` or `import {a as <name>} from "..."`
                for (const [foreignDef, alias] of child.vSymbolAliases) {
                    let symImportName;
                    if (alias !== undefined) {
                        symImportName = alias;
                    }
                    else {
                        if (foreignDef instanceof meta_1.ImportDirective) {
                            symImportName = foreignDef.unitAlias;
                            (0, misc_1.assert)(symImportName !== "", "Unexpected ImportDirective foreign def with non-unit alias {0}", foreignDef);
                        }
                        else {
                            symImportName = foreignDef.name;
                        }
                    }
                    if (symImportName === name) {
                        yield foreignDef;
                    }
                }
            }
        }
    }
}
/**
 * Lookup the definition corresponding to `name` in the `ContractDefinition` `scope`. Yield all matches.
 */
function* lookupInContractDefinition(name, inference, scope, ignoreVisiblity) {
    const overridenSigHashes = new Set();
    for (const base of scope.vLinearizedBaseContracts) {
        for (const child of base.children) {
            if ((child instanceof variable_declaration_1.VariableDeclaration ||
                child instanceof function_definition_1.FunctionDefinition ||
                child instanceof modifier_definition_1.ModifierDefinition ||
                child instanceof event_definition_1.EventDefinition ||
                child instanceof struct_definition_1.StructDefinition ||
                child instanceof enum_definition_1.EnumDefinition ||
                child instanceof error_definition_1.ErrorDefinition ||
                child instanceof user_defined_value_type_definition_1.UserDefinedValueTypeDefinition) &&
                child.name === name) {
                // If we are not ignoring visibility, and the node is a private function or state var
                // in a base class different from scope, then ignore it
                if (!ignoreVisiblity &&
                    ((child instanceof variable_declaration_1.VariableDeclaration &&
                        child.visibility === constants_1.StateVariableVisibility.Private) ||
                        (child instanceof function_definition_1.FunctionDefinition &&
                            child.visibility === _1.FunctionVisibility.Private)) &&
                    base !== scope) {
                    continue;
                }
                const sigHash = child instanceof function_definition_1.FunctionDefinition ||
                    child instanceof event_definition_1.EventDefinition ||
                    (child instanceof variable_declaration_1.VariableDeclaration &&
                        child.visibility === constants_1.StateVariableVisibility.Public)
                    ? inference.signatureHash(child)
                    : undefined;
                if (sigHash !== undefined) {
                    if (overridenSigHashes.has(sigHash)) {
                        continue;
                    }
                    overridenSigHashes.add(sigHash);
                }
                yield child;
            }
        }
    }
}
/**
 * Lookup the definition corresponding to `name` in the `FunctionDefinition` `scope`. Yield all matches.
 */
function* lookupInFunctionDefinition(name, scope) {
    for (const paramList of [scope.vParameters, scope.vReturnParameters]) {
        for (const parameter of paramList.vParameters) {
            if (parameter.name === name) {
                yield parameter;
            }
        }
    }
}
/**
 * Lookup the definition corresponding to `name` in the `Block|UncheckedBlock` `scope`. Yield all matches.
 */
function* lookupInBlock(name, scope, inference) {
    let declarations;
    if ((0, semver_1.lt)(inference.version, "0.5.0")) {
        declarations = scope.getChildrenByType(variable_declaration_1.VariableDeclaration);
    }
    else {
        declarations = scope.children
            .filter((node) => node instanceof statement_1.VariableDeclarationStatement)
            .reduce((declarations, statement) => [
            ...declarations,
            ...statement.vDeclarations
        ], []);
    }
    for (const declaration of declarations) {
        if (declaration.name === name) {
            yield declaration;
        }
    }
}
/**
 * Lookup the definition corresponding to `name` in the `ScopeNode` `node`. If no match is found return an empty set.
 * Otherwise return the set of all definitions matching by name in this scope. This function may return multuple results only in the following cases:
 * 1. Multiple FunctionDefinitions (and potentially VariableDeclarations corresponding to public state variables) with the same name and DIFFERENT SIGNATURES
 * 2. Multiple EventDefinitions with the same name and different signatures.
 */
function lookupInScope(name, scope, inference, visitedUnits = new Set(), ignoreVisiblity) {
    let results;
    if (scope instanceof meta_1.SourceUnit) {
        results = lookupInSourceUnit(name, inference, scope, visitedUnits);
    }
    else if (scope instanceof contract_definition_1.ContractDefinition) {
        results = lookupInContractDefinition(name, inference, scope, ignoreVisiblity);
    }
    else if (scope instanceof function_definition_1.FunctionDefinition) {
        results = lookupInFunctionDefinition(name, scope);
    }
    else if (scope instanceof modifier_definition_1.ModifierDefinition) {
        results = scope.vParameters.vParameters.filter((parameter) => parameter.name === name);
    }
    else if (scope instanceof statement_1.VariableDeclarationStatement) {
        results = scope.vDeclarations.filter((decl) => decl.name === name);
    }
    else if (scope instanceof statement_1.Block || scope instanceof statement_1.UncheckedBlock) {
        results = lookupInBlock(name, scope, inference);
    }
    else if (scope instanceof statement_1.TryCatchClause) {
        results = scope.vParameters
            ? scope.vParameters.vParameters.filter((param) => param.name === name)
            : [];
    }
    else {
        throw new Error(`Unknown scope node ${(0, misc_1.pp)(scope)}`);
    }
    return new Set(results);
}
/**
 * Resolve the name `name` in the scope containing `ctx`, assuming compiler
 * version `version`. If `inclusive` is true, then if `ctx` itself is a scope,
 * lookup inside of it as well. (e.g. if ctx is the `ContractDefinition`
 * corresponding to `contract { uint x; }`, calling `resolveAny("x", node,
 * "0.5.0", true)` would return the state var X, and `resolveAny("x", node,
 * "0.5.0", false)` would return undefined.).
 *
 * Note that `name` can be an identifier path (e.g `A.B.C`).
 *
 * We return a set, since in the case where `name` resolves to a callable
 * (function/public state var) or event, there could be multiple
 * functions/events with the same name but different arguments. In all other
 * cases the returned set should have either 0 or 1 elements.
 */
function resolveAny(name, ctx, inference, inclusive = false, ignoreVisiblity = false) {
    let scope = inclusive && isScope(ctx, inference.version)
        ? ctx
        : getContainingScope(ctx, inference.version);
    const elements = name.split(".");
    for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        let res;
        if (i == 0) {
            // If this is the first element (e.g. `A` in `A.B.C`), walk up the
            // stack of scopes starting from the current context, looking for `A`
            while (scope !== undefined) {
                res = lookupInScope(element, scope, inference, undefined, ignoreVisiblity);
                if (res.size > 0) {
                    // Sanity check - when multiple results are found, they must either be overloaded events
                    // or overloaded functions/public state vars.
                    if (res.size > 1) {
                        (0, misc_1.assert)((0, misc_1.forAll)(res, (def) => def instanceof event_definition_1.EventDefinition ||
                            def instanceof function_definition_1.FunctionDefinition ||
                            (def instanceof variable_declaration_1.VariableDeclaration &&
                                def.stateVariable &&
                                def.visibility === constants_1.StateVariableVisibility.Public)), "Unexpected intermediate def for {0} in {1}: {2}", element, name, res);
                    }
                    const first = [...res][0];
                    // If we are resolving `A` in `A.B` skip anything that is
                    // not a contract/source unit. (e.g. constructor name in
                    // 0.4.x)
                    if (elements.length == 1 ||
                        first instanceof contract_definition_1.ContractDefinition ||
                        first instanceof meta_1.SourceUnit) {
                        break;
                    }
                }
                scope = getContainingScope(scope, inference.version);
            }
        }
        else {
            // If this is a later segment (e.g. `B` or `C` in `A.B.C`),
            // then resolve it recursively in the current scope.
            res = resolveAny(element, scope, inference, true, ignoreVisiblity);
        }
        // We didn't find anything - return empty set
        if (res === undefined || res.size === 0) {
            return new Set();
        }
        // This is the final segment of `A.B.C` - just return it.
        if (i >= elements.length - 1) {
            return res;
        }
        // We found multiple definitions for an intermediate segment of
        // identifier path (e.g. multiple resolutions for `A` in `A.B`). This
        // shouldn't happen.
        (0, misc_1.assert)(res.size === 1, "Ambigious path resolution for {0} in {1} in ctx {2}: got {3}", element, name, ctx, res);
        const resolvedNode = [...res][0];
        // An intermediate segment in an identifier path (e.g. `A` in `A.B`) should always resolve to a
        // single imported source unit or contract.
        (0, misc_1.assert)(resolvedNode instanceof meta_1.ImportDirective || resolvedNode instanceof contract_definition_1.ContractDefinition, "Unexpected non-scope node for {0} in {1} in ctx {2}: got {3}", element, name, ctx, resolvedNode);
        scope = resolvedNode instanceof meta_1.ImportDirective ? resolvedNode.vSourceUnit : resolvedNode;
    }
    return new Set();
}
exports.resolveAny = resolveAny;
//# sourceMappingURL=definitions.js.map