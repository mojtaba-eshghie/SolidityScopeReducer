"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructuredDocumentationReconstructingPostprocessor = exports.StructuredDocumentationReconstructor = void 0;
const misc_1 = require("../../misc");
const comments_1 = require("../comments");
const constants_1 = require("../constants");
const declaration_1 = require("../implementation/declaration");
const source_unit_1 = require("../implementation/meta/source_unit");
const structured_documentation_1 = require("../implementation/meta/structured_documentation");
const statement_1 = require("../implementation/statement/statement");
class StructuredDocumentationReconstructor {
    /**
     * Extracts fragment at provided source location,
     * then tries to find documentation and construct dummy `StructuredDocumentation`.
     * Returns produced `StructuredDocumentation` on success or `undefined`
     * if documentation was not detected in extracted fragment.
     */
    fragmentCoordsToStructDoc(coords, source) {
        const [from, to, sourceIndex] = coords;
        const fragment = (0, misc_1.bytesToString)(source.slice(from, to));
        const parsedCommentsSoup = (0, comments_1.parseComments)(fragment);
        // The parser gives us a soup of "strings" (corresponding to non-comment
        // tokens) and comments.
        // Find the suffix of the parse output that contains only comments
        let commentsStartIdx = parsedCommentsSoup.length - 1;
        for (; commentsStartIdx >= 0; commentsStartIdx--) {
            if (!(parsedCommentsSoup[commentsStartIdx] instanceof comments_1.RawComment)) {
                commentsStartIdx++;
                break;
            }
        }
        const parsedComments = parsedCommentsSoup.slice(commentsStartIdx, parsedCommentsSoup.length);
        // No comments found in the game
        if (parsedComments.length === 0) {
            return undefined;
        }
        const lastComment = parsedComments[parsedComments.length - 1];
        // The last comment in the gap is not a docstring
        if (lastComment.kind !== constants_1.RawCommentKind.BlockNatSpec &&
            lastComment.kind !== constants_1.RawCommentKind.LineGroupNatSpec) {
            return undefined;
        }
        const byteOffsetFromFragment = (0, misc_1.strUTF8Len)(fragment.slice(0, lastComment.loc.start));
        const offset = from + byteOffsetFromFragment;
        const length = (0, misc_1.strUTF8Len)(lastComment.text);
        const src = `${offset}:${length}:${sourceIndex}`;
        return new structured_documentation_1.StructuredDocumentation(0, src, lastComment.internalText.trim());
    }
    getPrecedingGapCoordinates(node) {
        const curInfo = node.sourceInfo;
        const to = curInfo.offset;
        const sourceIndex = curInfo.sourceIndex;
        const prev = node.previousSibling;
        let from;
        if (prev === undefined) {
            const parent = node.parent;
            if (parent === undefined || parent instanceof source_unit_1.SourceUnit) {
                from = 0;
            }
            else {
                const parentInfo = parent.sourceInfo;
                from = parentInfo.offset;
            }
        }
        else {
            const prevInfo = prev.sourceInfo;
            from = prevInfo.offset + prevInfo.length;
        }
        return [from, to, sourceIndex];
    }
    getDanglingGapCoordinates(node) {
        const curInfo = node.sourceInfo;
        // Skip final }
        const to = curInfo.offset + curInfo.length - 1;
        const sourceIndex = curInfo.sourceIndex;
        const lastChild = node.lastChild;
        let from = curInfo.offset;
        if (lastChild) {
            const lastChildInfo = lastChild.sourceInfo;
            if (lastChildInfo.offset > curInfo.offset) {
                from = lastChildInfo.offset + lastChildInfo.length;
            }
        }
        return [from, to, sourceIndex];
    }
}
exports.StructuredDocumentationReconstructor = StructuredDocumentationReconstructor;
class StructuredDocumentationReconstructingPostprocessor {
    constructor() {
        this.reconstructor = new StructuredDocumentationReconstructor();
    }
    process(node, context, sources) {
        if (sources === undefined) {
            return;
        }
        const root = node.root;
        const source = sources.get(root.sourceEntryKey);
        if (source === undefined) {
            return;
        }
        /**
         * Skip reconstructing preceding strcutured documentation
         * when related fields is already an instance of StructuredDocumentation.
         */
        if (!(node.documentation instanceof structured_documentation_1.StructuredDocumentation)) {
            const precedingGap = this.reconstructor.getPrecedingGapCoordinates(node);
            const preceding = this.reconstructor.fragmentCoordsToStructDoc(precedingGap, source);
            if (preceding) {
                preceding.id = context.lastId + 1;
                context.register(preceding);
                node.documentation = preceding;
                preceding.parent = node;
            }
        }
        /**
         * Dangling structured documentation can currently be added to
         * Statements, ContractDefinitions, EnumDefinitions and
         * StructDefinitions
         */
        if (node instanceof statement_1.StatementWithChildren ||
            node instanceof declaration_1.ContractDefinition ||
            node instanceof declaration_1.EnumDefinition ||
            node instanceof declaration_1.StructDefinition) {
            const danglingGap = this.reconstructor.getDanglingGapCoordinates(node);
            const dangling = this.reconstructor.fragmentCoordsToStructDoc(danglingGap, source);
            if (dangling) {
                dangling.id = context.lastId + 1;
                context.register(dangling);
                node.danglingDocumentation = dangling;
                dangling.parent = node;
            }
        }
    }
    isSupportedNode(node) {
        return (node instanceof declaration_1.FunctionDefinition ||
            node instanceof declaration_1.ContractDefinition ||
            node instanceof declaration_1.EnumDefinition ||
            node instanceof declaration_1.StructDefinition ||
            node instanceof declaration_1.ErrorDefinition ||
            node instanceof declaration_1.EventDefinition ||
            node instanceof declaration_1.ModifierDefinition ||
            (node instanceof declaration_1.VariableDeclaration &&
                (node.parent instanceof declaration_1.ContractDefinition ||
                    node.parent instanceof source_unit_1.SourceUnit ||
                    node.parent instanceof declaration_1.StructDefinition)) ||
            node instanceof statement_1.Statement ||
            node instanceof statement_1.StatementWithChildren);
    }
}
exports.StructuredDocumentationReconstructingPostprocessor = StructuredDocumentationReconstructingPostprocessor;
//# sourceMappingURL=structured_documentation_reconstruction.js.map