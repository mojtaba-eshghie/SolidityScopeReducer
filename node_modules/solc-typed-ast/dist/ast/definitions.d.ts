import { InferType } from "../types";
import { ASTNode } from "./ast_node";
import { ContractDefinition } from "./implementation/declaration/contract_definition";
import { EnumDefinition } from "./implementation/declaration/enum_definition";
import { ErrorDefinition } from "./implementation/declaration/error_definition";
import { EventDefinition } from "./implementation/declaration/event_definition";
import { FunctionDefinition } from "./implementation/declaration/function_definition";
import { ModifierDefinition } from "./implementation/declaration/modifier_definition";
import { StructDefinition } from "./implementation/declaration/struct_definition";
import { UserDefinedValueTypeDefinition } from "./implementation/declaration/user_defined_value_type_definition";
import { VariableDeclaration } from "./implementation/declaration/variable_declaration";
import { ImportDirective, SourceUnit } from "./implementation/meta";
import { Block, TryCatchClause, UncheckedBlock, VariableDeclarationStatement } from "./implementation/statement";
/**
 * Type describing the possible ASTNodes to which a given Identifier/IdentifierPath may resolve to.
 */
export type AnyResolvable = VariableDeclaration | FunctionDefinition | ModifierDefinition | ErrorDefinition | EventDefinition | StructDefinition | EnumDefinition | ContractDefinition | UserDefinedValueTypeDefinition | ImportDirective;
/**
 * Type describing all the ASTNodes that are scopes that can define new names
 */
export type ScopeNode = SourceUnit | ContractDefinition | FunctionDefinition | ModifierDefinition | VariableDeclarationStatement | Block | TryCatchClause | UncheckedBlock;
/**
 * Resolve the name `name` in the scope containing `ctx`, assuming compiler
 * version `version`. If `inclusive` is true, then if `ctx` itself is a scope,
 * lookup inside of it as well. (e.g. if ctx is the `ContractDefinition`
 * corresponding to `contract { uint x; }`, calling `resolveAny("x", node,
 * "0.5.0", true)` would return the state var X, and `resolveAny("x", node,
 * "0.5.0", false)` would return undefined.).
 *
 * Note that `name` can be an identifier path (e.g `A.B.C`).
 *
 * We return a set, since in the case where `name` resolves to a callable
 * (function/public state var) or event, there could be multiple
 * functions/events with the same name but different arguments. In all other
 * cases the returned set should have either 0 or 1 elements.
 */
export declare function resolveAny(name: string, ctx: ASTNode, inference: InferType, inclusive?: boolean, ignoreVisiblity?: boolean): Set<AnyResolvable>;
//# sourceMappingURL=definitions.d.ts.map