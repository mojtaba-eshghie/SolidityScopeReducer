"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setDanglingDocumentation = exports.getDanglingDocumentation = exports.setDocumentation = exports.getDocumentation = void 0;
const meta_1 = require("./implementation/meta");
function getDocumentation(node) {
    if (node.docString !== undefined) {
        return node.docString;
    }
    const ownLoc = node.sourceInfo;
    const children = node.children;
    for (let c = 0; c < children.length; c++) {
        const child = children[c];
        if (child instanceof meta_1.StructuredDocumentation) {
            const childLoc = child.sourceInfo;
            /**
             * Note that preceding documentation nodes are
             * EXCLUDED from source range of parent node.
             */
            if (childLoc.offset <= ownLoc.offset) {
                return child;
            }
        }
    }
    return undefined;
}
exports.getDocumentation = getDocumentation;
function setDocumentation(node, value) {
    const old = node.documentation;
    if (value instanceof meta_1.StructuredDocumentation) {
        node.docString = undefined;
        if (old instanceof meta_1.StructuredDocumentation) {
            if (value !== old) {
                node.replaceChild(value, old);
            }
        }
        else {
            node.insertAtBeginning(value);
        }
    }
    else {
        if (old instanceof meta_1.StructuredDocumentation) {
            node.removeChild(old);
        }
        node.docString = value;
    }
}
exports.setDocumentation = setDocumentation;
function getDanglingDocumentation(node) {
    if (node.danglingDocString !== undefined) {
        return node.danglingDocString;
    }
    const ownLoc = node.sourceInfo;
    const children = node.children;
    for (let c = children.length - 1; c >= 0; c--) {
        const child = children[c];
        if (child instanceof meta_1.StructuredDocumentation) {
            const childLoc = child.sourceInfo;
            /**
             * Note that preceding documentation nodes are
             * INCLUDED from source range of parent node.
             */
            if (childLoc.offset > ownLoc.offset) {
                return child;
            }
        }
    }
    return undefined;
}
exports.getDanglingDocumentation = getDanglingDocumentation;
function setDanglingDocumentation(node, value) {
    const old = node.danglingDocumentation;
    if (value instanceof meta_1.StructuredDocumentation) {
        node.danglingDocString = undefined;
        if (old instanceof meta_1.StructuredDocumentation) {
            if (value !== old) {
                node.replaceChild(value, old);
            }
        }
        else {
            node.appendChild(value);
        }
    }
    else {
        if (old instanceof meta_1.StructuredDocumentation) {
            node.removeChild(old);
        }
        node.danglingDocString = value;
    }
}
exports.setDanglingDocumentation = setDanglingDocumentation;
//# sourceMappingURL=documentation.js.map