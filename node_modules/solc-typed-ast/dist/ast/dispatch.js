"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveCallable = exports.resolveEvent = exports.resolveByName = exports.resolve = void 0;
const constants_1 = require("./constants");
const contract_definition_1 = require("./implementation/declaration/contract_definition");
const event_definition_1 = require("./implementation/declaration/event_definition");
const function_definition_1 = require("./implementation/declaration/function_definition");
const modifier_definition_1 = require("./implementation/declaration/modifier_definition");
const variable_declaration_1 = require("./implementation/declaration/variable_declaration");
const identifier_1 = require("./implementation/expression/identifier");
const member_access_1 = require("./implementation/expression/member_access");
function getResolvableCollection(contract, target) {
    if (target === function_definition_1.FunctionDefinition) {
        return contract.vFunctions;
    }
    if (target === modifier_definition_1.ModifierDefinition) {
        return contract.vModifiers;
    }
    if (target === event_definition_1.EventDefinition) {
        return contract.vEvents;
    }
    if (target === variable_declaration_1.VariableDeclaration) {
        return contract.vStateVariables;
    }
    throw new Error("Unable to select resolvable collection for target " + target.name);
}
function resolve(scope, target, inference, onlyParents = false) {
    let finder;
    if (target instanceof variable_declaration_1.VariableDeclaration) {
        finder = (candidate) => candidate.name === target.name;
    }
    else {
        const signatureHash = inference.signatureHash(target);
        finder = (candidate) => signatureHash === inference.signatureHash(candidate);
    }
    for (const base of scope.vLinearizedBaseContracts) {
        if (onlyParents && base === scope) {
            continue;
        }
        const collection = getResolvableCollection(base, target.constructor);
        const result = collection.find(finder);
        if (result) {
            return result;
        }
    }
    return undefined;
}
exports.resolve = resolve;
/**
 * Resolve an inheritable contract property following the standard C3 linearization order.
 *
 * @param constructor The class constructor of the type of contract
 *   property we are resolving. One of `FunctionDefinition`,
 *   `ModifierDefinition`, `EventDefinition` or `VariableDeclaration`
 * @param name Name of the property we are attempting to resolve. Note that
 *   if we are resolving functions or events there may be multiple results as
 *   functions/events can have the same name and different arguments
 * @param onlyParents boolean flag specifing that we want to only look through the bases of the contract.
 */
function resolveByName(scope, constructor, name, inference, onlyParents = false) {
    const result = [];
    const found = new Set();
    for (const base of scope.vLinearizedBaseContracts) {
        if (onlyParents && base === scope) {
            continue;
        }
        const collection = getResolvableCollection(base, constructor);
        for (const resolvable of collection) {
            /**
             * We use `resolvableIdentifier` to avoid adding already-overloaded functions
             * into the resolved set.
             * (Its safe to assume ABIEncoderVersionV2 as its backwards
             * compatible, and we only use it internally here.)
             */
            const resolvableIdentifier = resolvable instanceof variable_declaration_1.VariableDeclaration
                ? resolvable.name
                : inference.signatureHash(resolvable);
            if (resolvable.name === name && !found.has(resolvableIdentifier)) {
                result.push(resolvable);
                found.add(resolvableIdentifier);
            }
        }
    }
    return result;
}
exports.resolveByName = resolveByName;
function isExplicitlyBound(call) {
    if (call.vExpression instanceof member_access_1.MemberAccess) {
        const expression = call.vExpression.vExpression;
        if (expression instanceof identifier_1.Identifier &&
            expression.vReferencedDeclaration instanceof contract_definition_1.ContractDefinition) {
            return true;
        }
    }
    return false;
}
function resolveEvent(scope, statement, inference, onlyParents = false) {
    const call = statement.vEventCall;
    const definition = call.vReferencedDeclaration;
    if (definition instanceof event_definition_1.EventDefinition) {
        return isExplicitlyBound(call)
            ? definition
            : resolve(scope, definition, inference, onlyParents);
    }
    return undefined;
}
exports.resolveEvent = resolveEvent;
function resolveCallable(scope, definition, inference, onlyParents = false) {
    const selector = inference.signatureHash(definition);
    for (const base of scope.vLinearizedBaseContracts) {
        if (onlyParents && base === scope) {
            continue;
        }
        for (const fn of base.vFunctions) {
            if (inference.signatureHash(fn) === selector) {
                return fn;
            }
        }
        for (const v of base.vStateVariables) {
            if (v.visibility === constants_1.StateVariableVisibility.Public) {
                if (inference.signatureHash(v) === selector) {
                    return v;
                }
            }
        }
    }
    return undefined;
}
exports.resolveCallable = resolveCallable;
//# sourceMappingURL=dispatch.js.map