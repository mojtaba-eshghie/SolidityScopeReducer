"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ASTNodeFactory = void 0;
const ast_node_1 = require("./ast_node");
const ast_reader_1 = require("./ast_reader");
const constants_1 = require("./constants");
const contract_definition_1 = require("./implementation/declaration/contract_definition");
const enum_definition_1 = require("./implementation/declaration/enum_definition");
const enum_value_1 = require("./implementation/declaration/enum_value");
const error_definition_1 = require("./implementation/declaration/error_definition");
const event_definition_1 = require("./implementation/declaration/event_definition");
const function_definition_1 = require("./implementation/declaration/function_definition");
const modifier_definition_1 = require("./implementation/declaration/modifier_definition");
const struct_definition_1 = require("./implementation/declaration/struct_definition");
const user_defined_value_type_definition_1 = require("./implementation/declaration/user_defined_value_type_definition");
const variable_declaration_1 = require("./implementation/declaration/variable_declaration");
const assignment_1 = require("./implementation/expression/assignment");
const binary_operation_1 = require("./implementation/expression/binary_operation");
const conditional_1 = require("./implementation/expression/conditional");
const elementary_type_name_expression_1 = require("./implementation/expression/elementary_type_name_expression");
const function_call_1 = require("./implementation/expression/function_call");
const function_call_options_1 = require("./implementation/expression/function_call_options");
const identifier_1 = require("./implementation/expression/identifier");
const index_access_1 = require("./implementation/expression/index_access");
const index_range_access_1 = require("./implementation/expression/index_range_access");
const literal_1 = require("./implementation/expression/literal");
const member_access_1 = require("./implementation/expression/member_access");
const new_expression_1 = require("./implementation/expression/new_expression");
const primary_expression_1 = require("./implementation/expression/primary_expression");
const tuple_expression_1 = require("./implementation/expression/tuple_expression");
const unary_operation_1 = require("./implementation/expression/unary_operation");
const identifier_path_1 = require("./implementation/meta/identifier_path");
const import_directive_1 = require("./implementation/meta/import_directive");
const inheritance_specifier_1 = require("./implementation/meta/inheritance_specifier");
const modifier_invocation_1 = require("./implementation/meta/modifier_invocation");
const override_specifier_1 = require("./implementation/meta/override_specifier");
const parameter_list_1 = require("./implementation/meta/parameter_list");
const pragma_directive_1 = require("./implementation/meta/pragma_directive");
const source_unit_1 = require("./implementation/meta/source_unit");
const structured_documentation_1 = require("./implementation/meta/structured_documentation");
const using_for_directive_1 = require("./implementation/meta/using_for_directive");
const block_1 = require("./implementation/statement/block");
const break_1 = require("./implementation/statement/break");
const continue_1 = require("./implementation/statement/continue");
const do_while_statement_1 = require("./implementation/statement/do_while_statement");
const emit_statement_1 = require("./implementation/statement/emit_statement");
const expression_statement_1 = require("./implementation/statement/expression_statement");
const for_statement_1 = require("./implementation/statement/for_statement");
const if_statement_1 = require("./implementation/statement/if_statement");
const inline_assembly_1 = require("./implementation/statement/inline_assembly");
const placeholder_statement_1 = require("./implementation/statement/placeholder_statement");
const return_1 = require("./implementation/statement/return");
const revert_statement_1 = require("./implementation/statement/revert_statement");
const throw_1 = require("./implementation/statement/throw");
const try_catch_clause_1 = require("./implementation/statement/try_catch_clause");
const try_statement_1 = require("./implementation/statement/try_statement");
const unchecked_block_1 = require("./implementation/statement/unchecked_block");
const variable_declaration_statement_1 = require("./implementation/statement/variable_declaration_statement");
const while_statement_1 = require("./implementation/statement/while_statement");
const array_type_name_1 = require("./implementation/type/array_type_name");
const elementary_type_name_1 = require("./implementation/type/elementary_type_name");
const function_type_name_1 = require("./implementation/type/function_type_name");
const mapping_1 = require("./implementation/type/mapping");
const user_defined_type_name_1 = require("./implementation/type/user_defined_type_name");
const argExtractionMapping = new Map([
    [ast_node_1.ASTNode, (node) => [node.raw]],
    [
        contract_definition_1.ContractDefinition,
        (node) => [
            node.name,
            node.scope,
            node.kind,
            node.abstract,
            node.fullyImplemented,
            node.linearizedBaseContracts,
            node.usedErrors,
            node.usedEvents,
            node.documentation,
            node.children,
            node.nameLocation,
            node.raw
        ]
    ],
    [
        enum_definition_1.EnumDefinition,
        (node) => [
            node.name,
            node.vMembers,
            node.documentation,
            node.nameLocation,
            node.raw
        ]
    ],
    [
        enum_value_1.EnumValue,
        (node) => [
            node.name,
            node.nameLocation,
            node.raw
        ]
    ],
    [
        error_definition_1.ErrorDefinition,
        (node) => [
            node.name,
            node.vParameters,
            node.documentation,
            node.nameLocation,
            node.raw
        ]
    ],
    [
        event_definition_1.EventDefinition,
        (node) => [
            node.anonymous,
            node.name,
            node.vParameters,
            node.documentation,
            node.nameLocation,
            node.raw
        ]
    ],
    [
        function_definition_1.FunctionDefinition,
        (node) => [
            node.scope,
            node.kind,
            node.name,
            node.virtual,
            node.visibility,
            node.stateMutability,
            node.isConstructor,
            node.vParameters,
            node.vReturnParameters,
            node.vModifiers,
            node.vOverrideSpecifier,
            node.vBody,
            node.documentation,
            node.nameLocation,
            node.raw
        ]
    ],
    [
        modifier_definition_1.ModifierDefinition,
        (node) => [
            node.name,
            node.virtual,
            node.visibility,
            node.vParameters,
            node.vOverrideSpecifier,
            node.vBody,
            node.documentation,
            node.nameLocation,
            node.raw
        ]
    ],
    [
        struct_definition_1.StructDefinition,
        (node) => [
            node.name,
            node.scope,
            node.visibility,
            node.vMembers,
            node.documentation,
            node.nameLocation,
            node.raw
        ]
    ],
    [
        user_defined_value_type_definition_1.UserDefinedValueTypeDefinition,
        (node) => [
            node.name,
            node.underlyingType,
            node.nameLocation,
            node.raw
        ]
    ],
    [
        variable_declaration_1.VariableDeclaration,
        (node) => [
            node.constant,
            node.indexed,
            node.name,
            node.scope,
            node.stateVariable,
            node.storageLocation,
            node.visibility,
            node.mutability,
            node.typeString,
            node.documentation,
            node.vType,
            node.vOverrideSpecifier,
            node.vValue,
            node.nameLocation,
            node.raw
        ]
    ],
    [
        assignment_1.Assignment,
        (node) => [
            node.typeString,
            node.operator,
            node.vLeftHandSide,
            node.vRightHandSide,
            node.raw
        ]
    ],
    [
        binary_operation_1.BinaryOperation,
        (node) => [
            node.typeString,
            node.operator,
            node.vLeftExpression,
            node.vRightExpression,
            node.userFunction,
            node.raw
        ]
    ],
    [
        conditional_1.Conditional,
        (node) => [
            node.typeString,
            node.vCondition,
            node.vTrueExpression,
            node.vFalseExpression,
            node.raw
        ]
    ],
    [
        elementary_type_name_expression_1.ElementaryTypeNameExpression,
        (node) => [
            node.typeString,
            node.typeName,
            node.raw
        ]
    ],
    [
        function_call_options_1.FunctionCallOptions,
        (node) => [
            node.typeString,
            node.vExpression,
            node.vOptionsMap,
            node.raw
        ]
    ],
    [
        function_call_1.FunctionCall,
        (node) => [
            node.typeString,
            node.kind,
            node.vExpression,
            node.vArguments,
            node.fieldNames,
            node.raw
        ]
    ],
    [
        identifier_1.Identifier,
        (node) => [
            node.typeString,
            node.name,
            node.referencedDeclaration,
            node.raw
        ]
    ],
    [
        identifier_path_1.IdentifierPath,
        (node) => [
            node.name,
            node.referencedDeclaration,
            node.raw
        ]
    ],
    [
        index_access_1.IndexAccess,
        (node) => [
            node.typeString,
            node.vBaseExpression,
            node.vIndexExpression,
            node.raw
        ]
    ],
    [
        index_range_access_1.IndexRangeAccess,
        (node) => [
            node.typeString,
            node.vBaseExpression,
            node.vStartExpression,
            node.vEndExpression,
            node.raw
        ]
    ],
    [
        literal_1.Literal,
        (node) => [
            node.typeString,
            node.kind,
            node.hexValue,
            node.value,
            node.subdenomination,
            node.raw
        ]
    ],
    [
        member_access_1.MemberAccess,
        (node) => [
            node.typeString,
            node.vExpression,
            node.memberName,
            node.referencedDeclaration,
            node.raw
        ]
    ],
    [
        new_expression_1.NewExpression,
        (node) => [
            node.typeString,
            node.vTypeName,
            node.raw
        ]
    ],
    [
        tuple_expression_1.TupleExpression,
        (node) => [
            node.typeString,
            node.isInlineArray,
            node.vOriginalComponents,
            node.raw
        ]
    ],
    [
        unary_operation_1.UnaryOperation,
        (node) => [
            node.typeString,
            node.prefix,
            node.operator,
            node.vSubExpression,
            node.userFunction,
            node.raw
        ]
    ],
    [
        import_directive_1.ImportDirective,
        (node) => [
            node.file,
            node.absolutePath,
            node.unitAlias,
            node.symbolAliases,
            node.scope,
            node.sourceUnit,
            node.raw
        ]
    ],
    [
        inheritance_specifier_1.InheritanceSpecifier,
        (node) => [
            node.vBaseType,
            node.vArguments,
            node.raw
        ]
    ],
    [
        modifier_invocation_1.ModifierInvocation,
        (node) => [
            node.vModifierName,
            node.vArguments,
            node.kind,
            node.raw
        ]
    ],
    [
        override_specifier_1.OverrideSpecifier,
        (node) => [
            node.vOverrides,
            node.raw
        ]
    ],
    [
        parameter_list_1.ParameterList,
        (node) => [
            node.vParameters,
            node.raw
        ]
    ],
    [
        pragma_directive_1.PragmaDirective,
        (node) => [
            node.literals,
            node.raw
        ]
    ],
    [
        source_unit_1.SourceUnit,
        (node) => [
            node.sourceEntryKey,
            node.sourceListIndex,
            node.absolutePath,
            node.exportedSymbols,
            node.children,
            node.license,
            node.raw
        ]
    ],
    [
        structured_documentation_1.StructuredDocumentation,
        (node) => [node.text, node.raw]
    ],
    [
        using_for_directive_1.UsingForDirective,
        (node) => [
            node.isGlobal,
            node.vLibraryName,
            node.vFunctionList,
            node.vTypeName,
            node.raw
        ]
    ],
    [
        block_1.Block,
        (node) => [
            node.vStatements,
            node.documentation,
            node.raw
        ]
    ],
    [
        unchecked_block_1.UncheckedBlock,
        (node) => [
            node.vStatements,
            node.documentation,
            node.raw
        ]
    ],
    [
        break_1.Break,
        (node) => [
            node.documentation,
            node.raw
        ]
    ],
    [
        continue_1.Continue,
        (node) => [
            node.documentation,
            node.raw
        ]
    ],
    [
        do_while_statement_1.DoWhileStatement,
        (node) => [
            node.vCondition,
            node.vBody,
            node.documentation,
            node.raw
        ]
    ],
    [
        emit_statement_1.EmitStatement,
        (node) => [
            node.vEventCall,
            node.documentation,
            node.raw
        ]
    ],
    [
        expression_statement_1.ExpressionStatement,
        (node) => [
            node.vExpression,
            node.documentation,
            node.raw
        ]
    ],
    [
        for_statement_1.ForStatement,
        (node) => [
            node.vBody,
            node.vInitializationExpression,
            node.vCondition,
            node.vLoopExpression,
            node.documentation,
            node.raw
        ]
    ],
    [
        if_statement_1.IfStatement,
        (node) => [
            node.vCondition,
            node.vTrueBody,
            node.vFalseBody,
            node.documentation,
            node.raw
        ]
    ],
    [
        inline_assembly_1.InlineAssembly,
        (node) => [
            node.externalReferences,
            node.operations,
            node.yul,
            node.flags,
            node.evmVersion,
            node.documentation,
            node.raw
        ]
    ],
    [
        placeholder_statement_1.PlaceholderStatement,
        (node) => [
            node.documentation,
            node.raw
        ]
    ],
    [
        return_1.Return,
        (node) => [
            node.functionReturnParameters,
            node.vExpression,
            node.documentation,
            node.raw
        ]
    ],
    [
        revert_statement_1.RevertStatement,
        (node) => [
            node.errorCall,
            node.documentation,
            node.raw
        ]
    ],
    [
        throw_1.Throw,
        (node) => [
            node.documentation,
            node.raw
        ]
    ],
    [
        try_catch_clause_1.TryCatchClause,
        (node) => [
            node.errorName,
            node.vBlock,
            node.vParameters,
            node.documentation,
            node.raw
        ]
    ],
    [
        try_statement_1.TryStatement,
        (node) => [
            node.vExternalCall,
            node.vClauses,
            node.documentation,
            node.raw
        ]
    ],
    [
        variable_declaration_statement_1.VariableDeclarationStatement,
        (node) => [
            node.assignments,
            node.vDeclarations,
            node.vInitialValue,
            node.documentation,
            node.raw
        ]
    ],
    [
        while_statement_1.WhileStatement,
        (node) => [
            node.vCondition,
            node.vBody,
            node.documentation,
            node.raw
        ]
    ],
    [
        array_type_name_1.ArrayTypeName,
        (node) => [
            node.typeString,
            node.vBaseType,
            node.vLength,
            node.raw
        ]
    ],
    [
        elementary_type_name_1.ElementaryTypeName,
        (node) => [
            node.typeString,
            node.name,
            node.stateMutability,
            node.raw
        ]
    ],
    [
        function_type_name_1.FunctionTypeName,
        (node) => [
            node.typeString,
            node.visibility,
            node.stateMutability,
            node.vParameterTypes,
            node.vReturnParameterTypes,
            node.raw
        ]
    ],
    [
        mapping_1.Mapping,
        (node) => [
            node.typeString,
            node.vKeyType,
            node.vValueType,
            node.raw
        ]
    ],
    [
        user_defined_type_name_1.UserDefinedTypeName,
        (node) => [
            node.typeString,
            node.name,
            node.referencedDeclaration,
            node.path,
            node.raw
        ]
    ]
]);
class ASTNodeFactory {
    constructor(context = new ast_reader_1.ASTContext(), postprocessor = new ast_reader_1.ASTPostprocessor()) {
        this.context = context;
        this.postprocessor = postprocessor;
        this.lastId = context.lastId;
    }
    makeContractDefinition(...args) {
        return this.make(contract_definition_1.ContractDefinition, ...args);
    }
    makeEnumDefinition(...args) {
        return this.make(enum_definition_1.EnumDefinition, ...args);
    }
    makeEnumValue(...args) {
        return this.make(enum_value_1.EnumValue, ...args);
    }
    makeErrorDefinition(...args) {
        return this.make(error_definition_1.ErrorDefinition, ...args);
    }
    makeEventDefinition(...args) {
        return this.make(event_definition_1.EventDefinition, ...args);
    }
    makeFunctionDefinition(...args) {
        return this.make(function_definition_1.FunctionDefinition, ...args);
    }
    makeModifierDefinition(...args) {
        return this.make(modifier_definition_1.ModifierDefinition, ...args);
    }
    makeStructDefinition(...args) {
        return this.make(struct_definition_1.StructDefinition, ...args);
    }
    makeUserDefinedValueTypeDefinition(...args) {
        return this.make(user_defined_value_type_definition_1.UserDefinedValueTypeDefinition, ...args);
    }
    makeVariableDeclaration(...args) {
        return this.make(variable_declaration_1.VariableDeclaration, ...args);
    }
    makeAssignment(...args) {
        return this.make(assignment_1.Assignment, ...args);
    }
    makeBinaryOperation(...args) {
        return this.make(binary_operation_1.BinaryOperation, ...args);
    }
    makeConditional(...args) {
        return this.make(conditional_1.Conditional, ...args);
    }
    makeElementaryTypeNameExpression(...args) {
        return this.make(elementary_type_name_expression_1.ElementaryTypeNameExpression, ...args);
    }
    makeFunctionCallOptions(...args) {
        return this.make(function_call_options_1.FunctionCallOptions, ...args);
    }
    makeFunctionCall(...args) {
        return this.make(function_call_1.FunctionCall, ...args);
    }
    makeIdentifier(...args) {
        return this.make(identifier_1.Identifier, ...args);
    }
    makeIdentifierPath(...args) {
        return this.make(identifier_path_1.IdentifierPath, ...args);
    }
    makeIndexAccess(...args) {
        return this.make(index_access_1.IndexAccess, ...args);
    }
    makeIndexRangeAccess(...args) {
        return this.make(index_range_access_1.IndexRangeAccess, ...args);
    }
    makeLiteral(...args) {
        return this.make(literal_1.Literal, ...args);
    }
    makeMemberAccess(...args) {
        return this.make(member_access_1.MemberAccess, ...args);
    }
    makeNewExpression(...args) {
        return this.make(new_expression_1.NewExpression, ...args);
    }
    makePrimaryExpression(...args) {
        return this.make(primary_expression_1.PrimaryExpression, ...args);
    }
    makeTupleExpression(...args) {
        return this.make(tuple_expression_1.TupleExpression, ...args);
    }
    makeUnaryOperation(...args) {
        return this.make(unary_operation_1.UnaryOperation, ...args);
    }
    makeImportDirective(...args) {
        return this.make(import_directive_1.ImportDirective, ...args);
    }
    makeInheritanceSpecifier(...args) {
        return this.make(inheritance_specifier_1.InheritanceSpecifier, ...args);
    }
    makeModifierInvocation(...args) {
        return this.make(modifier_invocation_1.ModifierInvocation, ...args);
    }
    makeOverrideSpecifier(...args) {
        return this.make(override_specifier_1.OverrideSpecifier, ...args);
    }
    makeParameterList(...args) {
        return this.make(parameter_list_1.ParameterList, ...args);
    }
    makePragmaDirective(...args) {
        return this.make(pragma_directive_1.PragmaDirective, ...args);
    }
    makeSourceUnit(...args) {
        return this.make(source_unit_1.SourceUnit, ...args);
    }
    makeStructuredDocumentation(...args) {
        return this.make(structured_documentation_1.StructuredDocumentation, ...args);
    }
    makeUsingForDirective(...args) {
        return this.make(using_for_directive_1.UsingForDirective, ...args);
    }
    makeBlock(...args) {
        return this.make(block_1.Block, ...args);
    }
    makeUncheckedBlock(...args) {
        return this.make(unchecked_block_1.UncheckedBlock, ...args);
    }
    makeBreak(...args) {
        return this.make(break_1.Break, ...args);
    }
    makeContinue(...args) {
        return this.make(continue_1.Continue, ...args);
    }
    makeDoWhileStatement(...args) {
        return this.make(do_while_statement_1.DoWhileStatement, ...args);
    }
    makeEmitStatement(...args) {
        return this.make(emit_statement_1.EmitStatement, ...args);
    }
    makeExpressionStatement(...args) {
        return this.make(expression_statement_1.ExpressionStatement, ...args);
    }
    makeForStatement(...args) {
        return this.make(for_statement_1.ForStatement, ...args);
    }
    makeIfStatement(...args) {
        return this.make(if_statement_1.IfStatement, ...args);
    }
    makeInlineAssembly(...args) {
        return this.make(inline_assembly_1.InlineAssembly, ...args);
    }
    makePlaceholderStatement(...args) {
        return this.make(placeholder_statement_1.PlaceholderStatement, ...args);
    }
    makeReturn(...args) {
        return this.make(return_1.Return, ...args);
    }
    makeRevertStatement(...args) {
        return this.make(revert_statement_1.RevertStatement, ...args);
    }
    makeThrow(...args) {
        return this.make(throw_1.Throw, ...args);
    }
    makeTryCatchClause(...args) {
        return this.make(try_catch_clause_1.TryCatchClause, ...args);
    }
    makeTryStatement(...args) {
        return this.make(try_statement_1.TryStatement, ...args);
    }
    makeVariableDeclarationStatement(...args) {
        return this.make(variable_declaration_statement_1.VariableDeclarationStatement, ...args);
    }
    makeWhileStatement(...args) {
        return this.make(while_statement_1.WhileStatement, ...args);
    }
    makeArrayTypeName(...args) {
        return this.make(array_type_name_1.ArrayTypeName, ...args);
    }
    makeElementaryTypeName(...args) {
        return this.make(elementary_type_name_1.ElementaryTypeName, ...args);
    }
    makeFunctionTypeName(...args) {
        return this.make(function_type_name_1.FunctionTypeName, ...args);
    }
    makeMapping(...args) {
        return this.make(mapping_1.Mapping, ...args);
    }
    makeUserDefinedTypeName(...args) {
        return this.make(user_defined_type_name_1.UserDefinedTypeName, ...args);
    }
    makeIdentifierFor(target) {
        let typeString;
        if (target instanceof variable_declaration_1.VariableDeclaration) {
            typeString = target.typeString;
        }
        else if (target instanceof function_definition_1.FunctionDefinition) {
            const args = target.vParameters.vParameters.map(this.typeExtractor);
            const result = [`function (${args.join(",")})`];
            if (target.stateMutability !== constants_1.FunctionStateMutability.NonPayable) {
                result.push(target.stateMutability);
            }
            if (target.visibility !== constants_1.FunctionVisibility.Public) {
                result.push(target.visibility);
            }
            if (target.vReturnParameters.vParameters.length) {
                const rets = target.vReturnParameters.vParameters.map(this.typeExtractor);
                result.push(`returns (${rets.join(",")})`);
            }
            typeString = result.join(" ");
        }
        else if (target instanceof contract_definition_1.ContractDefinition) {
            typeString = `type(contract ${target.name})`;
        }
        else if (target instanceof struct_definition_1.StructDefinition) {
            typeString = `type(struct ${target.canonicalName} storage pointer)`;
        }
        else if (target instanceof enum_definition_1.EnumDefinition) {
            typeString = `type(enum ${target.canonicalName})`;
        }
        else if (target instanceof user_defined_value_type_definition_1.UserDefinedValueTypeDefinition) {
            typeString = `type(${target.canonicalName})`;
        }
        else if (target instanceof event_definition_1.EventDefinition || target instanceof error_definition_1.ErrorDefinition) {
            const args = target.vParameters.vParameters.map(this.typeExtractor);
            typeString = `function (${args.join(",")})`;
        }
        else if (target instanceof import_directive_1.ImportDirective) {
            typeString = "<missing>";
            if (target.unitAlias === "") {
                throw new Error('Target ImportDirective required to have valid "unitAlias"');
            }
        }
        else {
            throw new Error("ASTNodeFactory.makeIdentifierFor(): Unable to compose typeString for supplied target");
        }
        return this.makeIdentifier(typeString, target instanceof import_directive_1.ImportDirective ? target.unitAlias : target.name, target.id);
    }
    makeUnfinalized(type, ...args) {
        const node = new type(++this.lastId, "0:0:0", ...args);
        this.context.register(node);
        return node;
    }
    make(type, ...args) {
        const node = this.makeUnfinalized(type, ...args);
        this.postprocessor.processNode(node, this.context);
        return node;
    }
    copy(node) {
        const cache = new Map();
        const clone = this.copyHelper(node, cache);
        const context = this.context;
        const postprocessor = this.postprocessor;
        for (const child of clone.getChildren(true)) {
            this.patchIds(child, cache);
            postprocessor.processNode(child, context);
        }
        return clone;
    }
    patchIds(node, cache) {
        const patch = (oldId) => {
            const newId = cache.get(oldId);
            return newId === undefined ? oldId : newId;
        };
        if (node instanceof contract_definition_1.ContractDefinition ||
            node instanceof function_definition_1.FunctionDefinition ||
            node instanceof struct_definition_1.StructDefinition ||
            node instanceof variable_declaration_1.VariableDeclaration ||
            node instanceof import_directive_1.ImportDirective) {
            node.scope = patch(node.scope);
        }
        if (node instanceof contract_definition_1.ContractDefinition) {
            node.linearizedBaseContracts = node.linearizedBaseContracts.map(patch);
            node.usedErrors = node.usedErrors.map(patch);
        }
        if (node instanceof identifier_1.Identifier ||
            node instanceof identifier_path_1.IdentifierPath ||
            node instanceof member_access_1.MemberAccess ||
            node instanceof user_defined_type_name_1.UserDefinedTypeName) {
            node.referencedDeclaration = patch(node.referencedDeclaration);
        }
        if (node instanceof import_directive_1.ImportDirective) {
            node.sourceUnit = patch(node.sourceUnit);
        }
        if (node instanceof source_unit_1.SourceUnit) {
            const m = new Map();
            for (const [k, v] of node.exportedSymbols) {
                m.set(k, patch(v));
            }
            node.exportedSymbols = m;
        }
        if ((node instanceof unary_operation_1.UnaryOperation || node instanceof binary_operation_1.BinaryOperation) &&
            node.userFunction) {
            node.userFunction = patch(node.userFunction);
        }
        if (node instanceof variable_declaration_statement_1.VariableDeclarationStatement) {
            node.assignments = node.assignments.map((id) => (id === null ? id : patch(id)));
        }
    }
    copyHelper(node, cache) {
        const ctor = node.constructor;
        const extractor = argExtractionMapping.get(ctor);
        if (extractor === undefined) {
            throw new Error(`Unable to find extractor for node constructor ${ctor.name}`);
        }
        const args = extractor(node).map((arg) => this.copyValue(arg, cache));
        const clone = this.makeUnfinalized(ctor, ...args);
        cache.set(node.id, clone.id);
        return clone;
    }
    copyValue(value, cache) {
        if (value === null || value === undefined) {
            return value;
        }
        if (["string", "number", "bigint", "boolean"].includes(typeof value)) {
            return value;
        }
        if (value instanceof ast_reader_1.ASTContext) {
            return value;
        }
        if (value instanceof ast_node_1.ASTNode) {
            return this.copyHelper(value, cache);
        }
        if (value instanceof Array) {
            return value.map((v) => v instanceof ast_node_1.ASTNode ? this.copyHelper(v, cache) : this.copyValue(v, cache));
        }
        if (value instanceof Map) {
            const m = new Map();
            for (const [k, v] of value) {
                m.set(k instanceof ast_node_1.ASTNode ? this.copyHelper(k, cache) : this.copyValue(k, cache), v instanceof ast_node_1.ASTNode ? this.copyHelper(v, cache) : this.copyValue(v, cache));
            }
            return m;
        }
        if (typeof value === "object") {
            const o = {};
            const hasProperty = Object.hasOwnProperty;
            for (const p in value) {
                if (hasProperty.call(value, p)) {
                    o[p] = this.copyValue(value[p], cache);
                }
            }
            return o;
        }
        throw new Error(`Cannot copy value ${JSON.stringify(value)} of type ${typeof value}`);
    }
    typeExtractor(arg) {
        return arg.typeString;
    }
}
exports.ASTNodeFactory = ASTNodeFactory;
//# sourceMappingURL=ast_node_factory.js.map