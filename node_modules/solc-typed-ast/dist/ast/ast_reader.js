"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ASTReader = exports.ASTKind = exports.ASTPostprocessor = exports.ASTContext = void 0;
const legacy_1 = require("./legacy");
const modern_1 = require("./modern");
const postprocessing_1 = require("./postprocessing");
const utils_1 = require("./utils");
const contextIdSequence = (0, utils_1.sequence)();
class ASTContext {
    constructor(...nodes) {
        /**
         * ID to distinct different contexts
         */
        this.id = contextIdSequence.next().value;
        /**
         * Map from ID number to the `AST` node with same ID in tree
         */
        this.map = new Map();
        this.register(...nodes);
    }
    /**
     * Max ID of the registered nodes
     */
    get lastId() {
        let last = 0;
        for (const id of this.map.keys()) {
            if (id > last) {
                last = id;
            }
        }
        return last;
    }
    get nodes() {
        return this.map.values();
    }
    register(...nodes) {
        for (const node of nodes) {
            if (this.map.has(node.id)) {
                throw new Error(`The id ${node.id} is already taken for the context`);
            }
            if (node.context) {
                node.context.unregister(node);
            }
            this.map.set(node.id, node);
            node.context = this;
        }
    }
    unregister(...nodes) {
        for (const node of nodes) {
            if (!this.contains(node)) {
                throw new Error(`Supplied node with id ${node.id} not belongs to the context`);
            }
            this.map.delete(node.id);
            node.context = undefined;
        }
    }
    locate(id) {
        return this.map.get(id);
    }
    require(id) {
        const node = this.locate(id);
        if (node) {
            return node;
        }
        throw new Error("Required node not found for id " + id);
    }
    contains(node) {
        return this.locate(node.id) === node;
    }
}
exports.ASTContext = ASTContext;
class ASTPostprocessor {
    constructor(nodePostProcessors = postprocessing_1.DefaultNodePostprocessorList) {
        this.nodePostprocessors = nodePostProcessors;
    }
    getPostprocessorsForNode(node) {
        return this.nodePostprocessors.filter((postprocessor) => postprocessor.isSupportedNode(node));
    }
    processNode(node, context, sources) {
        const postprocessors = this.getPostprocessorsForNode(node);
        for (const postprocessor of postprocessors) {
            postprocessor.process(node, context, sources);
        }
    }
    processContext(context, sources) {
        for (const postprocessor of this.nodePostprocessors) {
            for (const node of context.nodes) {
                if (postprocessor.isSupportedNode(node)) {
                    postprocessor.process(node, context, sources);
                }
            }
        }
    }
}
exports.ASTPostprocessor = ASTPostprocessor;
var ASTKind;
(function (ASTKind) {
    ASTKind["Any"] = "any";
    ASTKind["Modern"] = "modern";
    ASTKind["Legacy"] = "legacy";
})(ASTKind || (exports.ASTKind = ASTKind = {}));
class ASTReader {
    constructor(context = new ASTContext(), postprocessor = new ASTPostprocessor()) {
        this.context = context;
        this.postprocessor = postprocessor;
    }
    /**
     * Takes a Solc-compiler JSON output data and reads it to produce
     * universal AST node tree.
     *
     * @param data      Compiler output data to process.
     * @param kind      Kind of an AST tree (legacy, modern or any).
     * @param sources   Map with the source file names as keys
     *                  and corresponding source content strings as values.
     *
     * @returns An array of `SourceUnit`s for each of the source entries in the input.
     */
    read(data, kind = ASTKind.Any, sources) {
        const entries = Object.entries(data.sources);
        const rootNodeTypeName = "SourceUnit";
        const result = [];
        for (const [key, content] of entries) {
            let ast;
            if (kind === ASTKind.Modern) {
                ast = content.ast;
            }
            else if (kind === ASTKind.Legacy) {
                ast = content.legacyAST || content.AST;
            }
            else {
                ast = content.ast || content.legacyAST || content.AST;
            }
            if (!ast) {
                throw new Error(`Unable to detect AST for entry "${key}"`);
            }
            let config;
            if (ast.nodeType === rootNodeTypeName) {
                config = modern_1.ModernConfiguration;
            }
            else if (ast.name === rootNodeTypeName) {
                config = legacy_1.LegacyConfiguration;
            }
            else {
                throw new Error(`Unable to detect reader configuration for entry "${key}"`);
            }
            ast.sourceEntryKey = key;
            const sourceUnit = this.convert(ast, config);
            result.push(sourceUnit);
        }
        this.postprocessor.processContext(this.context, sources);
        return result;
    }
    /**
     * Takes a raw Solc node object and produces
     * corresponding universal AST node instance.
     */
    convert(raw, config) {
        if (!raw) {
            throw new Error("Unable to read " + String(raw) + " as an AST node");
        }
        const signature = config.signatureDetector(raw);
        const rule = signature in config.rules ? config.rules[signature] : config.rules.Default;
        const { constructor, processor } = rule;
        const args = processor.process(this, config, raw);
        const node = new constructor(...args);
        this.context.register(node);
        return node;
    }
    /**
     * Takes an array of raw Solc node objects and produces
     * array of corresponding universal AST node instances.
     *
     * If input is not an array, then the empty array is returned.
     */
    convertArray(array, config) {
        const result = [];
        if (array instanceof Array) {
            for (const raw of array) {
                const node = this.convert(raw, config);
                result.push(node);
            }
        }
        return result;
    }
}
exports.ASTReader = ASTReader;
//# sourceMappingURL=ast_reader.js.map