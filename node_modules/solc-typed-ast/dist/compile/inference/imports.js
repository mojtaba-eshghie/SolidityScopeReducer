"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findAllFiles = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = require("path");
const __1 = require("..");
const __2 = require("../..");
const file_level_definitions_parser_1 = require("./file_level_definitions_parser");
/**
 * Apply the first remapping in `remappings` that fits `path` and
 * return the updated path.
 */
function applyRemappings(remappings, path) {
    for (const [, prefix, mapped_prefix] of remappings) {
        if (path.startsWith(prefix)) {
            return path.replace(prefix, mapped_prefix);
        }
    }
    return path;
}
/**
 * Check that `path` starts with a relative prefix "." or "./".  Note that we
 * don't use `!path.isAbsolute(path)` on purpose.  Otherwise it might consider
 * paths like `@open-zeppelin/...` as relative.
 */
function isPathWithRelativePrefix(path) {
    return path.startsWith("./") || path.startsWith("../");
}
/**
 * Normalize a relative import path as described in
 * https://docs.soliditylang.org/en/v0.8.8/path-resolution.html#relative-imports
 *
 * @param importer - source unit name of importing unit
 * @param imported - path of import directive
 */
function normalizeRelativeImportPath(importer, imported) {
    imported = (0, path_1.normalize)(imported);
    const importedSegments = imported.split("/").filter((s) => s !== "");
    let prefix = (0, path_1.dirname)(importer);
    let strippedSegments = 0;
    while (strippedSegments < importedSegments.length &&
        importedSegments[strippedSegments] === "..") {
        prefix = (0, path_1.dirname)(prefix);
        strippedSegments++;
    }
    // According to https://docs.soliditylang.org/en/v0.8.8/path-resolution.html#relative-imports when prefix
    // is empty there is no leading "./". However `dirname` always returns non-empty prefixes.
    // Handle this edge case.
    if (prefix === "." && !importer.startsWith(".")) {
        prefix = "";
    }
    (0, __2.assert)(prefix === "" || !prefix.endsWith("/"), `Invalid prefix ${prefix}`);
    const suffix = importedSegments.slice(strippedSegments).join("/");
    return prefix === "" ? suffix : prefix + "/" + suffix;
}
/**
 * Given the `importer` source unit path, and the path `imported` of an import
 * directive compute the expected **source unit name** of the imported file.
 * This is the name the compiler will look for in its "VFS" as defined starting
 * here:
 *
 * https://docs.soliditylang.org/en/v0.8.8/path-resolution.html
 *
 * This takes into account relative and absolute paths and remappings.
 */
function computeSourceUnitName(importerSourceUnit, imported, remappings) {
    if (isPathWithRelativePrefix(imported)) {
        return normalizeRelativeImportPath(importerSourceUnit, imported);
    }
    return applyRemappings(remappings, imported);
}
async function resolveSourceUnitName(sourceUnitName, resolvers) {
    for (const resolver of resolvers) {
        const resolvedPath = resolver.resolve(sourceUnitName);
        if (resolvedPath !== undefined) {
            const contents = await fs_extra_1.default.readFile(resolvedPath);
            return [contents, resolvedPath];
        }
    }
    return undefined;
}
/**
 * Given a partial map `files` from **source unit names** to file contents, a list of
 * `remappings` and a list of `ImportResolver`s - `resolvers`, find all
 * files that are imported from the starting set `files` but are
 * **missing** in `files` and add them into the `files` map. Also for each imported file
 * add a mapping from its source unit name to the actual file name in `fileNames`.
 */
async function findAllFiles(files, fileNames, remappings, resolvers, visited = new Set()) {
    /**
     * Queue of source unit names to process
     */
    const queue = [...files.keys()];
    while (queue.length > 0) {
        const sourceUnitName = queue.pop();
        /**
         * Skip already processed units
         */
        if (visited.has(sourceUnitName)) {
            continue;
        }
        visited.add(sourceUnitName);
        let content = files.get(sourceUnitName);
        /**
         * Missing contents - try and fill them in from the resolvers
         */
        if (content === undefined) {
            const result = await resolveSourceUnitName(sourceUnitName, resolvers);
            if (result === undefined) {
                throw new __1.CompileInferenceError(`Couldn't find ${sourceUnitName}`);
            }
            content = result[0];
            files.set(sourceUnitName, content);
            fileNames.set(sourceUnitName, result[1]);
        }
        let flds;
        try {
            flds = (0, file_level_definitions_parser_1.parseFileLevelDefinitions)((0, __2.bytesToString)(content));
        }
        catch (e) {
            if (e instanceof file_level_definitions_parser_1.PeggySyntaxError) {
                const start = e.location.start.offset;
                const end = e.location.end.offset;
                const length = end - start;
                throw new __1.CompileInferenceError(`Failed parsing imports at ${sourceUnitName}:${start}:${length} - ${e.message}`);
            }
            throw e;
        }
        for (const fld of flds) {
            if (fld.kind === file_level_definitions_parser_1.FileLevelNodeKind.Import) {
                queue.push(computeSourceUnitName(sourceUnitName, fld.path, remappings));
            }
        }
    }
}
exports.findAllFiles = findAllFiles;
//# sourceMappingURL=imports.js.map