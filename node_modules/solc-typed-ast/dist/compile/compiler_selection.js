"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VersionDetectionStrategy = exports.LatestAndFirstVersionInEachSeriesStrategy = exports.LatestVersionInEachSeriesStrategy = exports.RangeVersionStrategy = void 0;
const misc_1 = require("../misc");
const constants_1 = require("./constants");
const version_1 = require("./version");
class RangeVersionStrategy {
    constructor(range) {
        this.range = range;
    }
    select() {
        return this.range;
    }
}
exports.RangeVersionStrategy = RangeVersionStrategy;
class LatestVersionInEachSeriesStrategy {
    constructor(descending = true) {
        this.descending = descending;
    }
    select() {
        const series = this.descending ? constants_1.CompilerSeries.slice(0).reverse() : constants_1.CompilerSeries;
        const result = [];
        for (const versions of series) {
            const len = versions.length;
            if (len) {
                result.push(versions[len - 1]);
            }
            else {
                throw new Error("Unable to select compiler version from empty series");
            }
        }
        return result;
    }
}
exports.LatestVersionInEachSeriesStrategy = LatestVersionInEachSeriesStrategy;
class LatestAndFirstVersionInEachSeriesStrategy {
    constructor(descending = true) {
        this.descending = descending;
    }
    select() {
        const series = this.descending ? constants_1.CompilerSeries.slice(0).reverse() : constants_1.CompilerSeries;
        const result = [];
        for (const versions of series) {
            const len = versions.length;
            if (len > 1) {
                result.push(versions[len - 1], versions[0]);
            }
            else if (len === 1) {
                result.push(versions[len - 1]);
            }
            else {
                throw new Error("Unable to select compiler version from empty series");
            }
        }
        return result;
    }
}
exports.LatestAndFirstVersionInEachSeriesStrategy = LatestAndFirstVersionInEachSeriesStrategy;
class VersionDetectionStrategy {
    constructor(sources, fallback, descending = true) {
        this.sources = sources.map(misc_1.bytesToString);
        this.fallback = fallback;
        this.descending = descending;
    }
    select() {
        const specifiers = [];
        for (const source of this.sources) {
            specifiers.push(...(0, version_1.extractSpecifiersFromSource)(source));
        }
        if (specifiers.length) {
            const versions = (0, version_1.getCompilerVersionsBySpecifiers)(specifiers, constants_1.CompilerVersions);
            if (versions.length) {
                return this.descending ? versions.reverse() : versions;
            }
        }
        return this.fallback.select();
    }
}
exports.VersionDetectionStrategy = VersionDetectionStrategy;
//# sourceMappingURL=compiler_selection.js.map