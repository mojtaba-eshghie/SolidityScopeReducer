"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadSupportedCompilers = exports.getCompilerForVersion = exports.getCompilerLocalPath = exports.WasmCompiler = exports.NativeCompiler = exports.Compiler = void 0;
const axios_1 = __importDefault(require("axios"));
const child_process_1 = require("child_process");
const crypto_1 = __importDefault(require("crypto"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const __1 = require("..");
const misc_1 = require("../../misc");
const version_1 = require("../version");
const md_1 = require("./md");
class Compiler {
    constructor(version, path) {
        this.version = version;
        this.path = path;
    }
}
exports.Compiler = Compiler;
class NativeCompiler extends Compiler {
    async compile(input) {
        const child = (0, child_process_1.spawn)(this.path, ["--standard-json"], {});
        return new Promise((resolve, reject) => {
            child.stdin.write(JSON.stringify(input), "utf-8");
            child.stdin.end();
            let stdout = "";
            let stderr = "";
            child.stdout.on("data", (data) => {
                stdout += data;
            });
            child.stderr.on("data", (data) => {
                stderr += data;
            });
            child.on("close", (code) => {
                if (code !== 0) {
                    reject(`Compiler exited with code ${code}, stderr: ${stderr}`);
                    return;
                }
                if (stderr !== "") {
                    reject(`Compiler exited with non-empty stderr: ${stderr}`);
                    return;
                }
                let outJson;
                try {
                    outJson = JSON.parse(stdout);
                }
                catch (e) {
                    reject(e);
                    return;
                }
                resolve(outJson);
            });
        });
    }
}
exports.NativeCompiler = NativeCompiler;
class WasmCompiler extends Compiler {
    async compile(input) {
        const solc = require("solc");
        const module = require(this.path);
        const wrappedModule = solc.setupMethods(module);
        const output = wrappedModule.compile(JSON.stringify(input));
        return JSON.parse(output);
    }
}
exports.WasmCompiler = WasmCompiler;
function getCompilerLocalPath(prefix, compilerFileName) {
    const compilerLocalPath = path_1.default.join(md_1.CACHE_DIR, prefix, compilerFileName);
    (0, misc_1.assert)((0, md_1.isSubDir)(compilerLocalPath, md_1.CACHE_DIR), `Path ${compilerLocalPath} escapes from cache dir ${md_1.CACHE_DIR}`);
    return compilerLocalPath;
}
exports.getCompilerLocalPath = getCompilerLocalPath;
async function getCompilerForVersion(version, kind) {
    (0, misc_1.assert)((0, version_1.isExact)(version), "Version string must contain exact SemVer-formatted version without any operators");
    let prefix;
    if (kind === __1.CompilerKind.Native) {
        prefix = (0, md_1.getCompilerPrefixForOs)();
    }
    else if (kind === __1.CompilerKind.WASM) {
        prefix = "wasm";
    }
    else {
        throw new Error(`Unsupported compiler kind "${kind}"`);
    }
    (0, misc_1.assert)(__1.CompilerVersions.includes(version), `Unsupported ${kind} compiler version ${version}`);
    if (prefix === undefined) {
        return undefined;
    }
    const md = await (0, md_1.getCompilerMDForPlatform)(prefix, version);
    const compilerFileName = md.releases[version];
    if (compilerFileName === undefined) {
        return undefined;
    }
    const compilerLocalPath = getCompilerLocalPath(prefix, compilerFileName);
    if (!fs_extra_1.default.existsSync(compilerLocalPath)) {
        const build = md.builds.find((b) => b.version === version);
        (0, misc_1.assert)(build !== undefined, `Unable to find build metadata for ${prefix} compiler ${version} in "list.json"`);
        const response = await axios_1.default.get(`${md_1.BINARIES_URL}/${prefix}/${compilerFileName}`, {
            responseType: "arraybuffer"
        });
        const buf = Buffer.from(response.data);
        const hash = crypto_1.default.createHash("sha256");
        hash.update(buf);
        const digest = "0x" + hash.digest("hex");
        (0, misc_1.assert)(digest === build.sha256, `Downloaded ${prefix} compiler ${version} hash ${digest} does not match hash ${build.sha256} from "list.json"`);
        /**
         * Native compilers are exe—Åutable files, so give them proper permissions.
         * WASM compilers are loaded by NodeJS, so write them as readonly common files.
         */
        const permissions = kind === __1.CompilerKind.Native ? 0o555 : 0o444;
        await fs_extra_1.default.writeFile(compilerLocalPath, buf, { mode: permissions });
    }
    if (kind === __1.CompilerKind.Native) {
        return new NativeCompiler(version, compilerLocalPath);
    }
    if (kind === __1.CompilerKind.WASM) {
        return new WasmCompiler(version, compilerLocalPath);
    }
    throw new Error(`Unable to detemine compiler constructor for kind "${kind}"`);
}
exports.getCompilerForVersion = getCompilerForVersion;
async function* downloadSupportedCompilers(kinds) {
    for (const compilerKind of kinds) {
        for (const version of __1.CompilerVersions) {
            const compiler = await getCompilerForVersion(version, compilerKind);
            (0, misc_1.assert)(compiler !== undefined, `Expected {0} compiler v{1} to be defined`, compilerKind, version);
            yield compiler;
        }
    }
}
exports.downloadSupportedCompilers = downloadSupportedCompilers;
//# sourceMappingURL=compiler.js.map