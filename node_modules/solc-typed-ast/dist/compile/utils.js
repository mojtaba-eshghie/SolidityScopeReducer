"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileJson = exports.compileJsonData = exports.compileSol = exports.compileSourceString = exports.detectCompileErrors = exports.compile = exports.parsePathRemapping = exports.CompileFailedError = exports.CompileInferenceError = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const _1 = require(".");
const misc_1 = require("../misc");
const compiler_selection_1 = require("./compiler_selection");
const constants_1 = require("./constants");
const inference_1 = require("./inference");
const input_1 = require("./input");
class CompileInferenceError extends Error {
}
exports.CompileInferenceError = CompileInferenceError;
class CompileFailedError extends Error {
    constructor(entries) {
        super();
        this.failures = entries;
        const formattedErrorStr = entries.map((entry) => `==== ${entry.compilerVersion} ====:\n ${entry.errors.join("\n")}\n`);
        this.message = `Compiler Errors: ${formattedErrorStr}`;
    }
}
exports.CompileFailedError = CompileFailedError;
function consistentlyContainsOneOf(sources, ...properties) {
    const sections = Object.values(sources);
    for (const property of properties) {
        if (sections.every((section) => property in section)) {
            return true;
        }
    }
    return false;
}
function parsePathRemapping(remapping) {
    const rxRemapping = /^(([^:]*):)?([^=]*)=(.+)$/;
    const result = remapping.map((entry) => {
        const matches = entry.match(rxRemapping);
        if (matches === null) {
            throw new Error(`Invalid remapping entry "${entry}"`);
        }
        return [matches[2] === undefined ? "" : matches[2], matches[3], matches[4]];
    });
    return result;
}
exports.parsePathRemapping = parsePathRemapping;
function fillFilesFromSources(files, sources) {
    for (const [fileName, section] of Object.entries(sources)) {
        if (section && typeof section.source === "string") {
            files.set(fileName, (0, misc_1.stringToBytes)(section.source));
        }
    }
}
function getCompilerVersionStrategy(sources, versionOrStrategy) {
    if (versionOrStrategy === "auto") {
        return new compiler_selection_1.VersionDetectionStrategy(sources, new compiler_selection_1.LatestVersionInEachSeriesStrategy());
    }
    if (typeof versionOrStrategy === "string") {
        return new compiler_selection_1.RangeVersionStrategy([versionOrStrategy]);
    }
    return versionOrStrategy;
}
async function compile(files, remapping, version, compilationOutput = [constants_1.CompilationOutput.ALL], compilerSettings, kind = constants_1.CompilerKind.WASM) {
    const compilerInput = (0, input_1.createCompilerInput)(files, remapping, compilationOutput, compilerSettings);
    const compiler = await (0, _1.getCompilerForVersion)(version, kind);
    (0, misc_1.assert)(compiler !== undefined, `Couldn't find "${kind}" compiler for version ${version} for current platform`);
    return compiler.compile(compilerInput);
}
exports.compile = compile;
function detectCompileErrors(data) {
    const errors = [];
    if (data.errors instanceof Array) {
        for (const error of data.errors) {
            const typeOf = typeof error;
            if (typeOf === "object") {
                /**
                 * Solc >= 0.5
                 */
                if (error.severity === "error") {
                    errors.push(error.formattedMessage);
                }
            }
            else if (typeOf === "string") {
                /**
                 * Solc < 0.5
                 */
                if (!error.match("Warning")) {
                    errors.push(error);
                }
            }
        }
    }
    return errors;
}
exports.detectCompileErrors = detectCompileErrors;
async function compileSourceString(fileName, sourceCode, version, pathOptions = {}, compilationOutput = [constants_1.CompilationOutput.ALL], compilerSettings, kind) {
    const basePath = pathOptions.basePath === undefined ? path_1.default.dirname(fileName) : pathOptions.basePath;
    const includePath = pathOptions.includePath;
    const remapping = pathOptions.remapping || [];
    const inferredRemappings = new Map();
    const fsResolver = new _1.FileSystemResolver(basePath, includePath);
    const npmResolver = new _1.LocalNpmResolver(basePath, inferredRemappings);
    const resolvers = [fsResolver, npmResolver];
    const parsedRemapping = parsePathRemapping(remapping);
    const files = new Map([[fileName, (0, misc_1.stringToBytes)(sourceCode)]]);
    const resolvedFileNames = new Map([[fileName, fileName]]);
    await (0, inference_1.findAllFiles)(files, resolvedFileNames, parsedRemapping, resolvers);
    const compilerVersionStrategy = getCompilerVersionStrategy([...files.values()], version);
    const failures = [];
    for (const compilerVersion of compilerVersionStrategy.select()) {
        const data = await compile(files, remapping, compilerVersion, compilationOutput, compilerSettings, kind);
        const errors = detectCompileErrors(data);
        if (errors.length === 0) {
            return {
                data,
                compilerVersion,
                files,
                resolvedFileNames,
                inferredRemappings
            };
        }
        failures.push({ compilerVersion, errors });
    }
    throw new CompileFailedError(failures);
}
exports.compileSourceString = compileSourceString;
async function compileSol(input, version, pathOptions = {}, compilationOutput = [constants_1.CompilationOutput.ALL], compilerSettings, kind) {
    const fileNames = typeof input === "string" ? [input] : input;
    (0, misc_1.assert)(fileNames.length > 0, "There must be at least one file to compile");
    const inferredRemappings = new Map();
    const fsResolver = new _1.FileSystemResolver(pathOptions.basePath, pathOptions.includePath);
    const npmResolver = new _1.LocalNpmResolver(pathOptions.basePath, inferredRemappings);
    const resolvers = [fsResolver, npmResolver];
    const remapping = pathOptions.remapping || [];
    const parsedRemapping = parsePathRemapping(remapping);
    const files = new Map();
    const resolvedFileNames = new Map();
    const visited = new Set();
    const isDynamicBasePath = pathOptions.basePath === undefined;
    for (const fileName of fileNames) {
        const resolvedFileName = fsResolver.resolve(fileName);
        (0, misc_1.assert)(resolvedFileName !== undefined, `Unable to find "${fileName}"`);
        const sourceCode = await fs_extra_1.default.readFile(resolvedFileName);
        if (isDynamicBasePath) {
            const basePath = path_1.default.dirname(resolvedFileName);
            fsResolver.basePath = basePath;
            npmResolver.basePath = basePath;
        }
        files.set(resolvedFileName, sourceCode);
        /**
         * Add self-mapping as we need every key in `files`
         * to also be defined in `resolvedFileNames`
         */
        resolvedFileNames.set(resolvedFileName, resolvedFileName);
        /**
         * Set the resolved path for every file passed in by the caller as well
         */
        resolvedFileNames.set(fileName, resolvedFileName);
        await (0, inference_1.findAllFiles)(files, resolvedFileNames, parsedRemapping, resolvers, visited);
    }
    const compilerVersionStrategy = getCompilerVersionStrategy([...files.values()], version);
    const failures = [];
    for (const compilerVersion of compilerVersionStrategy.select()) {
        const data = await compile(files, remapping, compilerVersion, compilationOutput, compilerSettings, kind);
        const errors = detectCompileErrors(data);
        if (errors.length === 0) {
            return {
                data,
                compilerVersion,
                files,
                resolvedFileNames,
                inferredRemappings
            };
        }
        failures.push({ compilerVersion, errors });
    }
    throw new CompileFailedError(failures);
}
exports.compileSol = compileSol;
async function compileJsonData(fileName, data, version, compilationOutput = [constants_1.CompilationOutput.ALL], compilerSettings, kind) {
    const files = new Map();
    if (!(data instanceof Object && data.sources instanceof Object)) {
        throw new Error(`Unable to find required properties in "${fileName}"`);
    }
    const sources = data.sources;
    const resolvedFileNames = new Map(Object.keys(sources).map((x) => [x, x]));
    if (consistentlyContainsOneOf(sources, "ast", "legacyAST", "AST")) {
        const compilerVersion = undefined;
        const errors = detectCompileErrors(data);
        if (errors.length) {
            throw new CompileFailedError([{ compilerVersion, errors }]);
        }
        fillFilesFromSources(files, sources);
        return {
            data,
            compilerVersion,
            files,
            resolvedFileNames,
            inferredRemappings: new Map()
        };
    }
    if (consistentlyContainsOneOf(sources, "source")) {
        for (const [fileName, fileData] of Object.entries(sources)) {
            files.set(fileName, (0, misc_1.stringToBytes)(fileData.source));
        }
        const compilerVersionStrategy = getCompilerVersionStrategy([...files.values()], version);
        const failures = [];
        for (const compilerVersion of compilerVersionStrategy.select()) {
            const compileData = await compile(files, [], compilerVersion, compilationOutput, compilerSettings, kind);
            const errors = detectCompileErrors(compileData);
            if (errors.length === 0) {
                return {
                    data: compileData,
                    compilerVersion,
                    files,
                    resolvedFileNames,
                    inferredRemappings: new Map()
                };
            }
            failures.push({ compilerVersion, errors });
        }
        throw new CompileFailedError(failures);
    }
    throw new Error("Unable to process data structure: neither consistent AST or code values are present");
}
exports.compileJsonData = compileJsonData;
async function compileJson(fileName, version, compilationOutput = [constants_1.CompilationOutput.ALL], compilerSettings, kind) {
    const data = await fs_extra_1.default.readJSON(fileName);
    return compileJsonData(fileName, data, version, compilationOutput, compilerSettings, kind);
}
exports.compileJson = compileJson;
//# sourceMappingURL=utils.js.map