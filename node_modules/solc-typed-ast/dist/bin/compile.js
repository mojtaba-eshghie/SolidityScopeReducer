#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
const fs_extra_1 = __importDefault(require("fs-extra"));
const __1 = require("..");
var CompileMode;
(function (CompileMode) {
    CompileMode["Auto"] = "auto";
    CompileMode["Sol"] = "sol";
    CompileMode["Json"] = "json";
})(CompileMode || (CompileMode = {}));
const compileModes = Object.values(CompileMode);
function terminate(message, exitCode = 0) {
    if (message !== undefined) {
        if (exitCode === 0) {
            console.log(message);
        }
        else {
            console.error(message);
        }
    }
    process.exit(exitCode);
}
function error(message) {
    terminate(message, 1);
}
(async () => {
    const { version } = require("../../package.json");
    const program = new commander_1.Command();
    program
        .name("sol-ast-compile")
        .description("Compiles Solidity input and prints typed AST.")
        .version(version, "-v, --version", "Print package version.")
        .helpOption("-h, --help", "Print help message.");
    program.argument("[file(s)]", "Either one or more Solidity files, one JSON compiler output file.");
    program
        .option("--solidity-versions", "Print information about supported Solidity versions.")
        .option("--stdin", "Read input from STDIN instead of files.")
        .option("--mode <mode>", `One of the following input modes: "${CompileMode.Sol}" (Solidity source), "${CompileMode.Json}" (JSON compiler artifact), "${CompileMode.Auto}" (try to detect by file extension)`, CompileMode.Auto)
        .option("--compiler-version <compilerVersion>", `Solc version to use: ${__1.LatestCompilerVersion} (exact SemVer version specifier), auto (try to detect suitable compiler version)`, "auto")
        .option("--compiler-kind <compilerKind>", `Type of Solidity compiler to use. Currently supported values are "${__1.CompilerKind.WASM}" or "${__1.CompilerKind.Native}".`, __1.CompilerKind.WASM)
        .option("--path-remapping <pathRemapping>", "Path remapping input for Solc.")
        .option("--base-path <basePath>", "Base path for compiler to look for files Solc.")
        .option("--include-path <includePath...>", "Include paths for compiler to additinally look for files. Supports multiple entries.")
        .option("--compiler-settings <compilerSettings>", `Additional settings passed to the solc compiler in the form of a JSON string (e.g. '{"optimizer": {"enabled": true, "runs": 200}}'). Note the double quotes. For more details see https://docs.soliditylang.org/en/latest/using-the-compiler.html#input-description.`)
        .option("--raw", "Print raw Solc compilation output.")
        .option("--with-sources", 'When used with "raw", adds "source" property with source files content to the compiler artifact.')
        .option("--tree", "Print short tree of parent-child relations in AST.")
        .option("--source", "Print source code, assembled from Solc-generated AST.")
        .option("--xpath <xpath>", "XPath selector to perform for each source unit.")
        .option("--depth <depth>", 'Number of children for each of AST node to print. Minimum value is 0. Not affects "raw", "tree" and "source".', `${Number.MAX_SAFE_INTEGER}`)
        .option("--locate-compiler-cache", "Print location of current compiler cache directory (used to store downloaded compilers).")
        .option("--download-compilers <compilerKind...>", `Download specified kind of supported compilers to compiler cache. Supports multiple entries.`);
    program.parse(process.argv);
    const args = program.args;
    const options = program.opts();
    if (options.solidityVersions) {
        const message = [
            "Latest supported version: " + __1.LatestCompilerVersion,
            "",
            `All supported versions (${__1.CompilerVersions.length} total):`,
            ...__1.CompilerVersions
        ].join("\n");
        terminate(message);
    }
    if (options.locateCompilerCache) {
        terminate(__1.CACHE_DIR);
    }
    if (options.downloadCompilers) {
        const compilerKinds = options.downloadCompilers.map((kind) => {
            if (__1.PossibleCompilerKinds.has(kind)) {
                return kind;
            }
            error(`Invalid compiler kind "${kind}". Possible values: ${[
                ...__1.PossibleCompilerKinds.values()
            ].join(", ")}.`);
        });
        console.log(`Downloading compilers (${compilerKinds.join(", ")}) to current compiler cache:`);
        for await (const compiler of (0, __1.downloadSupportedCompilers)(compilerKinds)) {
            console.log(`${compiler.path} (${compiler.constructor.name} v${compiler.version})`);
        }
        terminate();
    }
    if (options.help || (!args.length && !options.stdin)) {
        terminate(program.helpInformation());
    }
    const stdin = options.stdin;
    const mode = options.mode;
    const compilerKind = options.compilerKind;
    if (!__1.PossibleCompilerKinds.has(compilerKind)) {
        error(`Invalid compiler kind "${compilerKind}". Possible values: ${[
            ...__1.PossibleCompilerKinds.values()
        ].join(", ")}.`);
    }
    if (!compileModes.includes(mode)) {
        error(`Invalid mode "${mode}". Possible values: ${compileModes.join(", ")}.`);
    }
    const compilerVersion = options.compilerVersion;
    if (!(compilerVersion === "auto" || (0, __1.isExact)(compilerVersion))) {
        const message = [
            `Invalid compiler version "${compilerVersion}".`,
            'Possible values: "auto" or exact version string.'
        ].join(" ");
        error(message);
    }
    const pathOptions = {
        remapping: options.pathRemapping ? options.pathRemapping.split(";") : [],
        basePath: options.basePath,
        includePath: options.includePath
    };
    let compilerSettings = undefined;
    if (options.compilerSettings) {
        try {
            compilerSettings = JSON.parse(options.compilerSettings);
        }
        catch (e) {
            error(`Invalid compiler settings '${options.compilerSettings}'. Compiler settings must be a valid JSON object (${e}).`);
        }
    }
    const compilationOutput = [__1.CompilationOutput.ALL];
    let result;
    try {
        if (stdin) {
            if (mode === "auto") {
                error('Mode "auto" is not supported for the input from STDIN. Explicitly specify "mode" as "sol" or "json" instead.');
            }
            const fileName = "stdin";
            const content = await fs_extra_1.default.readFile(process.stdin.fd, { encoding: "utf-8" });
            result =
                mode === "json"
                    ? await (0, __1.compileJsonData)(fileName, JSON.parse(content), compilerVersion, compilationOutput, compilerSettings, compilerKind)
                    : await (0, __1.compileSourceString)(fileName, content, compilerVersion, pathOptions, compilationOutput, compilerSettings, compilerKind);
        }
        else {
            const fileNames = args;
            const singleFileName = fileNames[0];
            const iSingleFileName = singleFileName.toLowerCase();
            let isSol;
            let isJson;
            if (mode === "auto") {
                isSol = iSingleFileName.endsWith(".sol");
                isJson = iSingleFileName.endsWith(".json");
            }
            else {
                isSol = mode === "sol";
                isJson = mode === "json";
            }
            if (isSol) {
                result = await (0, __1.compileSol)(fileNames, compilerVersion, pathOptions, compilationOutput, compilerSettings, compilerKind);
            }
            else if (isJson) {
                result = await (0, __1.compileJson)(singleFileName, compilerVersion, compilationOutput, compilerSettings, compilerKind);
            }
            else {
                error("Unable to auto-detect mode by the file name: " + singleFileName);
            }
        }
    }
    catch (e) {
        if (e instanceof __1.CompileFailedError) {
            console.error("Compile errors encountered:");
            for (const failure of e.failures) {
                console.error(failure.compilerVersion
                    ? `SolcJS ${failure.compilerVersion}:`
                    : "Unknown compiler:");
                for (const error of failure.errors) {
                    console.error(error);
                }
            }
            error("Unable to compile due to errors above.");
        }
        error(e.message);
    }
    const { data, files } = result;
    if (options.raw) {
        if (options.withSources && files.size > 0) {
            if (!data.sources) {
                data.sources = {};
            }
            for (const [key, value] of files) {
                if (!data.sources[key]) {
                    data.sources[key] = {};
                }
                data.sources[key].source = (0, __1.bytesToString)(value);
            }
        }
        const output = JSON.stringify(data, undefined, 4);
        terminate(output);
    }
    const separator = "-".repeat(60);
    const depth = parseInt(options.depth);
    const reader = new __1.ASTReader();
    const units = reader.read(data, __1.ASTKind.Any, files);
    if (options.tree) {
        const INDENT = "|   ";
        const writer = (inference, node) => {
            const level = node.getParents().length;
            const indent = INDENT.repeat(level);
            let message = node.type + " #" + node.id;
            if (node instanceof __1.SourceUnit) {
                message += " -> " + node.absolutePath;
            }
            else if (node instanceof __1.ContractDefinition) {
                message += " -> " + node.kind + " " + node.name;
                const interfaceId = inference.interfaceId(node);
                if (interfaceId) {
                    message += ` [id: ${interfaceId}]`;
                }
            }
            else if (node instanceof __1.FunctionDefinition) {
                const signature = node.vScope instanceof __1.ContractDefinition &&
                    (node.visibility === __1.FunctionVisibility.Public ||
                        node.visibility === __1.FunctionVisibility.External)
                    ? inference.signature(node)
                    : undefined;
                if (signature) {
                    const selector = inference.signatureHash(node);
                    message += ` -> ${signature} [selector: ${selector}]`;
                }
                else {
                    message += ` -> ${node.kind}`;
                }
            }
            else if (node instanceof __1.ErrorDefinition || node instanceof __1.EventDefinition) {
                const signature = inference.signature(node);
                const selector = inference.signatureHash(node);
                message += ` -> ${signature} [selector: ${selector}]`;
            }
            else if (node instanceof __1.VariableDeclaration) {
                if (node.stateVariable) {
                    message += ` -> ${node.typeString} ${node.visibility} ${node.name}`;
                    if (node.visibility === __1.StateVariableVisibility.Public) {
                        const signature = inference.signature(node);
                        const selector = inference.signatureHash(node);
                        message += ` [getter: ${signature}, selector: ${selector}]`;
                    }
                }
                else {
                    message +=
                        node.name === ""
                            ? ` -> ${node.typeString}`
                            : ` -> ${node.typeString} ${node.name}`;
                }
            }
            console.log(indent + message);
        };
        const compilerVersion = result.compilerVersion || __1.LatestCompilerVersion;
        const inference = new __1.InferType(compilerVersion);
        for (const unit of units) {
            unit.walk(writer.bind(undefined, inference));
            console.log();
        }
        terminate();
    }
    if (options.xpath) {
        const selector = options.xpath;
        const formatter = new __1.ASTNodeFormatter();
        for (const unit of units) {
            const xp = new __1.XPath(unit);
            const queryResult = xp.query(selector);
            const output = queryResult instanceof Array
                ? queryResult.map((value) => formatter.format(value, depth)).join("\n")
                : formatter.format(queryResult, depth);
            console.log(unit.sourceEntryKey);
            console.log(separator);
            console.log(output);
        }
        terminate();
    }
    if (options.source) {
        let targetCompilerVersion;
        if (result.compilerVersion) {
            targetCompilerVersion = result.compilerVersion;
        }
        else if (compilerVersion !== "auto") {
            targetCompilerVersion = compilerVersion;
        }
        else {
            targetCompilerVersion = __1.LatestCompilerVersion;
        }
        const formatter = new __1.PrettyFormatter(4, 0);
        const writer = new __1.ASTWriter(__1.DefaultASTWriterMapping, formatter, targetCompilerVersion);
        for (const unit of units) {
            console.log("// " + separator);
            console.log("// " + unit.absolutePath);
            console.log("// " + separator);
            console.log(writer.write(unit));
        }
        terminate();
    }
    for (const unit of units) {
        console.log(unit.print(depth));
    }
    terminate();
})().catch((e) => {
    error(e.message);
});
//# sourceMappingURL=compile.js.map