"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fmt = exports.ppMap = exports.ppSet = exports.ppIter = exports.ppArr = exports.pp = exports.isPPAble = void 0;
const ast_1 = require("../ast");
function isPPAble(value) {
    return value ? typeof value.pp === "function" : false;
}
exports.isPPAble = isPPAble;
function pp(value) {
    if (value instanceof ast_1.ASTNode) {
        return value.type + " #" + value.id;
    }
    if (value instanceof ast_1.ASTContext) {
        return value.constructor.name + " #" + value.id;
    }
    if (value === undefined) {
        return "<undefined>";
    }
    if (value === null ||
        typeof value === "string" ||
        typeof value === "number" ||
        typeof value === "boolean" ||
        typeof value === "bigint") {
        return String(value);
    }
    if (isPPAble(value)) {
        return value.pp();
    }
    if (value instanceof Array) {
        return ppArr(value);
    }
    if (value instanceof Set) {
        return ppSet(value);
    }
    if (value instanceof Map) {
        return ppMap(value);
    }
    if (typeof value[Symbol.iterator] === "function") {
        return ppIter(value);
    }
    throw new Error("Unhandled value in pp(): " + String(value));
}
exports.pp = pp;
function ppArr(array, separator = ",", start = "[", end = "]") {
    return start + array.map(pp).join(separator) + end;
}
exports.ppArr = ppArr;
function ppIter(iter, separator = ",", start = "[", end = "]") {
    const parts = [];
    for (const part of iter) {
        parts.push(pp(part));
    }
    return start + parts.join(separator) + end;
}
exports.ppIter = ppIter;
function ppSet(set, separator = ",", start = "{", end = "}") {
    return ppIter(set, separator, start, end);
}
exports.ppSet = ppSet;
function ppMap(map, separator = ",", keyValueSeparator = ":", start = "{", end = "}") {
    const parts = [];
    for (const [name, val] of map.entries()) {
        parts.push(pp(name) + keyValueSeparator + pp(val));
    }
    return start + parts.join(separator) + end;
}
exports.ppMap = ppMap;
function fmt(message, ...details) {
    if (details.length) {
        const nodes = [];
        for (let i = 0; i < details.length; i++) {
            const detail = details[i];
            const part = pp(detail);
            if (detail instanceof ast_1.ASTNode) {
                nodes.push(detail);
            }
            message = message.replace(new RegExp("\\{" + i + "\\}", "g"), part);
        }
        if (nodes.length) {
            if (!message.endsWith(".")) {
                message += ".";
            }
            message += "\n\n" + nodes.map((node) => node.print()).join("\n");
        }
    }
    return message;
}
exports.fmt = fmt;
//# sourceMappingURL=pretty_printing.js.map